(window["canvasWebpackJsonp"] = window["canvasWebpackJsonp"] || []).push([[96],{

/***/ "+aUL":
/*!********************************************************!*\
  !*** ./node_modules/normalize-scroll-left/esm/main.js ***!
  \********************************************************/
/*! exports provided: _setScrollType, detectScrollType, getNormalizedScrollLeft, setNormalizedScrollLeft */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_setScrollType\", function() { return _setScrollType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"detectScrollType\", function() { return detectScrollType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getNormalizedScrollLeft\", function() { return getNormalizedScrollLeft; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setNormalizedScrollLeft\", function() { return setNormalizedScrollLeft; });\n// Based on https://github.com/react-bootstrap/dom-helpers/blob/master/src/util/inDOM.js\r\nvar inDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\r\nvar cachedType;\r\nfunction _setScrollType(type) {\r\n    cachedType = type;\r\n}\r\n// Based on the jquery plugin https://github.com/othree/jquery.rtl-scroll-type\r\nfunction detectScrollType() {\r\n    if (cachedType) {\r\n        return cachedType;\r\n    }\r\n    if (!inDOM || !window.document.body) {\r\n        return 'indeterminate';\r\n    }\r\n    var dummy = window.document.createElement('div');\r\n    dummy.appendChild(document.createTextNode('ABCD'));\r\n    dummy.dir = 'rtl';\r\n    dummy.style.fontSize = '14px';\r\n    dummy.style.width = '4px';\r\n    dummy.style.height = '1px';\r\n    dummy.style.position = 'absolute';\r\n    dummy.style.top = '-1000px';\r\n    dummy.style.overflow = 'scroll';\r\n    document.body.appendChild(dummy);\r\n    cachedType = 'reverse';\r\n    if (dummy.scrollLeft > 0) {\r\n        cachedType = 'default';\r\n    }\r\n    else {\r\n        dummy.scrollLeft = 2;\r\n        if (dummy.scrollLeft < 2) {\r\n            cachedType = 'negative';\r\n        }\r\n    }\r\n    document.body.removeChild(dummy);\r\n    return cachedType;\r\n}\r\n// Based on https://stackoverflow.com/a/24394376\r\nfunction getNormalizedScrollLeft(element, direction) {\r\n    var scrollLeft = element.scrollLeft;\r\n    // Perform the calculations only when direction is rtl to avoid messing up the ltr behavior\r\n    if (direction !== 'rtl') {\r\n        return scrollLeft;\r\n    }\r\n    var type = detectScrollType();\r\n    if (type === 'indeterminate') {\r\n        return Number.NaN;\r\n    }\r\n    switch (type) {\r\n        case 'negative':\r\n            return element.scrollWidth - element.clientWidth + scrollLeft;\r\n        case 'reverse':\r\n            return element.scrollWidth - element.clientWidth - scrollLeft;\r\n    }\r\n    return scrollLeft;\r\n}\r\nfunction setNormalizedScrollLeft(element, scrollLeft, direction) {\r\n    // Perform the calculations only when direction is rtl to avoid messing up the ltr behavior\r\n    if (direction !== 'rtl') {\r\n        element.scrollLeft = scrollLeft;\r\n        return;\r\n    }\r\n    var type = detectScrollType();\r\n    if (type === 'indeterminate') {\r\n        return;\r\n    }\r\n    switch (type) {\r\n        case 'negative':\r\n            element.scrollLeft = element.clientWidth - element.scrollWidth + scrollLeft;\r\n            break;\r\n        case 'reverse':\r\n            element.scrollLeft = element.scrollWidth - element.clientWidth - scrollLeft;\r\n            break;\r\n        default:\r\n            element.scrollLeft = scrollLeft;\r\n            break;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/normalize-scroll-left/esm/main.js?");

/***/ }),

/***/ "C5mO":
/*!******************************************!*\
  !*** ./packages/slickgrid/slick.grid.js ***!
  \******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"ouhR\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _slick_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slick.core */ \"sbct\");\n/* harmony import */ var _jquery_event_drag_2_2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jquery.event.drag-2.2 */ \"o6Wt\");\n/* harmony import */ var _canvas_i18n_rtlHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @canvas/i18n/rtlHelper */ \"uYtQ\");\n/* harmony import */ var normalize_scroll_left__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! normalize-scroll-left */ \"+aUL\");\n/* harmony import */ var jqueryui_sortable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! jqueryui/sortable */ \"bgJ8\");\n/*\n * Copyright (c) 2010 Michael Leibman, http://github.com/mleibman/slickgrid\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n\n\n\n/*\n * These eslint configurations are just becase that's how this file was\n * originally written and we want the file to remain as much like the original\n * source as possible but still want it to tell us about the important stuff.\n */\n\n/* eslint-disable notice/notice, no-var, vars-on-top, prefer-template, object-shorthand, no-use-before-define, max-len, eqeqeq, no-multi-assign, no-cond-assign, one-var */\n\n/* eslint linebreak-style: [\"error\", \"windows\"] */\n\n/**\n * @license\n * (c) 2009-2013 Michael Leibman\n * michael{dot}leibman{at}gmail{dot}com\n * http://github.com/mleibman/slickgrid\n *\n * Distributed under MIT license.\n * All rights reserved.\n *\n * SlickGrid v2.2\n *\n * NOTES:\n *     Cell/row DOM manipulations are done directly bypassing jQuery's DOM manipulation methods.\n *     This increases the speed dramatically, but can only be done safely because there are no event handlers\n *     or data associated with any cell/row DOM nodes.  Cell editors must make sure they implement .destroy()\n *     and do proper cleanup.\n */\n// make sure required JavaScript modules are loaded\n\nif (typeof jquery__WEBPACK_IMPORTED_MODULE_0___default.a === 'undefined') {\n  throw 'SlickGrid requires jquery module to be loaded';\n}\n\nif (!jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn.drag) {\n  throw 'SlickGrid requires jquery.event.drag module to be loaded';\n}\n\nif (typeof Slick === 'undefined') {\n  throw 'slick.core.js not loaded';\n}\n\n;\n\n(function ($) {\n  // Slick.Grid\n  $.extend(true, window, {\n    Slick: {\n      Grid: SlickGrid\n    }\n  }); // shared across all grids on the page\n\n  var scrollbarDimensions;\n  var maxSupportedCssHeight; // browser's breaking point\n  // ////////////////////////////////////////////////////////////////////////////////////////////\n  // SlickGrid class implementation (available as Slick.Grid)\n\n  /**\n   * Creates a new instance of the grid.\n   * @class SlickGrid\n   * @constructor\n   * @param {Node}              container   Container node to create the grid in.\n   * @param {Array,Object}      data        An array of objects for databinding.\n   * @param {Array}             columns     An array of column definitions.\n   * @param {Object}            options     Grid options.\n   * */\n\n  function SlickGrid(container, data, columns, options) {\n    // settings\n    var defaults = {\n      explicitInitialization: false,\n      rowHeight: 25,\n      defaultColumnWidth: 80,\n      enableAddRow: false,\n      leaveSpaceForNewRows: false,\n      editable: false,\n      autoEdit: true,\n      enableCellNavigation: true,\n      enableColumnReorder: true,\n      asyncEditorLoading: false,\n      asyncEditorLoadDelay: 100,\n      forceFitColumns: false,\n      enableAsyncPostRender: false,\n      asyncPostRenderDelay: 50,\n      autoHeight: false,\n      editorLock: Slick.GlobalEditorLock,\n      showHeaderRow: false,\n      headerRowHeight: 25,\n      showTopPanel: false,\n      topPanelHeight: 25,\n      formatterFactory: null,\n      editorFactory: null,\n      cellFlashingCssClass: 'flashing',\n      selectedCellCssClass: 'selected',\n      multiSelect: true,\n      enableTextSelectionOnCells: false,\n      dataItemColumnValueExtractor: null,\n      fullWidthRows: false,\n      multiColumnSort: false,\n      defaultFormatter: defaultFormatter,\n      forceSyncScrolling: false,\n      numberOfColumnsToFreeze: 0 // Number of left-most columns to freeze from scrolling\n\n    };\n    var columnDefaults = {\n      name: '',\n      resizable: true,\n      sortable: false,\n      minWidth: 30,\n      rerenderOnResize: false,\n      headerCssClass: null,\n      defaultSortAsc: true,\n      focusable: true,\n      selectable: true\n    }; // scroller\n\n    var th; // virtual height\n\n    var h; // real scrollable height\n\n    var ph; // page height\n\n    var n; // number of pages\n\n    var cj; // \"jumpiness\" coefficient\n\n    var page = 0; // current page\n\n    var offset = 0; // current page offset\n\n    var vScrollDir = 1; // private\n\n    var initialized = false;\n    var uid = 'slickgrid_' + Math.round(1000000 * Math.random());\n    var self = this;\n    var $focusSink, $focusSink2;\n    var $outerContainer;\n    var $container_0;\n    var $container_1;\n    var $headerScroller_0;\n    var $headerScroller_1;\n    var $headers_0;\n    var $headers_1;\n    var $headerRow_0;\n    var $headerRow_1;\n    var $headerRowScroller_0;\n    var $headerRowScroller_1;\n    var $headerRowSpacer_0;\n    var $headerRowSpacer_1;\n    var $topPanelScroller_0;\n    var $topPanelScroller_1;\n    var $topPanel_0;\n    var $topPanel_1;\n    var $viewport_0;\n    var $viewport_1;\n    var $canvas_0;\n    var $canvas_1;\n    var canvasWidth_0;\n    var canvasWidth_1;\n    var $style;\n    var $boundAncestors;\n    var stylesheet, columnCssRulesB, columnCssRulesF;\n    var viewportH_1;\n    var viewportW_1;\n    var viewportHasHScroll_1;\n    var viewportHasVScroll_1; // viewport_0 will never have scroll bars so the above two vars are only necessary for viewport_1.\n\n    var headerColumnWidthDiff = 0,\n        headerColumnHeightDiff = 0,\n        // border+padding\n    cellWidthDiff = 0,\n        cellHeightDiff = 0;\n    var absoluteColumnMinWidth;\n    var numberOfRows = 0;\n    var tabbingDirection = 1;\n    var activePosX;\n    var activeRow, activeCell;\n    var activeCellNode = null;\n    var currentEditor = null;\n    var serializedEditorValue;\n    var editController;\n    var rowsCache = {};\n    var renderedRows = 0;\n    var numVisibleRows;\n    var prevScrollTop = 0;\n    var scrollTop = 0;\n    var lastRenderedScrollTop = 0;\n    var lastRenderedScrollLeft = 0;\n    var prevScrollLeft = 0;\n    var scrollLeft = 0;\n    var selectionModel;\n    var selectedRows = [];\n    var plugins = [];\n    var cellCssClasses = {};\n    var columnsById = {};\n    var sortColumns = [];\n    var columnPosRear = [];\n    var columnPosFront = []; // async call handles\n\n    var h_editorLoader = null;\n    var h_render = null;\n    var h_postrender = null;\n    var postProcessedRows = {};\n    var postProcessToRow = null;\n    var postProcessFromRow = null; // perf counters\n\n    var counter_rows_rendered = 0;\n    var counter_rows_removed = 0;\n    var rtl = false;\n    var rear = 'left';\n    var front = 'right';\n    var gotoRight;\n    var gotoLeft;\n    var getOffsetRear; // ////////////////////////////////////////////////////////////////////////////////////////////\n    // Initialization\n\n    function init() {\n      $outerContainer = $(container);\n      $container_1 = $outerContainer;\n\n      if ($outerContainer.length < 1) {\n        throw new Error('SlickGrid requires a valid container, ' + container + ' does not exist in the DOM.');\n      } // calculate these only once and share between grid instances\n\n\n      maxSupportedCssHeight = maxSupportedCssHeight || getMaxSupportedCssHeight();\n      scrollbarDimensions = scrollbarDimensions || measureScrollbar();\n      options = $.extend({}, defaults, options);\n      validateAndEnforceOptions();\n      columnDefaults.width = options.defaultColumnWidth;\n      columnsById = {};\n\n      for (var i = 0; i < columns.length; i++) {\n        var m = columns[i] = $.extend({}, columnDefaults, columns[i]);\n        columnsById[m.id] = i;\n\n        if (m.minWidth && m.width < m.minWidth) {\n          m.width = m.minWidth;\n        }\n\n        if (m.maxWidth && m.width > m.maxWidth) {\n          m.width = m.maxWidth;\n        }\n      } // validate loaded JavaScript modules against requested options\n\n\n      if (options.enableColumnReorder && !$.fn.sortable) {\n        throw new Error(\"SlickGrid's 'enableColumnReorder = true' option requires jquery-ui.sortable module to be loaded\");\n      }\n\n      editController = {\n        commitCurrentEdit: commitCurrentEdit,\n        cancelCurrentEdit: cancelCurrentEdit\n      };\n      $outerContainer.empty().css('overflow', 'hidden').css('outline', 0).addClass(uid).addClass('ui-widget');\n      $container_1.empty().css('overflow', 'hidden').css('outline', 0).addClass(uid).addClass('ui-widget');\n\n      if (Object(_canvas_i18n_rtlHelper__WEBPACK_IMPORTED_MODULE_3__[\"isRTL\"])($outerContainer[0])) {\n        rtl = true;\n        rear = 'right';\n        front = 'left';\n        gotoRight = gotoRear;\n        gotoLeft = gotoFront;\n        getOffsetRear = getOffsetRight;\n\n        getScrollLeft = el => Object(normalize_scroll_left__WEBPACK_IMPORTED_MODULE_4__[\"getNormalizedScrollLeft\"])(el, 'rtl');\n\n        setScrollLeft = (el, val) => Object(normalize_scroll_left__WEBPACK_IMPORTED_MODULE_4__[\"setNormalizedScrollLeft\"])(el, val, 'rtl');\n      } // set up a positioning container if needed\n\n\n      if (!/relative|absolute|fixed/.test($outerContainer.css('position'))) {\n        $outerContainer.css('position', 'relative');\n      } // set up a positioning container if needed\n\n\n      if (!/relative|absolute|fixed/.test($container_1.css('position'))) {\n        $container_1.css('position', 'relative');\n      }\n\n      $focusSink = $(\"<div tabIndex='0' hideFocus style='position:fixed;width:0;height:0;top:0;left:0;outline:0;'></div>\").appendTo($outerContainer); // FreezeColumns - Add outerContainer and frozen column structure - Begin\n\n      if (options.numberOfColumnsToFreeze > 0) {\n        var totalWidthOfFrozenColumns = 0;\n        var container_1Width = 0;\n        var containerCSS = {\n          overflow: 'hidden',\n          position: 'absolute',\n          [rear]: 0,\n          top: 0,\n          bottom: 0,\n          outline: 0\n        };\n        var containerClass = uid + ' ui-widget'; // Calculate frozen widths\n\n        for (var i = 0, len = columns.length; i < len; i++) {\n          if (i < options.numberOfColumnsToFreeze) {\n            totalWidthOfFrozenColumns += columns[i].width;\n          } else {\n            break;\n          }\n        }\n\n        $container_0 = $(\"<div class='container_0'></div>\").css($.extend({}, containerCSS, {\n          width: totalWidthOfFrozenColumns\n        })).addClass(containerClass).appendTo($outerContainer);\n        $container_1 = $(\"<div class='container_1'></div>\").css($.extend({}, containerCSS, {\n          [rear]: totalWidthOfFrozenColumns,\n          [front]: 0\n        })).addClass(containerClass).appendTo($outerContainer);\n        $headerScroller_0 = $(\"<div class='headerScroller_0 slick-header ui-state-default' style='overflow:hidden;position:relative;' />\").appendTo($container_0);\n        $headers_0 = $(\"<div class='headers_0 slick-header-columns' style='\" + rear + \":-1000px' />\").appendTo($headerScroller_0);\n        $headerRowScroller_0 = $(\"<div class='headerRowScroller_0 slick-headerrow ui-state-default' style='overflow:hidden;position:relative;' />\").appendTo($container_0);\n        $headerRow_0 = $(\"<div class='headerRow_0 slick-headerrow-columns' />\").appendTo($headerRowScroller_0);\n        $headerRowSpacer_0 = $(\"<div class='headerRowSpacer_0' style='display:block;height:1px;position:absolute;top:0;left:0;'></div>\").appendTo($headerRowScroller_0);\n        $topPanelScroller_0 = $(\"<div class='topPanelScroller_0 slick-top-panel-scroller ui-state-default' style='overflow:hidden;position:relative;' />\").appendTo($container_0);\n        $topPanel_0 = $(\"<div class='topPanel_0 slick-top-panel' style='width:10000px' />\").appendTo($topPanelScroller_0);\n\n        if (!options.showTopPanel) {\n          $topPanelScroller_0.hide();\n        }\n\n        if (!options.showHeaderRow) {\n          $headerRowScroller_0.hide();\n        }\n\n        $viewport_0 = $(\"<div class='viewport_0 slick-viewport' style='width:100%;overflow:hidden;outline:0;position:relative;'>\").appendTo($container_0);\n        $canvas_0 = $(\"<div class='canvas_0 grid-canvas' />\").appendTo($viewport_0);\n      } // FreezeColumns - Add outerContainer and frozen column structure - End\n\n\n      $headerScroller_1 = $(\"<div class='headerScroller_1 slick-header ui-state-default' style='overflow:hidden;position:relative;' />\").appendTo($container_1);\n      $headers_1 = $(\"<div class='headers_1 slick-header-columns' style='\" + rear + \":-1000px' />\").appendTo($headerScroller_1); // FreezeColumns - Set width of headers - Begin\n\n      var headersWidthObj = getHeadersWidth();\n\n      if (options.numberOfColumnsToFreeze > 0) {\n        $headers_0.width(headersWidthObj.frozen + 1000);\n        $headers_1.width(headersWidthObj.nonFrozen);\n      } else {\n        $headers_1.width(headersWidthObj.nonFrozen);\n      } // FreezeColumns - Set width of headers - End\n\n\n      $headerRowScroller_1 = $(\"<div class='headerRowScroller_1 slick-headerrow ui-state-default' style='overflow:hidden;position:relative;' />\").appendTo($container_1);\n      $headerRow_1 = $(\"<div class='headerRow_1 slick-headerrow-columns' />\").appendTo($headerRowScroller_1);\n      $headerRowSpacer_1 = $(\"<div class='headerRowSpacer_1' style='display:block;height:1px;position:absolute;top:0;left:0;'></div>\").appendTo($headerRowScroller_1); // FreezeColumns - Set width of header row spacer - Begin\n\n      var canvasWidthObj = getCanvasWidth();\n      $headerRowSpacer_1.css('width', canvasWidthObj.nonFrozen + scrollbarDimensions.width + 'px');\n\n      if (options.numberOfColumnsToFreeze > 0) {\n        $headerRowSpacer_0.css('width', canvasWidthObj.frozen + 'px');\n      } // FreezeColumns - Set width of header row spacer - End\n\n\n      $topPanelScroller_1 = $(\"<div class='topPanelScroller_1 slick-top-panel-scroller ui-state-default' style='overflow:hidden;position:relative;' />\").appendTo($container_1);\n      $topPanel_1 = $(\"<div class='topPanel_1 slick-top-panel' style='width:10000px' />\").appendTo($topPanelScroller_1);\n\n      if (!options.showTopPanel) {\n        $topPanelScroller_1.hide();\n      }\n\n      if (!options.showHeaderRow) {\n        $headerRowScroller_1.hide();\n      }\n\n      $viewport_1 = $(\"<div class='viewport_1 slick-viewport' style='width:100%;overflow:auto;outline:0;position:relative;'>\").appendTo($container_1);\n      $viewport_1.css('overflow-y', options.autoHeight ? 'hidden' : 'auto');\n      $canvas_1 = $(\"<div class='canvas_1 grid-canvas' />\").appendTo($viewport_1);\n      $focusSink2 = $focusSink.clone().appendTo($outerContainer);\n\n      if (!options.explicitInitialization) {\n        finishInitialization();\n      }\n    }\n\n    function finishInitialization() {\n      if (!initialized) {\n        initialized = true;\n        viewportW_1 = parseFloat($.css($outerContainer[0], 'width', true)); // header columns and cells may have different padding/border skewing width calculations (box-sizing, hello?)\n        // calculate the diff so we can set consistent sizes\n\n        measureCellPaddingAndBorder(); // for usability reasons, all text selection in SlickGrid is disabled\n        // with the exception of input and textarea elements (selection must\n        // be enabled there so that editors work as expected); note that\n        // selection in grid cells (grid body) is already unavailable in\n        // all browsers except IE\n\n        disableSelection($headers_1); // disable all text selection in header (including input and textarea)\n\n        if (!options.enableTextSelectionOnCells) {\n          // disable text selection in grid cells except in input and textarea elements\n          // (this is IE-specific, because selectstart event will only fire in IE)\n          $viewport_1.bind('selectstart.ui', event => $(event.target).is('input,textarea'));\n        }\n\n        updateColumnCaches();\n        createColumnHeaders();\n        setupColumnSort();\n        createCssRules();\n        resizeCanvas();\n        bindAncestorScrollEvents();\n        $outerContainer.bind('resize.slickgrid', resizeCanvas);\n        $container_1.bind('resize.slickgrid', resizeCanvas);\n        $viewport_1.bind('scroll', handleScroll).bind('click', handleClick);\n        $headerScroller_1.bind('contextmenu', handleHeaderContextMenu).bind('click', handleHeaderClick).delegate('.slick-header-column', 'mouseenter', handleHeaderMouseEnter).delegate('.slick-header-column', 'mouseleave', handleHeaderMouseLeave);\n        $headerRowScroller_1.bind('scroll', handleHeaderRowScroll);\n        $focusSink.add($focusSink2).bind('keydown', handleKeyDown);\n        $canvas_1.bind('keydown', handleKeyDown).bind('click', handleClick).bind('dblclick', handleDblClick).bind('contextmenu', handleContextMenu).bind('draginit', handleDragInit).bind('dragstart', {\n          distance: 3\n        }, handleDragStart).bind('drag', handleDrag).bind('dragend', handleDragEnd).delegate('.slick-cell', 'mouseenter', handleMouseEnter).delegate('.slick-cell', 'mouseleave', handleMouseLeave);\n\n        if (options.numberOfColumnsToFreeze > 0) {\n          $container_0.bind('resize.slickgrid', resizeCanvas);\n          $viewport_0.bind('mousewheel', e => {\n            var wheelDelta = e.originalEvent.wheelDelta;\n            var newScrollTop = scrollTop - wheelDelta;\n\n            if (newScrollTop < 0) {\n              newScrollTop = 0;\n            }\n\n            handleScroll({\n              wheelDelta: wheelDelta,\n              scrollTop: newScrollTop\n            });\n          });\n          $headerScroller_0.bind('contextmenu', handleHeaderContextMenu).bind('click', handleHeaderClick).delegate('.slick-header-column', 'mouseenter', handleHeaderMouseEnter).delegate('.slick-header-column', 'mouseleave', handleHeaderMouseLeave);\n          $headerRowScroller_0.bind('scroll', handleHeaderRowScroll);\n          $canvas_0.bind('keydown', handleKeyDown).bind('click', handleClick).bind('dblclick', handleDblClick).bind('contextmenu', handleContextMenu).bind('draginit', handleDragInit).bind('dragstart', {\n            distance: 3\n          }, handleDragStart).bind('drag', handleDrag).bind('dragend', handleDragEnd).delegate('.slick-cell', 'mouseenter', handleMouseEnter).delegate('.slick-cell', 'mouseleave', handleMouseLeave);\n        }\n      }\n    }\n\n    function registerPlugin(plugin) {\n      plugins.unshift(plugin);\n      plugin.init(self);\n    }\n\n    function unregisterPlugin(plugin) {\n      for (var i = plugins.length; i >= 0; i--) {\n        if (plugins[i] === plugin) {\n          if (plugins[i].destroy) {\n            plugins[i].destroy();\n          }\n\n          plugins.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    function setSelectionModel(model) {\n      if (selectionModel) {\n        selectionModel.onSelectedRangesChanged.unsubscribe(handleSelectedRangesChanged);\n\n        if (selectionModel.destroy) {\n          selectionModel.destroy();\n        }\n      }\n\n      selectionModel = model;\n\n      if (selectionModel) {\n        selectionModel.init(self);\n        selectionModel.onSelectedRangesChanged.subscribe(handleSelectedRangesChanged);\n      }\n    }\n\n    function getSelectionModel() {\n      return selectionModel;\n    }\n\n    function getCanvasNode(nodeClassName) {\n      // TODO: SFA: This is the entry point into fixing the row reordering style issue\n      var canvasNode = $canvas_1[0]; // Original code\n      // New code not yet complete\n      // if(nodeClassName != undefined){\n      //  canvasNode = {\"frozen\": $canvas_0[0],\n      //                \"nonFrozen\": $canvas_1[0]\n      //               };\n      // }\n\n      return canvasNode;\n    }\n\n    function measureScrollbar() {\n      var $c = $(\"<div style='position:absolute; top:-10000px; left:-10000px; width:100px; height:100px; overflow:scroll;'></div>\").appendTo('body');\n      var dim = {\n        width: $c.width() - $c[0].clientWidth,\n        height: $c.height() - $c[0].clientHeight\n      };\n      $c.remove();\n      return dim;\n    }\n\n    function getHeadersWidth() {\n      var headersWidth_0 = 0;\n      var headersWidth_1 = 0;\n      var numberOfColumnsToFreeze = options.numberOfColumnsToFreeze;\n\n      for (var i = 0, ii = columns.length; i < ii; i++) {\n        var width = columns[i].width;\n\n        if (i < numberOfColumnsToFreeze) {\n          headersWidth_0 += width;\n        } else {\n          headersWidth_1 += width;\n        }\n      }\n\n      headersWidth_0 += 1000;\n      headersWidth_1 += scrollbarDimensions.width;\n      headersWidth_1 = Math.max(headersWidth_1, viewportW_1) + 1000;\n      return {\n        frozen: headersWidth_0,\n        nonFrozen: headersWidth_1\n      };\n    }\n\n    function getCanvasWidth() {\n      var availableWidth = viewportHasVScroll_1 ? viewportW_1 - scrollbarDimensions.width : viewportW_1;\n      var rowWidth_0 = 0;\n      var rowWidth_1 = 0;\n      var numberOfColumnsToFreeze = options.numberOfColumnsToFreeze;\n      var i = columns.length;\n\n      while (i--) {\n        var colWidth = columns[i].width;\n\n        if (i < numberOfColumnsToFreeze) {\n          rowWidth_0 += colWidth;\n        } else {\n          rowWidth_1 += colWidth;\n        }\n      }\n\n      rowWidth_1 = options.fullWidthRows ? Math.max(rowWidth_1, availableWidth) : rowWidth_1;\n      return {\n        frozen: rowWidth_0,\n        nonFrozen: rowWidth_1\n      };\n    }\n\n    function updateCanvasWidth(forceColumnWidthsUpdate) {\n      var oldCanvasWidth_0 = canvasWidth_0;\n      var oldCanvasWidth_1 = canvasWidth_1;\n      var newCanvasWidth = getCanvasWidth();\n      canvasWidth_0 = newCanvasWidth.frozen;\n      canvasWidth_1 = newCanvasWidth.nonFrozen; // FreezeColumns - Handle left and main canvas widths\n\n      var headersWidthObj = getHeadersWidth();\n      var canvasWidthDelta_0 = 0;\n\n      if (options.numberOfColumnsToFreeze > 0 && canvasWidth_0 != oldCanvasWidth_0) {\n        $canvas_0.width(canvasWidth_0);\n        $headerRow_0.width(canvasWidth_0);\n        $headers_0.width(headersWidthObj.frozen);\n        $headerRowSpacer_0.width(canvasWidth_0);\n\n        if (oldCanvasWidth_0 != void 0) {\n          canvasWidthDelta_0 = canvasWidth_0 - oldCanvasWidth_0;\n          canvasWidth_1 -= canvasWidthDelta_0;\n          viewportW_1 -= canvasWidthDelta_0;\n          $container_0[0].style.width = parseInt($container_0[0].style.width) + canvasWidthDelta_0 + 'px';\n          $container_1[0].style[rear] = canvasWidth_0 + 'px';\n          $container_1[0].style.width = parseInt($container_1[0].style.width) - canvasWidthDelta_0 + 'px';\n        }\n      }\n\n      if (canvasWidth_1 != oldCanvasWidth_1 || canvasWidthDelta_0 != 0) {\n        $canvas_1.width(canvasWidth_1);\n        $headerRow_1.width(canvasWidth_1);\n        $headers_1.width(headersWidthObj.nonFrozen);\n        viewportHasHScroll_1 = canvasWidth_1 > viewportW_1 - scrollbarDimensions.width;\n      }\n\n      $headerRowSpacer_1.width(canvasWidth_1 + (viewportHasVScroll_1 ? scrollbarDimensions.width : 0));\n\n      if (canvasWidth_1 != oldCanvasWidth_1 || forceColumnWidthsUpdate || canvasWidthDelta_0 != 0) {\n        applyColumnWidths();\n      }\n    }\n\n    function disableSelection($target) {\n      if ($target && $target.jquery) {\n        $target.attr('unselectable', 'on').css('MozUserSelect', 'none').bind('selectstart.ui', () => false); // from jquery:ui.core.js 1.7.2\n      }\n    }\n\n    function getMaxSupportedCssHeight() {\n      var supportedHeight = 1000000; // FF reports the height back but still renders blank after ~6M px\n\n      var testUpTo = navigator.userAgent.toLowerCase().match(/firefox/) ? 6000000 : 1000000000;\n      var div = $(\"<div style='display:none' />\").appendTo(document.body);\n\n      while (true) {\n        var test = supportedHeight * 2;\n        div.css('height', test);\n\n        if (test > testUpTo || div.height() !== test) {\n          break;\n        } else {\n          supportedHeight = test;\n        }\n      }\n\n      div.remove();\n      return supportedHeight;\n    } // TODO:  this is static.  need to handle page mutation.\n\n\n    function bindAncestorScrollEvents() {\n      var elem = $canvas_1[0];\n\n      while ((elem = elem.parentNode) != document.body && elem != null) {\n        // bind to scroll containers only\n        if (elem == $viewport_1[0] || elem.scrollWidth != elem.clientWidth || elem.scrollHeight != elem.clientHeight) {\n          var $elem = $(elem);\n\n          if (!$boundAncestors) {\n            $boundAncestors = $elem;\n          } else {\n            $boundAncestors = $boundAncestors.add($elem);\n          }\n\n          $elem.bind('scroll.' + uid, handleActiveCellPositionChange);\n        }\n      }\n    }\n\n    function unbindAncestorScrollEvents() {\n      if (!$boundAncestors) {\n        return;\n      }\n\n      $boundAncestors.unbind('scroll.' + uid);\n      $boundAncestors = null;\n    }\n\n    function updateColumnHeader(columnId, title, toolTip) {\n      if (!initialized) {\n        return;\n      }\n\n      var idx = getColumnIndex(columnId);\n\n      if (idx == null) {\n        return;\n      }\n\n      var columnDef = columns[idx];\n      let $header;\n\n      if (options.numberOfColumnsToFreeze > 0) {\n        if (options.numberOfColumnsToFreeze > idx) {\n          $header = $headers_0.children().eq(idx);\n        } else {\n          $header = $headers_1.children().eq(idx - options.numberOfColumnsToFreeze);\n        }\n      }\n\n      if ($header) {\n        if (title !== void 0) {\n          columns[idx].name = title;\n        }\n\n        if (toolTip !== void 0) {\n          columns[idx].toolTip = toolTip;\n        }\n\n        trigger(self.onBeforeHeaderCellDestroy, {\n          node: $header[0],\n          column: columnDef\n        });\n        $header.attr('title', toolTip || '').children().eq(0).html(title);\n        trigger(self.onHeaderCellRendered, {\n          node: $header[0],\n          column: columnDef\n        });\n      }\n    }\n\n    function getHeaderRow() {\n      return $headerRow_1[0];\n    }\n\n    function getColumnHeaderNode(columnId) {\n      var idx = getColumnIndex(columnId); // FreezeColumn - Combine frozen and nonFrozen side header row objects\n\n      var $headersObject;\n\n      if (!options.numberOfColumnsToFreeze) {\n        $headersObject = $headers_1;\n      } else {\n        // Combine frozen and nonFrozen\n        $headersObject = $($.merge($.merge([], $headers_0), $headers_1));\n      }\n\n      var $header = $headersObject.children().eq(idx);\n      return $header && $header[0];\n    }\n\n    function getHeaderRowColumn(columnId) {\n      var idx = getColumnIndex(columnId); // FreezeColumn - Combine frozen and nonFrozen side header row objects\n\n      var $headerRowObject;\n\n      if (!options.numberOfColumnsToFreeze) {\n        $headerRowObject = $headerRow_1;\n      } else {\n        // Combine frozen and nonFrozen\n        $headerRowObject = $($.merge($.merge([], $headerRow_0), $headerRow_1));\n      }\n\n      var $header = $headerRowObject.children().eq(idx);\n      return $header && $header[0];\n    }\n\n    function createColumnHeaders() {\n      function onMouseEnter() {\n        $(this).addClass('ui-state-hover');\n      }\n\n      function onMouseLeave() {\n        $(this).removeClass('ui-state-hover');\n      }\n\n      $headers_1.find('.slick-header-column').each(function () {\n        var columnDef = $(this).data('column');\n\n        if (columnDef) {\n          trigger(self.onBeforeHeaderCellDestroy, {\n            node: this,\n            column: columnDef\n          });\n        }\n      });\n      $headers_1.empty();\n      var headersWidthObj = getHeadersWidth();\n      $headers_1.width(headersWidthObj.nonFrozen); // FreezeColumns - handle header empty\n\n      var numberOfColumnsToFreeze = options.numberOfColumnsToFreeze;\n\n      if (numberOfColumnsToFreeze > 0) {\n        $headers_0.empty();\n        $headers_0.width(headersWidthObj.frozen);\n      } // FreezeColumns - handle header row empty\n\n\n      var $headerRowObject;\n      $headerRowObject = $headerRow_1;\n\n      if (numberOfColumnsToFreeze > 0) {\n        // Combine frozen and nonFrozen\n        $headerRowObject = $($.merge($.merge([], $headerRow_0), $headerRow_1));\n      }\n\n      $headerRowObject.find('.slick-headerrow-column').each(function () {\n        var columnDef = $(this).data('column');\n\n        if (columnDef) {\n          trigger(self.onBeforeHeaderRowCellDestroy, {\n            node: this,\n            column: columnDef\n          });\n        }\n      });\n      $headerRowObject.empty();\n\n      for (var i = 0; i < columns.length; i++) {\n        var m = columns[i];\n        var header = $(\"<div class='ui-state-default slick-header-column' />\").html(\"<span class='slick-column-name'>\" + m.name + '</span>').width(m.width - headerColumnWidthDiff).attr('id', '' + uid + m.id).attr('title', m.toolTip || '').data('column', m).addClass(m.headerCssClass || '').appendTo(i < numberOfColumnsToFreeze ? $headers_0 : $headers_1);\n\n        if (options.enableColumnReorder || m.sortable) {\n          header.on('mouseenter', onMouseEnter).on('mouseleave', onMouseLeave);\n        }\n\n        if (m.sortable) {\n          header.addClass('slick-header-sortable');\n          header.append(\"<span class='slick-sort-indicator' />\");\n        }\n\n        trigger(self.onHeaderCellRendered, {\n          node: header[0],\n          column: m\n        });\n\n        if (options.showHeaderRow) {\n          var headerRowCell = $(\"<div class='ui-state-default slick-headerrow-column b\" + i + ' f' + i + \"'></div>\").data('column', m).appendTo(i < numberOfColumnsToFreeze ? $headerRow_0 : $headerRow_1);\n          trigger(self.onHeaderRowCellRendered, {\n            node: headerRowCell[0],\n            column: m\n          });\n        }\n      }\n\n      setSortColumns(sortColumns);\n      setupColumnResize();\n\n      if (options.enableColumnReorder) {\n        setupColumnReorder();\n      }\n    }\n\n    function setupColumnSort() {\n      $headers_1.add(options.numberOfColumnsToFreeze ? $headers_0 : null).click(e => {\n        // temporary workaround for a bug in jQuery 1.7.1 (http://bugs.jquery.com/ticket/11328)\n        e.metaKey = e.metaKey || e.ctrlKey;\n\n        if ($(e.target).hasClass('slick-resizable-handle')) {\n          return;\n        }\n\n        var $col = $(e.target).closest('.slick-header-column');\n\n        if (!$col.length) {\n          return;\n        }\n\n        var column = $col.data('column');\n\n        if (column.sortable) {\n          if (!getEditorLock().commitCurrentEdit()) {\n            return;\n          }\n\n          var sortOpts = null;\n          var i = 0;\n\n          for (; i < sortColumns.length; i++) {\n            if (sortColumns[i].columnId == column.id) {\n              sortOpts = sortColumns[i];\n              sortOpts.sortAsc = !sortOpts.sortAsc;\n              break;\n            }\n          }\n\n          if (e.metaKey && options.multiColumnSort) {\n            if (sortOpts) {\n              sortColumns.splice(i, 1);\n            }\n          } else {\n            if (!e.shiftKey && !e.metaKey || !options.multiColumnSort) {\n              sortColumns = [];\n            }\n\n            if (!sortOpts) {\n              sortOpts = {\n                columnId: column.id,\n                sortAsc: column.defaultSortAsc\n              };\n              sortColumns.push(sortOpts);\n            } else if (sortColumns.length == 0) {\n              sortColumns.push(sortOpts);\n            }\n          }\n\n          setSortColumns(sortColumns);\n\n          if (!options.multiColumnSort) {\n            trigger(self.onSort, {\n              multiColumnSort: false,\n              sortCol: column,\n              sortAsc: sortOpts.sortAsc\n            }, e);\n          } else {\n            trigger(self.onSort, {\n              multiColumnSort: true,\n              sortCols: $.map(sortColumns, col => ({\n                sortCol: columns[getColumnIndex(col.columnId)],\n                sortAsc: col.sortAsc\n              }))\n            }, e);\n          }\n        }\n      });\n    }\n\n    function setupColumnReorder() {\n      const sortableHeaderGroups = [$headers_1];\n      if (options.numberOfColumnsToFreeze > 0) sortableHeaderGroups.push($headers_0);\n      sortableHeaderGroups.forEach($headers => {\n        $headers.filter(':ui-sortable').sortable('destroy');\n        $headers.sortable({\n          containment: 'parent',\n          distance: 3,\n          axis: 'x',\n          cursor: 'default',\n          tolerance: 'intersection',\n          helper: 'clone',\n          placeholder: 'slick-sortable-placeholder ui-state-default slick-header-column',\n          forcePlaceholderSize: true,\n          start: function (e, ui) {\n            ui.placeholder.width(ui.helper.outerWidth() - headerColumnWidthDiff);\n            $(ui.helper).addClass('slick-header-column-active');\n          },\n          beforeStop: function (e, ui) {\n            $(ui.helper).removeClass('slick-header-column-active');\n          },\n          stop: function (e) {\n            if (!getEditorLock().commitCurrentEdit()) {\n              $(this).sortable('cancel');\n              return;\n            }\n\n            var reorderedIds = $headers.sortable('toArray');\n            var reorderedColumns = []; // handle the reordering\n\n            for (var i = 0; i < reorderedIds.length; i++) {\n              var reorderedIndex = reorderedIds[i].replace(uid, '');\n              var columnIndex = getColumnIndex(reorderedIndex);\n              var thingToPush = columns[columnIndex];\n              reorderedColumns.push(thingToPush);\n            } // Preserve the other (frozen/nonfrozen) set of columns\n\n\n            reorderedColumns = $headers === $headers_1 ? [...columns.slice(0, options.numberOfColumnsToFreeze), ...reorderedColumns] : [...reorderedColumns, ...columns.slice(options.numberOfColumnsToFreeze)];\n            setColumns(reorderedColumns);\n            trigger(self.onColumnsReordered, {});\n            e.stopPropagation();\n            setupColumnResize();\n          }\n        });\n      });\n    }\n\n    function setupColumnResize() {\n      var $col, j, c, pageX, columnElements, minPageX, maxPageX, firstResizable, lastResizable;\n      var isFrozenColumn;\n      var headerElements = [];\n\n      if (options.numberOfColumnsToFreeze > 0) {\n        headerElements.push($headers_0.children());\n      }\n\n      headerElements.push($headers_1.children());\n\n      for (var h = 0; h < headerElements.length; h++) {\n        columnElements = headerElements[h];\n        isFrozenColumn = isPartOfAFrozenColumn(columnElements);\n        columnElements.find('.slick-resizable-handle').remove();\n        columnElements.each((i, e) => {\n          var columnIndex = getIndexOffset(isFrozenColumn, i);\n\n          if (columns[columnIndex].resizable) {\n            if (firstResizable === void 0) {\n              firstResizable = i;\n            }\n\n            lastResizable = i;\n          }\n        });\n\n        if (firstResizable === void 0) {\n          return;\n        }\n\n        columnElements.each((i, e) => {\n          if (i < firstResizable || options.forceFitColumns && i >= lastResizable) {\n            return;\n          }\n\n          $col = $(e);\n          $(\"<div class='slick-resizable-handle' />\").appendTo(e).bind('dragstart', function (e, dd) {\n            isFrozenColumn = isPartOfAFrozenColumn(this);\n            columnElements = getColumnElements(this);\n\n            if (!getEditorLock().commitCurrentEdit()) {\n              return false;\n            }\n\n            pageX = e.pageX;\n            $(this).parent().addClass('slick-header-column-active');\n            var shrinkLeewayOnFront = null,\n                stretchLeewayOnFront = null; // lock each column's width option to current width\n\n            columnElements.each((i, e) => {\n              var columnIndex = getIndexOffset(isFrozenColumn, i);\n              columns[columnIndex].previousWidth = $(e).outerWidth();\n            });\n\n            if (options.forceFitColumns) {\n              shrinkLeewayOnFront = 0;\n              stretchLeewayOnFront = 0; // colums on front affect maxPageX/minPageX\n\n              var nextColumnIndex;\n\n              for (j = i + 1; j < columnElements.length; j++) {\n                nextColumnIndex = getIndexOffset(isFrozenColumn, j);\n                c = columns[nextColumnIndex];\n\n                if (c.resizable) {\n                  if (stretchLeewayOnFront !== null) {\n                    if (c.maxWidth) {\n                      stretchLeewayOnFront += c.maxWidth - c.previousWidth;\n                    } else {\n                      stretchLeewayOnFront = null;\n                    }\n                  }\n\n                  shrinkLeewayOnFront += c.previousWidth - Math.max(c.minWidth || 0, absoluteColumnMinWidth);\n                }\n              }\n            }\n\n            var shrinkLeewayOnRear = 0,\n                stretchLeewayOnRear = 0;\n\n            for (j = 0; j <= i; j++) {\n              // columns on rear only affect minPageX\n              var columnIndex = getIndexOffset(isFrozenColumn, j);\n              c = columns[columnIndex];\n\n              if (c.resizable) {\n                if (stretchLeewayOnRear !== null) {\n                  if (c.maxWidth) {\n                    stretchLeewayOnRear += c.maxWidth - c.previousWidth;\n                  } else {\n                    stretchLeewayOnRear = null;\n                  }\n                }\n\n                shrinkLeewayOnRear += c.previousWidth - Math.max(c.minWidth || 0, absoluteColumnMinWidth);\n              }\n            }\n\n            if (shrinkLeewayOnFront === null) {\n              shrinkLeewayOnFront = 100000;\n            }\n\n            if (shrinkLeewayOnRear === null) {\n              shrinkLeewayOnRear = 100000;\n            }\n\n            if (stretchLeewayOnFront === null) {\n              stretchLeewayOnFront = 100000;\n            }\n\n            if (stretchLeewayOnRear === null) {\n              stretchLeewayOnRear = 100000;\n            }\n\n            if (rtl) {\n              maxPageX = pageX - Math.min(shrinkLeewayOnFront, stretchLeewayOnRear);\n              minPageX = pageX + Math.min(shrinkLeewayOnRear, stretchLeewayOnFront);\n            } else {\n              maxPageX = pageX + Math.min(shrinkLeewayOnFront, stretchLeewayOnRear);\n              minPageX = pageX - Math.min(shrinkLeewayOnRear, stretchLeewayOnFront);\n            }\n          }).bind('drag', function (e, dd) {\n            isFrozenColumn = isPartOfAFrozenColumn(this);\n            columnElements = getColumnElements(this);\n            var actualMinWidth, d, x;\n            d = rtl ? Math.max(maxPageX, Math.min(minPageX, e.pageX)) - pageX : Math.min(maxPageX, Math.max(minPageX, e.pageX)) - pageX;\n            var isShrink = d < 0 && !rtl || d > 0 && rtl;\n\n            if (isShrink) {\n              // shrink column\n              x = d * (rtl ? -1 : 1);\n\n              for (j = i; j >= 0; j--) {\n                c = columns[getIndexOffset(isFrozenColumn, j)];\n\n                if (c.resizable) {\n                  actualMinWidth = Math.max(c.minWidth || 0, absoluteColumnMinWidth);\n\n                  if (x && c.previousWidth + x < actualMinWidth) {\n                    x += c.previousWidth - actualMinWidth;\n                    c.width = actualMinWidth;\n                  } else {\n                    c.width = c.previousWidth + x;\n                    x = 0;\n                  }\n                }\n              }\n\n              if (options.forceFitColumns) {\n                x = -d * (rtl ? -1 : 1);\n\n                for (j = i + 1; j < columnElements.length; j++) {\n                  c = columns[getIndexOffset(isFrozenColumn, j)];\n\n                  if (c.resizable) {\n                    if (x && c.maxWidth && c.maxWidth - c.previousWidth < x) {\n                      x -= c.maxWidth - c.previousWidth;\n                      c.width = c.maxWidth;\n                    } else {\n                      c.width = c.previousWidth + x;\n                      x = 0;\n                    }\n                  }\n                }\n              }\n            } else {\n              // stretch column\n              x = d * (rtl ? -1 : 1);\n\n              for (j = i; j >= 0; j--) {\n                c = columns[getIndexOffset(isFrozenColumn, j)];\n\n                if (c.resizable) {\n                  if (x && c.maxWidth && c.maxWidth - c.previousWidth < x) {\n                    x -= c.maxWidth - c.previousWidth;\n                    c.width = c.maxWidth;\n                  } else {\n                    c.width = c.previousWidth + x;\n                    x = 0;\n                  }\n                }\n              }\n\n              if (options.forceFitColumns) {\n                x = -d * (rtl ? -1 : 1);\n\n                for (j = i + 1; j < columnElements.length; j++) {\n                  c = columns[getIndexOffset(isFrozenColumn, j)];\n\n                  if (c.resizable) {\n                    actualMinWidth = Math.max(c.minWidth || 0, absoluteColumnMinWidth);\n\n                    if (x && c.previousWidth + x < actualMinWidth) {\n                      x += c.previousWidth - actualMinWidth;\n                      c.width = actualMinWidth;\n                    } else {\n                      c.width = c.previousWidth + x;\n                      x = 0;\n                    }\n                  }\n                }\n              }\n            }\n\n            applyColumnHeaderWidths();\n\n            if (options.numberOfColumnsToFreeze > 0) {\n              updateCanvasWidth(true);\n            }\n\n            if (options.syncColumnCellResize) {\n              applyColumnWidths();\n            }\n          }).bind('dragend', function (e, dd) {\n            isFrozenColumn = isPartOfAFrozenColumn(this);\n            columnElements = getColumnElements(this);\n            var newWidth;\n            $(this).parent().removeClass('slick-header-column-active');\n\n            for (var j = 0; j < columnElements.length; j++) {\n              c = columns[getIndexOffset(isFrozenColumn, j)];\n              newWidth = $(columnElements[j]).outerWidth();\n\n              if (c.previousWidth !== newWidth) {\n                if (c.rerenderOnResize) {\n                  invalidateAllRows();\n                }\n              }\n            }\n\n            updateCanvasWidth(true);\n            render();\n            trigger(self.onColumnsResized, {});\n          });\n        });\n      }\n    }\n\n    function getIndexOffset(isFrozen, index) {\n      var newIndex = isFrozen ? index : index + options.numberOfColumnsToFreeze;\n      return newIndex;\n    }\n\n    function isPartOfAFrozenColumn(target) {\n      var results = false;\n      var targetIsFrozen = $(target).hasClass('headers_0');\n\n      if (targetIsFrozen) {\n        results = true;\n      } else {\n        results = $(target).parents('.headers_0').length > 0;\n      }\n\n      return results;\n    }\n\n    function getColumnElements(target) {\n      var results = $(target).parents('.slick-header-columns').children();\n      return results;\n    }\n\n    function getVBoxDelta($el) {\n      var p = ['borderTopWidth', 'borderBottomWidth', 'paddingTop', 'paddingBottom'];\n      var delta = 0;\n      $.each(p, (n, val) => {\n        delta += parseFloat($el.css(val)) || 0;\n      });\n      return delta;\n    }\n\n    function measureCellPaddingAndBorder() {\n      var el;\n      var h = ['borderLeftWidth', 'borderRightWidth', 'paddingLeft', 'paddingRight'];\n      var v = ['borderTopWidth', 'borderBottomWidth', 'paddingTop', 'paddingBottom'];\n      el = $(\"<div class='ui-state-default slick-header-column' style='visibility:hidden'>-</div>\").appendTo($headers_1);\n      headerColumnWidthDiff = headerColumnHeightDiff = 0;\n\n      if (el.css('box-sizing') != 'border-box' && el.css('-moz-box-sizing') != 'border-box' && el.css('-webkit-box-sizing') != 'border-box') {\n        $.each(h, (n, val) => {\n          headerColumnWidthDiff += parseFloat(el.css(val)) || 0;\n        });\n        $.each(v, (n, val) => {\n          headerColumnHeightDiff += parseFloat(el.css(val)) || 0;\n        });\n      }\n\n      el.remove();\n      var r = $(\"<div class='slick-row' />\").appendTo($canvas_1);\n      el = $(\"<div class='slick-cell' id='' style='visibility:hidden'>-</div>\").appendTo(r);\n      cellWidthDiff = cellHeightDiff = 0;\n\n      if (el.css('box-sizing') != 'border-box' && el.css('-moz-box-sizing') != 'border-box' && el.css('-webkit-box-sizing') != 'border-box') {\n        $.each(h, (n, val) => {\n          cellWidthDiff += parseFloat(el.css(val)) || 0;\n        });\n        $.each(v, (n, val) => {\n          cellHeightDiff += parseFloat(el.css(val)) || 0;\n        });\n      }\n\n      r.remove();\n      absoluteColumnMinWidth = Math.max(headerColumnWidthDiff, cellWidthDiff);\n    }\n\n    function createCssRules() {\n      $style = $(\"<style type='text/css' rel='stylesheet' />\").appendTo($('head'));\n      var rowHeight = options.rowHeight - cellHeightDiff;\n      var rules = ['.' + uid + ' .slick-header-column { ' + rear + ': 1000px; }', '.' + uid + ' .slick-top-panel { height:' + options.topPanelHeight + 'px; }', '.' + uid + ' .slick-headerrow-columns { height:' + options.headerRowHeight + 'px; }', '.' + uid + ' .slick-cell { height:' + rowHeight + 'px; }', '.' + uid + ' .slick-row { height:' + options.rowHeight + 'px; }'];\n\n      for (var i = 0; i < columns.length; i++) {\n        rules.push('.' + uid + ' .b' + i + ' { }');\n        rules.push('.' + uid + ' .f' + i + ' { }');\n      }\n\n      if ($style[0].styleSheet) {\n        // IE\n        $style[0].styleSheet.cssText = rules.join(' ');\n      } else {\n        $style[0].appendChild(document.createTextNode(rules.join(' ')));\n      }\n    }\n\n    function getColumnCssRules(idx) {\n      if (!stylesheet) {\n        var sheets = document.styleSheets;\n\n        for (var i = 0; i < sheets.length; i++) {\n          if ((sheets[i].ownerNode || sheets[i].owningElement) == $style[0]) {\n            stylesheet = sheets[i];\n            break;\n          }\n        }\n\n        if (!stylesheet) {\n          throw new Error('Cannot find stylesheet.');\n        } // find and cache column CSS rules\n\n\n        columnCssRulesB = [];\n        columnCssRulesF = [];\n        var cssRules = stylesheet.cssRules || stylesheet.rules;\n        var matches, columnIdx;\n\n        for (var i = 0; i < cssRules.length; i++) {\n          var selector = cssRules[i].selectorText;\n\n          if (matches = /\\.b(\\d+)/.exec(selector)) {\n            columnIdx = parseInt(matches[1], 10);\n            columnCssRulesB[columnIdx] = cssRules[i];\n          } else if (matches = /\\.f(\\d+)/.exec(selector)) {\n            columnIdx = parseInt(matches[1], 10);\n            columnCssRulesF[columnIdx] = cssRules[i];\n          }\n        }\n      }\n\n      return {\n        [rear]: columnCssRulesB[idx],\n        [front]: columnCssRulesF[idx]\n      };\n    }\n\n    function removeCssRules() {\n      $style.remove();\n      stylesheet = null;\n    }\n\n    function destroy() {\n      getEditorLock().cancelCurrentEdit();\n      trigger(self.onBeforeDestroy, {});\n      var i = plugins.length;\n\n      while (i--) {\n        unregisterPlugin(plugins[i]);\n      }\n\n      if (options.enableColumnReorder) {\n        if (options.numberOfColumnsToFreeze > 0) {\n          $headers_0.filter(':ui-sortable').sortable('destroy');\n        }\n\n        $headers_1.filter(':ui-sortable').sortable('destroy');\n      }\n\n      unbindAncestorScrollEvents();\n      $outerContainer.unbind('.slickgrid');\n      removeCssRules();\n      $canvas_1.unbind('draginit dragstart dragend drag');\n      $outerContainer.empty().removeClass(uid);\n    } // ////////////////////////////////////////////////////////////////////////////////////////////\n    // General\n\n\n    function trigger(evt, args, e) {\n      e = e || new Slick.EventData();\n      args = args || {};\n      args.grid = self;\n      return evt.notify(args, e, self);\n    }\n\n    function getUID() {\n      return uid;\n    }\n\n    function getEditorLock() {\n      return options.editorLock;\n    }\n\n    function getEditController() {\n      return editController;\n    }\n\n    function getColumnIndex(id) {\n      return columnsById[id];\n    }\n\n    function autosizeColumns() {\n      var i,\n          c,\n          widths = [],\n          shrinkLeeway = 0,\n          total = 0,\n          prevTotal,\n          availWidth = viewportHasVScroll_1 ? viewportW_1 - scrollbarDimensions.width : viewportW_1;\n\n      for (i = 0; i < columns.length; i++) {\n        c = columns[i];\n        widths.push(c.width);\n        total += c.width;\n\n        if (c.resizable) {\n          shrinkLeeway += c.width - Math.max(c.minWidth, absoluteColumnMinWidth);\n        }\n      } // shrink\n\n\n      prevTotal = total;\n\n      while (total > availWidth && shrinkLeeway) {\n        var shrinkProportion = (total - availWidth) / shrinkLeeway;\n\n        for (i = 0; i < columns.length && total > availWidth; i++) {\n          c = columns[i];\n          var width = widths[i];\n\n          if (!c.resizable || width <= c.minWidth || width <= absoluteColumnMinWidth) {\n            continue;\n          }\n\n          var absMinWidth = Math.max(c.minWidth, absoluteColumnMinWidth);\n          var shrinkSize = Math.floor(shrinkProportion * (width - absMinWidth)) || 1;\n          shrinkSize = Math.min(shrinkSize, width - absMinWidth);\n          total -= shrinkSize;\n          shrinkLeeway -= shrinkSize;\n          widths[i] -= shrinkSize;\n        }\n\n        if (prevTotal == total) {\n          // avoid infinite loop\n          break;\n        }\n\n        prevTotal = total;\n      } // grow\n\n\n      prevTotal = total;\n\n      while (total < availWidth) {\n        var growProportion = availWidth / total;\n\n        for (i = 0; i < columns.length && total < availWidth; i++) {\n          c = columns[i];\n\n          if (!c.resizable || c.maxWidth <= c.width) {\n            continue;\n          }\n\n          var growSize = Math.min(Math.floor(growProportion * c.width) - c.width, c.maxWidth - c.width || 1000000) || 1;\n          total += growSize;\n          widths[i] += growSize;\n        }\n\n        if (prevTotal == total) {\n          // avoid infinite loop\n          break;\n        }\n\n        prevTotal = total;\n      }\n\n      var reRender = false;\n\n      for (i = 0; i < columns.length; i++) {\n        if (columns[i].rerenderOnResize && columns[i].width != widths[i]) {\n          reRender = true;\n        }\n\n        columns[i].width = widths[i];\n      }\n\n      applyColumnHeaderWidths();\n      updateCanvasWidth(true);\n\n      if (reRender) {\n        invalidateAllRows();\n        render();\n      }\n    }\n\n    function applyWidthToHeaders(header) {\n      var isFrozenColumn = isPartOfAFrozenColumn(header);\n      var headers = header.children();\n\n      for (var i = 0, h, ii = headers.length; i < ii; i++) {\n        h = $(headers[i]);\n        var columnIndex = getIndexOffset(isFrozenColumn, i);\n\n        if (h.width() !== columns[columnIndex].width - headerColumnWidthDiff) {\n          h.width(columns[columnIndex].width - headerColumnWidthDiff);\n        }\n      }\n    }\n\n    function applyColumnHeaderWidths() {\n      if (!initialized) {\n        return;\n      }\n\n      if (options.numberOfColumnsToFreeze > 0) {\n        applyWidthToHeaders($headers_0); // Frozen Columns\n      }\n\n      applyWidthToHeaders($headers_1); // NonFrozen Columns\n\n      updateColumnCaches();\n    }\n\n    function applyColumnWidths() {\n      var nonFrozenWidth = 0,\n          w,\n          rule;\n      var frozenWidth = 0;\n      var numberOfColumnsToFreeze = options.numberOfColumnsToFreeze;\n      var ruleIndex = 0;\n      var columnCount = columns.length;\n\n      for (var i = 0; i < columnCount; i++) {\n        w = columns[i].width;\n        rule = getColumnCssRules(i);\n\n        if (i < numberOfColumnsToFreeze) {\n          // FrozenColumns\n          rule[rear].style[rear] = frozenWidth + 'px';\n          rule[front].style[front] = canvasWidth_0 - frozenWidth - w + 'px';\n          frozenWidth += columns[i].width;\n        } else {\n          // NonFrozenColumns\n          rule[rear].style[rear] = nonFrozenWidth + 'px';\n          rule[front].style[front] = canvasWidth_1 - nonFrozenWidth - w + 'px';\n          nonFrozenWidth += columns[i].width;\n        }\n      }\n    }\n    /*\n     * updates the numberOfColumnsToFreeze.\n     *\n     * doesn't change the number of frozen columns until you do something to\n     * re-build the grid (like setColumns)\n     */\n\n\n    function setNumberOfColumnsToFreeze(n) {\n      options.numberOfColumnsToFreeze = n;\n    }\n\n    function setSortColumn(columnId, ascending) {\n      setSortColumns([{\n        columnId: columnId,\n        sortAsc: ascending\n      }]);\n    }\n\n    function setSortColumns(cols) {\n      sortColumns = cols; // Combine frozen and nonFrozen\n\n      var headerColumnEls = $headers_1.children().add(options.numberOfColumnsToFreeze ? $headers_0.children() : null);\n      headerColumnEls.removeClass('slick-header-column-sorted').find('.slick-sort-indicator').removeClass('slick-sort-indicator-asc slick-sort-indicator-desc');\n      $.each(sortColumns, (i, col) => {\n        if (col.sortAsc == null) {\n          col.sortAsc = true;\n        }\n\n        var columnIndex = getColumnIndex(col.columnId);\n\n        if (columnIndex != null) {\n          headerColumnEls.eq(columnIndex).addClass('slick-header-column-sorted').find('.slick-sort-indicator').addClass(col.sortAsc ? 'slick-sort-indicator-asc' : 'slick-sort-indicator-desc');\n        }\n      });\n    }\n\n    function getSortColumns() {\n      return sortColumns;\n    }\n\n    function handleSelectedRangesChanged(e, ranges) {\n      selectedRows = [];\n      var hash = {};\n\n      for (var i = 0; i < ranges.length; i++) {\n        for (var j = ranges[i].fromRow; j <= ranges[i].toRow; j++) {\n          if (!hash[j]) {\n            // prevent duplicates\n            selectedRows.push(j);\n            hash[j] = {};\n          }\n\n          for (var k = ranges[i].fromCell; k <= ranges[i].toCell; k++) {\n            if (canCellBeSelected(j, k)) {\n              hash[j][columns[k].id] = options.selectedCellCssClass;\n            }\n          }\n        }\n      }\n\n      setCellCssStyles(options.selectedCellCssClass, hash);\n      trigger(self.onSelectedRowsChanged, {\n        rows: getSelectedRows()\n      }, e);\n    }\n\n    function getColumns() {\n      return columns;\n    }\n\n    function updateColumnCaches() {\n      // Pre-calculate cell boundaries.\n      columnPosRear = [];\n      columnPosFront = [];\n      var frozenWidth = 0;\n      var nonFrozenWidth = 0;\n      var numberOfColumnsToFreeze = options.numberOfColumnsToFreeze;\n\n      for (var i = 0, ii = columns.length; i < ii; i++) {\n        if (i < numberOfColumnsToFreeze) {\n          // Frozen Columns\n          columnPosRear[i] = frozenWidth;\n          columnPosFront[i] = frozenWidth + columns[i].width;\n          frozenWidth += columns[i].width;\n        } else {\n          // NonFrozen Columns\n          columnPosRear[i] = nonFrozenWidth;\n          columnPosFront[i] = nonFrozenWidth + columns[i].width;\n          nonFrozenWidth += columns[i].width;\n        }\n      }\n    }\n\n    function setColumns(columnDefinitions) {\n      columns = columnDefinitions;\n      columnsById = {};\n\n      for (var i = 0; i < columns.length; i++) {\n        var m = columns[i] = $.extend({}, columnDefaults, columns[i]);\n        columnsById[m.id] = i;\n\n        if (m.minWidth && m.width < m.minWidth) {\n          m.width = m.minWidth;\n        }\n\n        if (m.maxWidth && m.width > m.maxWidth) {\n          m.width = m.maxWidth;\n        }\n      }\n\n      updateColumnCaches();\n\n      if (initialized) {\n        invalidateAllRows();\n        createColumnHeaders();\n        removeCssRules();\n        createCssRules();\n        resizeCanvas();\n        applyColumnWidths();\n        handleScroll();\n      }\n    }\n\n    function getOptions() {\n      return options;\n    }\n\n    function setOptions(args) {\n      if (!getEditorLock().commitCurrentEdit()) {\n        return;\n      }\n\n      makeActiveCellNormal();\n\n      if (options.enableAddRow !== args.enableAddRow) {\n        invalidateRow(getDataLength());\n      }\n\n      options = $.extend(options, args);\n      validateAndEnforceOptions();\n      $viewport_1.css('overflow-y', options.autoHeight ? 'hidden' : 'auto');\n      render();\n    }\n\n    function validateAndEnforceOptions() {\n      if (options.autoHeight) {\n        options.leaveSpaceForNewRows = false;\n      }\n    }\n\n    function setData(newData, scrollToTop) {\n      data = newData;\n      invalidateAllRows();\n      updateRowCount();\n\n      if (scrollToTop) {\n        scrollTo(0);\n      }\n    }\n\n    function getData() {\n      return data;\n    }\n\n    function getDataLength() {\n      if (data.getLength) {\n        return data.getLength();\n      } else {\n        return data.length;\n      }\n    }\n\n    function getDataLengthIncludingAddNew() {\n      return getDataLength() + (options.enableAddRow ? 1 : 0);\n    }\n\n    function getDataItem(i) {\n      if (data.getItem) {\n        return data.getItem(i);\n      } else {\n        return data[i];\n      }\n    }\n\n    function getTopPanel() {\n      return $topPanel_1[0];\n    }\n\n    function setTopPanelVisibility(visible) {\n      if (options.showTopPanel != visible) {\n        options.showTopPanel = visible;\n\n        if (visible) {\n          $topPanelScroller_1.slideDown('fast', resizeCanvas);\n        } else {\n          $topPanelScroller_1.slideUp('fast', resizeCanvas);\n        }\n      }\n    }\n\n    function setHeaderRowVisibility(visible) {\n      if (options.showHeaderRow != visible) {\n        options.showHeaderRow = visible;\n\n        if (visible) {\n          $headerRowScroller_1.slideDown('fast', resizeCanvas);\n        } else {\n          $headerRowScroller_1.slideUp('fast', resizeCanvas);\n        }\n      }\n    }\n\n    function getContainerNode() {\n      return $outerContainer.get(0);\n    } // ////////////////////////////////////////////////////////////////////////////////////////////\n    // Rendering / Scrolling\n\n\n    function getRowTop(row) {\n      return options.rowHeight * row - offset;\n    }\n\n    function getRowFromPosition(y) {\n      return Math.floor((y + offset) / options.rowHeight);\n    }\n\n    function scrollTo(y) {\n      y = Math.max(y, 0);\n      y = Math.min(y, th - viewportH_1 + (viewportHasHScroll_1 ? scrollbarDimensions.height : 0));\n      var oldOffset = offset;\n      page = Math.min(n - 1, Math.floor(y / ph));\n      offset = Math.round(page * cj);\n      var newScrollTop = y - offset;\n\n      if (offset != oldOffset) {\n        var range = getVisibleRange(newScrollTop);\n        cleanupRows(range);\n        updateRowPositions();\n      }\n\n      if (prevScrollTop != newScrollTop) {\n        vScrollDir = prevScrollTop + oldOffset < newScrollTop + offset ? 1 : -1;\n        $viewport_1[0].scrollTop = lastRenderedScrollTop = scrollTop = prevScrollTop = newScrollTop;\n\n        if (options.numberOfColumnsToFreeze > 0) {\n          $viewport_0[0].scrollTop = scrollTop;\n        }\n\n        trigger(self.onViewportChanged, {});\n      }\n    }\n\n    function defaultFormatter(row, cell, value, columnDef, dataContext) {\n      if (value == null) {\n        return '';\n      } else {\n        return (value + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n      }\n    }\n\n    function getFormatter(row, column) {\n      var rowMetadata = data.getItemMetadata && data.getItemMetadata(row); // look up by id, then index\n\n      var columnOverrides = rowMetadata && rowMetadata.columns && (rowMetadata.columns[column.id] || rowMetadata.columns[getColumnIndex(column.id)]);\n      return columnOverrides && columnOverrides.formatter || rowMetadata && rowMetadata.formatter || column.formatter || options.formatterFactory && options.formatterFactory.getFormatter(column) || options.defaultFormatter;\n    }\n\n    function getEditor(row, cell) {\n      var column = columns[cell];\n      var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n      var columnMetadata = rowMetadata && rowMetadata.columns;\n\n      if (columnMetadata && columnMetadata[column.id] && columnMetadata[column.id].editor !== void 0) {\n        return columnMetadata[column.id].editor;\n      }\n\n      if (columnMetadata && columnMetadata[cell] && columnMetadata[cell].editor !== void 0) {\n        return columnMetadata[cell].editor;\n      }\n\n      return column.editor || options.editorFactory && options.editorFactory.getEditor(column);\n    }\n\n    function getDataItemValueForColumn(item, columnDef) {\n      if (options.dataItemColumnValueExtractor) {\n        return options.dataItemColumnValueExtractor(item, columnDef);\n      }\n\n      return item[columnDef.field];\n    }\n\n    function appendRowHtml(stringArray, row, range, dataLength) {\n      var numberOfColumnsToFreeze = options.numberOfColumnsToFreeze; // CLICK CUSTOM CODE\n\n      var d = getDataItem(row);\n      var dataLoading = row < dataLength && !d;\n      var rowCss = 'slick-row' + (dataLoading ? ' loading' : '') + (row === activeRow ? ' active' : '') + (row % 2 == 1 ? ' odd' : ' even');\n      var metadata = data.getItemMetadata && data.getItemMetadata(row);\n\n      if (metadata && metadata.cssClasses) {\n        rowCss += ' ' + metadata.cssClasses;\n      }\n\n      var rowString = \"<div class='ui-widget-content \" + rowCss + \"' style='top:\" + getRowTop(row) + \"px;' >\"; // only use role in normal rows\n\n      stringArray.nonFrozen.push(rowString);\n\n      if (numberOfColumnsToFreeze > 0) {\n        stringArray.frozen.push(rowString);\n      }\n\n      var colspan, m;\n\n      for (var i = 0, ii = columns.length; i < ii; i++) {\n        m = columns[i];\n        colspan = 1;\n\n        if (metadata && metadata.columns) {\n          var columnData = metadata.columns[m.id] || metadata.columns[i];\n          colspan = columnData && columnData.colspan || 1;\n\n          if (colspan === '*') {\n            colspan = ii - i;\n          }\n        } // Always render frozen columns\n\n\n        if (numberOfColumnsToFreeze && i < numberOfColumnsToFreeze) {\n          appendCellHtml(stringArray, row, i, colspan, d);\n        } else if (columnPosFront[Math.min(ii - 1, i + colspan - 1)] > (rtl ? canvasWidth_1 - range.rightPx : range.leftPx)) {\n          // Do not render cells before those in range.\n          if (columnPosRear[i] > (rtl ? canvasWidth_1 - range.leftPx : range.rightPx)) {\n            // All columns after are outside the range.\n            break;\n          }\n\n          appendCellHtml(stringArray, row, i, colspan, d);\n        }\n\n        if (colspan > 1) {\n          i += colspan - 1;\n        }\n      }\n\n      stringArray.nonFrozen.push('</div>');\n\n      if (numberOfColumnsToFreeze > 0) {\n        stringArray.frozen.push('</div>');\n      }\n    }\n\n    function appendCellHtml(stringArray, row, cell, colspan, item) {\n      var m = columns[cell]; // var d = getDataItem(row);\n\n      var cellCss = 'slick-cell b' + cell + ' f' + Math.min(columns.length - 1, cell + colspan - 1) + (m.cssClass ? ' ' + m.cssClass : '');\n\n      if (row === activeRow && cell === activeCell) {\n        cellCss += ' active';\n      } // TODO:  merge them together in the setter\n\n\n      for (var key in cellCssClasses) {\n        if (cellCssClasses[key][row] && cellCssClasses[key][row][m.id]) {\n          cellCss += ' ' + cellCssClasses[key][row][m.id];\n        }\n      }\n\n      var cellString = \"<div class='\" + cellCss + \"'>\";\n      var numberOfColumnsToFreeze = options.numberOfColumnsToFreeze; // FrozenColumns - Add the cells html depending on the cell index - frozen or not\n\n      if (cell < numberOfColumnsToFreeze) {\n        stringArray.frozen.push(cellString);\n      } else {\n        stringArray.nonFrozen.push(cellString);\n      } // if there is a corresponding row (if not, this is the Add New row or this data hasn't been loaded yet)\n\n\n      if (item) {\n        var value = getDataItemValueForColumn(item, m);\n        var contents = getFormatter(row, m)(row, cell, value, m, item);\n\n        if (cell < numberOfColumnsToFreeze) {\n          stringArray.frozen.push(contents);\n        } else {\n          stringArray.nonFrozen.push(getFormatter(row, m)(row, cell, value, m, item));\n        }\n      }\n\n      if (cell < numberOfColumnsToFreeze) {\n        stringArray.frozen.push('</div>');\n      } else {\n        stringArray.nonFrozen.push('</div>');\n      }\n\n      rowsCache[row].cellRenderQueue.push(cell);\n      rowsCache[row].cellColSpans[cell] = colspan;\n    }\n\n    function cleanupRows(rangeToKeep) {\n      for (var i in rowsCache) {\n        if ((i = parseInt(i, 10)) !== activeRow && (i < rangeToKeep.top || i > rangeToKeep.bottom)) {\n          removeRowFromCache(i);\n        }\n      }\n    }\n\n    function invalidate() {\n      updateRowCount();\n      invalidateAllRows();\n      render();\n    }\n\n    function invalidateAllRows() {\n      if (currentEditor) {\n        makeActiveCellNormal();\n      }\n\n      for (var row in rowsCache) {\n        removeRowFromCache(row);\n      }\n    }\n\n    function removeRowFromCache(row) {\n      var cacheEntry = rowsCache[row];\n\n      if (!cacheEntry) {\n        return;\n      }\n\n      var childToRemove = cacheEntry.rowNode; // Frozen Columns - remove row from frozen and nonFrozen canvas_x\n\n      if (options.numberOfColumnsToFreeze > 0) {\n        if (childToRemove.nonFrozen) {\n          $canvas_1[0].removeChild(childToRemove.nonFrozen);\n        }\n\n        if (childToRemove.frozen) {\n          $canvas_0[0].removeChild(childToRemove.frozen);\n        }\n      } else {\n        $canvas_1[0].removeChild(childToRemove.nonFrozen);\n      }\n\n      delete rowsCache[row];\n      delete postProcessedRows[row];\n      renderedRows--;\n      counter_rows_removed++;\n    }\n\n    function invalidateRows(rows) {\n      var i, rl;\n\n      if (!rows || !rows.length) {\n        return;\n      }\n\n      vScrollDir = 0;\n\n      for (i = 0, rl = rows.length; i < rl; i++) {\n        if (currentEditor && activeRow === rows[i]) {\n          makeActiveCellNormal();\n        }\n\n        if (rowsCache[rows[i]]) {\n          removeRowFromCache(rows[i]);\n        }\n      }\n    }\n\n    function invalidateRow(row) {\n      invalidateRows([row]);\n    }\n\n    function updateCell(row, cell) {\n      var cellNode = getCellNode(row, cell);\n\n      if (!cellNode) {\n        return;\n      }\n\n      var m = columns[cell],\n          d = getDataItem(row);\n\n      if (currentEditor && activeRow === row && activeCell === cell) {\n        currentEditor.loadValue(d);\n      } else {\n        cellNode.innerHTML = d ? getFormatter(row, m)(row, cell, getDataItemValueForColumn(d, m), m, d) : '';\n        invalidatePostProcessingResults(row);\n      }\n    }\n\n    function updateRow(row) {\n      var cacheEntry = rowsCache[row];\n\n      if (!cacheEntry) {\n        return;\n      }\n\n      ensureCellNodesInRowsCache(row);\n      var d = getDataItem(row);\n\n      for (var columnIdx in cacheEntry.cellNodesByColumnIdx) {\n        if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(columnIdx)) {\n          continue;\n        }\n\n        columnIdx |= 0;\n        var m = columns[columnIdx],\n            node = cacheEntry.cellNodesByColumnIdx[columnIdx];\n\n        if (row === activeRow && columnIdx === activeCell && currentEditor) {\n          currentEditor.loadValue(d);\n        } else if (d) {\n          node.innerHTML = getFormatter(row, m)(row, columnIdx, getDataItemValueForColumn(d, m), m, d);\n        } else {\n          node.innerHTML = '';\n        }\n      }\n\n      invalidatePostProcessingResults(row);\n    }\n\n    function getViewportHeight() {\n      return parseFloat($.css($outerContainer[0], 'height', true)) - parseFloat($.css($outerContainer[0], 'paddingTop', true)) - parseFloat($.css($outerContainer[0], 'paddingBottom', true)) - parseFloat($.css($headerScroller_1[0], 'height')) - getVBoxDelta($headerScroller_1) - (options.showTopPanel ? options.topPanelHeight + getVBoxDelta($topPanelScroller_1) : 0) - (options.showHeaderRow ? options.headerRowHeight + getVBoxDelta($headerRowScroller_1) : 0);\n    }\n\n    function resizeCanvas() {\n      if (!initialized) {\n        return;\n      }\n\n      if (options.autoHeight) {\n        viewportH_1 = options.rowHeight * getDataLengthIncludingAddNew();\n      } else {\n        viewportH_1 = getViewportHeight();\n      }\n\n      numVisibleRows = Math.ceil(viewportH_1 / options.rowHeight);\n      viewportW_1 = parseFloat($.css($container_1[0], 'width', true));\n\n      if (!options.autoHeight) {\n        $viewport_1.height(viewportH_1); // Frozen Columns - also set left viewport height\n\n        if (options.numberOfColumnsToFreeze) {\n          $viewport_0.height(viewportH_1);\n        }\n      }\n\n      if (options.forceFitColumns) {\n        autosizeColumns();\n      }\n\n      updateRowCount();\n      handleScroll(); // Since the width has changed, force the render() to reevaluate virtually rendered cells.\n\n      lastRenderedScrollLeft = -1;\n      render();\n    }\n\n    function updateRowCount() {\n      var dataLength = getDataLength();\n\n      if (!initialized) {\n        return;\n      }\n\n      numberOfRows = getDataLengthIncludingAddNew() + (options.leaveSpaceForNewRows ? numVisibleRows - 1 : 0);\n      var oldViewportHasVScroll = viewportHasVScroll_1; // with autoHeight, we do not need to accommodate the vertical scroll bar\n\n      viewportHasVScroll_1 = !options.autoHeight && numberOfRows * options.rowHeight > viewportH_1; // remove the rows that are now outside of the data range\n      // this helps avoid redundant calls to .removeRow() when the size of the data decreased by thousands of rows\n\n      var l = getDataLengthIncludingAddNew() - 1;\n\n      for (var i in rowsCache) {\n        if (i >= l) {\n          removeRowFromCache(i);\n        }\n      }\n\n      if (activeCellNode && activeRow > l) {\n        resetActiveCell();\n      }\n\n      var oldH = h;\n      th = Math.max(options.rowHeight * numberOfRows, viewportH_1 - scrollbarDimensions.height);\n\n      if (th < maxSupportedCssHeight) {\n        // just one page\n        h = ph = th;\n        n = 1;\n        cj = 0;\n      } else {\n        // break into pages\n        h = maxSupportedCssHeight;\n        ph = h / 100;\n        n = Math.floor(th / ph);\n        cj = (th - h) / (n - 1);\n      }\n\n      if (h !== oldH) {\n        $canvas_1.css('height', h);\n        scrollTop = $viewport_1[0].scrollTop; // Frozen Columns - Set left viewport height to h + scrollbar height\n\n        if (options.numberOfColumnsToFreeze > 0) {\n          $canvas_0.css('height', h + scrollbarDimensions.height);\n        }\n      }\n\n      var oldScrollTopInRange = scrollTop + offset <= th - viewportH_1;\n\n      if (th == 0 || scrollTop == 0) {\n        page = offset = 0;\n      } else if (oldScrollTopInRange) {\n        // maintain virtual position\n        scrollTo(scrollTop + offset);\n      } else {\n        // scroll to bottom\n        scrollTo(th - viewportH_1);\n      }\n\n      if (h != oldH && options.autoHeight) {\n        resizeCanvas();\n      }\n\n      if (options.forceFitColumns && oldViewportHasVScroll != viewportHasVScroll_1) {\n        autosizeColumns();\n      }\n\n      updateCanvasWidth(false);\n    } // ///////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Returns an object with the following values.\n    //\ttop\t\t- row number of the top visible row. applicable to viewport_0 and viewport_1.\n    //\tbottom\t- row number of the bottom visible row. applicable to viewport_0 and viewport_1.\n    //\tleftPx\t- pixel number of the leftmost visible pixel. applicable to viewPort_1 only.\n    //\t\t\tAs viewport_0 is frozen it is assumed to always be visible\n    //\trightPx\t- pixel number. applicable to viewPort_1 only.\n    //\t\t\tAs viewport_0 is frozen it is assumed to always be visible\n    // ///////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n    function getVisibleRange(viewportTop, viewportLeft) {\n      if (viewportTop == null) {\n        viewportTop = scrollTop;\n      }\n\n      if (viewportLeft == null) {\n        viewportLeft = scrollLeft;\n      }\n\n      return {\n        top: getRowFromPosition(viewportTop),\n        bottom: getRowFromPosition(viewportTop + viewportH_1),\n        leftPx: viewportLeft,\n        rightPx: viewportLeft + viewportW_1\n      };\n    } // ///////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Returns an object with the following values.\n    //\ttop\t\t- row number. applicable to viewport_0 and viewport_1.\n    //\tbottom\t- row number. applicable to viewport_0 and viewport_1.\n    //\tleftPx\t- pixel number. applicable to viewPort_1 only. As viewport_0 is frozen it\n    //\t\t\tis assumed to always be rendered\n    //\trightPx\t- pixel number. applicable to viewPort_1 only. As viewport_0 is frozen it\n    //\t\t\tis assumed to always be rendered\n    // ///////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n    function getRenderedRange(viewportTop, viewportLeft) {\n      var range = getVisibleRange(viewportTop, viewportLeft);\n      var buffer = Math.round(viewportH_1 / options.rowHeight);\n      var minBuffer = 3;\n\n      if (vScrollDir == -1) {\n        range.top -= buffer;\n        range.bottom += minBuffer;\n      } else if (vScrollDir == 1) {\n        range.top -= minBuffer;\n        range.bottom += buffer;\n      } else {\n        range.top -= minBuffer;\n        range.bottom += minBuffer;\n      }\n\n      range.top = Math.max(0, range.top);\n      range.bottom = Math.min(getDataLengthIncludingAddNew() - 1, range.bottom);\n      range.leftPx -= viewportW_1;\n      range.rightPx += viewportW_1;\n      range.leftPx = Math.max(0, range.leftPx);\n      range.rightPx = Math.min(canvasWidth_1, range.rightPx);\n      return range;\n    }\n\n    function ensureCellNodesInRowsCache(row) {\n      var cacheEntry = rowsCache[row];\n\n      if (cacheEntry) {\n        if (cacheEntry.cellRenderQueue.length) {\n          var lastChild_1 = cacheEntry.rowNode.nonFrozen.lastChild;\n\n          if (options.numberOfColumnsToFreeze > 0) {\n            var lastChild_0 = cacheEntry.rowNode.frozen.lastChild;\n          }\n\n          var numberOfColumnsToFreeze = options.numberOfColumnsToFreeze;\n\n          while (cacheEntry.cellRenderQueue.length) {\n            var columnIdx = cacheEntry.cellRenderQueue.pop();\n\n            if (numberOfColumnsToFreeze > columnIdx) {\n              cacheEntry.cellNodesByColumnIdx[columnIdx] = lastChild_0;\n\n              if (lastChild_0.previousSibling) {\n                lastChild_0 = lastChild_0.previousSibling;\n              }\n            } else {\n              cacheEntry.cellNodesByColumnIdx[columnIdx] = lastChild_1;\n\n              if (lastChild_1.previousSibling) {\n                lastChild_1 = lastChild_1.previousSibling;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    function cleanUpCells(range, row) {\n      var totalCellsRemoved = 0;\n      var cacheEntry = rowsCache[row]; // Remove cells outside the range.\n\n      var cellsToRemove = [];\n\n      for (var i in cacheEntry.cellNodesByColumnIdx) {\n        // I really hate it when people mess with Array.prototype.\n        if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(i)) {\n          continue;\n        } // This is a string, so it needs to be cast back to a number.\n\n\n        i |= 0;\n        var colspan = cacheEntry.cellColSpans[i];\n        const outOfRange = rtl ? columnPosRear[i] > canvasWidth_1 - range.leftPx || columnPosFront[Math.min(columns.length - 1, i + colspan - 1)] < canvasWidth_1 - range.rightPx : columnPosRear[i] > range.rightPx || columnPosFront[Math.min(columns.length - 1, i + colspan - 1)] < range.leftPx;\n\n        if (outOfRange) {\n          if (!(row == activeRow && i == activeCell)) {\n            cellsToRemove.push(i);\n          }\n        }\n      }\n\n      var cellToRemove = cellsToRemove.pop();\n      var childToRemove, children;\n\n      while (cellToRemove != null && cellToRemove != 0) {\n        childToRemove = cacheEntry.cellNodesByColumnIdx[cellToRemove]; // cacheEntry.rowNode.frozen.removeChild(childToRemove);\n\n        children = cacheEntry.rowNode.nonFrozen.childNodes;\n\n        for (var i = 0; i < children.length; i++) {\n          if (children[i] == childToRemove) {\n            cacheEntry.rowNode.nonFrozen.removeChild(childToRemove);\n            delete cacheEntry.cellColSpans[cellToRemove];\n            delete cacheEntry.cellNodesByColumnIdx[cellToRemove];\n\n            if (postProcessedRows[row]) {\n              delete postProcessedRows[row][cellToRemove];\n            }\n\n            totalCellsRemoved++;\n            break;\n          }\n        }\n\n        if (cellsToRemove.length > 0) {\n          cellToRemove = cellsToRemove.pop();\n        } else {\n          cellToRemove = null;\n        }\n      }\n    }\n\n    function cleanUpAndRenderCells(range) {\n      var cacheEntry;\n      var stringArray = {\n        frozen: [],\n        nonFrozen: []\n      };\n      var processedRows = [];\n      var cellsAdded;\n      var totalCellsAdded = 0;\n      var colspan;\n\n      for (var row = range.top, btm = range.bottom; row <= btm; row++) {\n        cacheEntry = rowsCache[row];\n\n        if (!cacheEntry) {\n          continue;\n        } // cellRenderQueue populated in renderRows() needs to be cleared first\n\n\n        ensureCellNodesInRowsCache(row);\n        cleanUpCells(range, row); // Render missing cells.\n\n        cellsAdded = 0;\n        var metadata = data.getItemMetadata && data.getItemMetadata(row);\n        metadata = metadata && metadata.columns;\n        var d = getDataItem(row); // TODO:  shorten this loop (index? heuristics? binary search?)\n\n        for (var i = 0, ii = columns.length; i < ii; i++) {\n          // Cells to the right are outside the range.\n          if (columnPosRear[i] > (rtl ? range.rightPx + canvasWidth_1 : range.rightPx)) {\n            break;\n          } // Already rendered.\n\n\n          if ((colspan = cacheEntry.cellColSpans[i]) != null) {\n            i += colspan > 1 ? colspan - 1 : 0;\n            continue;\n          }\n\n          colspan = 1;\n\n          if (metadata) {\n            var columnData = metadata[columns[i].id] || metadata[i];\n            colspan = columnData && columnData.colspan || 1;\n\n            if (colspan === '*') {\n              colspan = ii - i;\n            }\n          }\n\n          if (columnPosFront[Math.min(ii - 1, i + colspan - 1)] > (rtl ? canvasWidth_1 - range.rightPx : range.leftPx)) {\n            appendCellHtml(stringArray, row, i, colspan, d);\n            cellsAdded++;\n          }\n\n          i += colspan > 1 ? colspan - 1 : 0;\n        }\n\n        if (cellsAdded) {\n          totalCellsAdded += cellsAdded;\n          processedRows.push(row);\n        }\n      }\n\n      if (!stringArray.nonFrozen.length) {\n        return;\n      }\n\n      var nonFrozenDiv = document.createElement('div');\n      nonFrozenDiv.innerHTML = stringArray.nonFrozen.join('');\n      var frozenDiv = document.createElement('div');\n      frozenDiv.innerHTML = stringArray.frozen.join('');\n      var processedRow;\n      var nonFrozenNode;\n      var frozenNode;\n      var numberOfColumnsToFreeze = options.numberOfColumnsToFreeze;\n\n      while ((processedRow = processedRows.pop()) != null) {\n        cacheEntry = rowsCache[processedRow];\n        var columnIdx;\n\n        while ((columnIdx = cacheEntry.cellRenderQueue.pop()) != null) {\n          frozenNode = frozenDiv.lastChild;\n          nonFrozenNode = nonFrozenDiv.lastChild;\n\n          if (numberOfColumnsToFreeze > columnIdx) {\n            cacheEntry.rowNode.frozen.appendChild(frozenNode);\n            cacheEntry.cellNodesByColumnIdx[columnIdx] = frozenNode;\n          } else {\n            cacheEntry.rowNode.nonFrozen.appendChild(nonFrozenNode);\n            cacheEntry.cellNodesByColumnIdx[columnIdx] = nonFrozenNode;\n          }\n        }\n      }\n    }\n\n    function renderRows(range) {\n      var parentNode_1 = $canvas_1[0],\n          stringArray = {\n        frozen: [],\n        nonFrozen: []\n      },\n          rows = [],\n          needToReselectCell = false,\n          dataLength = getDataLength();\n      var numberOfColumnsToFreeze = options.numberOfColumnsToFreeze;\n\n      if (numberOfColumnsToFreeze) {\n        var parentNode_0 = $canvas_0[0];\n      }\n\n      for (var i = range.top, ii = range.bottom; i <= ii; i++) {\n        if (rowsCache[i]) {\n          continue;\n        }\n\n        renderedRows++;\n        rows.push(i); // Create an entry right away so that appendRowHtml() can\n        // start populatating it.\n\n        rowsCache[i] = {\n          rowNode: null,\n          // ColSpans of rendered cells (by column idx).\n          // Can also be used for checking whether a cell has been rendered.\n          cellColSpans: [],\n          // Cell nodes (by column idx).  Lazy-populated by ensureCellNodesInRowsCache().\n          cellNodesByColumnIdx: [],\n          // Column indices of cell nodes that have been rendered, but not yet indexed in\n          // cellNodesByColumnIdx.  These are in the same order as cell nodes added at the\n          // end of the row.\n          cellRenderQueue: []\n        };\n        appendRowHtml(stringArray, i, range, dataLength);\n\n        if (activeCellNode && activeRow === i) {\n          needToReselectCell = true;\n        }\n\n        counter_rows_rendered++;\n      }\n\n      if (!rows.length) {\n        return;\n      }\n\n      var nonFrozenDiv = document.createElement('div');\n      nonFrozenDiv.innerHTML = stringArray.nonFrozen.join('');\n\n      if (numberOfColumnsToFreeze > 0) {\n        // FreezeColumns - Add divs for both frozen columns and update contents\n        var frozenDiv = document.createElement('div');\n        frozenDiv.innerHTML = stringArray.frozen.join('');\n      }\n\n      var currentRowCache;\n\n      for (var i = 0, ii = rows.length; i < ii; i++) {\n        currentRowCache = rowsCache[rows[i]];\n        currentRowCache.rowNode = {\n          frozen: numberOfColumnsToFreeze > 0 ? parentNode_0.appendChild(frozenDiv.firstChild) : '',\n          nonFrozen: parentNode_1.appendChild(nonFrozenDiv.firstChild)\n        };\n      }\n\n      if (needToReselectCell) {\n        activeCellNode = getCellNode(activeRow, activeCell);\n      }\n    }\n\n    function startPostProcessing() {\n      if (!options.enableAsyncPostRender) {\n        return;\n      }\n\n      clearTimeout(h_postrender);\n      h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay);\n    }\n\n    function invalidatePostProcessingResults(row) {\n      delete postProcessedRows[row];\n      postProcessFromRow = Math.min(postProcessFromRow, row);\n      postProcessToRow = Math.max(postProcessToRow, row);\n      startPostProcessing();\n    }\n\n    function updateRowPositions() {\n      for (var row in rowsCache) {\n        var rowTop = getRowTop(row) + 'px';\n        rowsCache[row].rowNode.frozen.style.top = rowTop;\n        rowsCache[row].rowNode.nonFrozen.style.top = rowTop;\n      }\n    }\n\n    function render() {\n      if (!initialized) {\n        return;\n      }\n\n      var visible = getVisibleRange();\n      var rendered = getRenderedRange(); // remove rows no longer in the viewport\n\n      cleanupRows(rendered); // add new rows & missing cells in existing rows\n\n      if (lastRenderedScrollLeft != scrollLeft) {\n        cleanUpAndRenderCells(rendered);\n      } // render missing rows\n\n\n      renderRows(rendered);\n      postProcessFromRow = visible.top;\n      postProcessToRow = Math.min(getDataLengthIncludingAddNew() - 1, visible.bottom);\n      startPostProcessing();\n      lastRenderedScrollTop = scrollTop;\n      lastRenderedScrollLeft = scrollLeft;\n      h_render = null;\n    }\n\n    function handleHeaderRowScroll() {\n      var scrollLeft = getScrollLeft($headerRowScroller_1[0]);\n\n      if (scrollLeft != getScrollLeft($viewport_1[0])) {\n        $viewport_1[0].scrollLeft = scrollLeft;\n      }\n    }\n\n    function handleScroll(scrollInfo) {\n      if (scrollInfo != void 0 && scrollInfo.scrollTop != void 0) {\n        $viewport_1[0].scrollTop = scrollInfo.scrollTop;\n      }\n\n      scrollTop = $viewport_1[0].scrollTop;\n      scrollLeft = getScrollLeft($viewport_1[0]);\n      var vScrollDist = Math.abs(scrollTop - prevScrollTop);\n      var hScrollDist = Math.abs(scrollLeft - prevScrollLeft);\n\n      if (hScrollDist) {\n        prevScrollLeft = scrollLeft;\n        setScrollLeft($headerScroller_1[0], scrollLeft);\n        setScrollLeft($topPanelScroller_1[0], scrollLeft);\n        setScrollLeft($headerRowScroller_1[0], scrollLeft);\n      }\n\n      if (vScrollDist) {\n        vScrollDir = prevScrollTop < scrollTop ? 1 : -1;\n        prevScrollTop = scrollTop;\n\n        if (options.numberOfColumnsToFreeze > 0) {\n          $viewport_0[0].scrollTop = scrollTop;\n        } // switch virtual pages if needed\n\n\n        if (vScrollDist < viewportH_1) {\n          scrollTo(scrollTop + offset);\n        } else {\n          var oldOffset = offset;\n\n          if (h == viewportH_1) {\n            page = 0;\n          } else {\n            page = Math.min(n - 1, Math.floor(scrollTop * ((th - viewportH_1) / (h - viewportH_1)) * (1 / ph)));\n          }\n\n          offset = Math.round(page * cj);\n\n          if (oldOffset != offset) {\n            invalidateAllRows();\n          }\n        }\n      }\n\n      if (hScrollDist || vScrollDist) {\n        if (h_render) {\n          clearTimeout(h_render);\n        }\n\n        if (Math.abs(lastRenderedScrollTop - scrollTop) > 20 || Math.abs(lastRenderedScrollLeft - scrollLeft) > 20) {\n          if (options.forceSyncScrolling || Math.abs(lastRenderedScrollTop - scrollTop) < viewportH_1 && Math.abs(lastRenderedScrollLeft - scrollLeft) < viewportW_1) {\n            render();\n          } else {\n            h_render = setTimeout(render, 50);\n          }\n\n          trigger(self.onViewportChanged, {});\n        }\n      }\n\n      trigger(self.onScroll, {\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      });\n    }\n\n    function asyncPostProcessRows() {\n      while (postProcessFromRow <= postProcessToRow) {\n        var row = vScrollDir >= 0 ? postProcessFromRow++ : postProcessToRow--;\n        var cacheEntry = rowsCache[row];\n\n        if (!cacheEntry || row >= getDataLength()) {\n          continue;\n        }\n\n        if (!postProcessedRows[row]) {\n          postProcessedRows[row] = {};\n        }\n\n        ensureCellNodesInRowsCache(row);\n\n        for (var columnIdx in cacheEntry.cellNodesByColumnIdx) {\n          if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(columnIdx)) {\n            continue;\n          }\n\n          columnIdx |= 0;\n          var m = columns[columnIdx];\n\n          if (m.asyncPostRender && !postProcessedRows[row][columnIdx]) {\n            var node = cacheEntry.cellNodesByColumnIdx[columnIdx];\n\n            if (node) {\n              m.asyncPostRender(node, row, getDataItem(row), m);\n            }\n\n            postProcessedRows[row][columnIdx] = true;\n          }\n        }\n\n        h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay);\n        return;\n      }\n    }\n\n    function updateCellCssStylesOnRenderedRows(addedHash, removedHash) {\n      var node, columnId, addedRowHash, removedRowHash;\n\n      for (var row in rowsCache) {\n        removedRowHash = removedHash && removedHash[row];\n        addedRowHash = addedHash && addedHash[row];\n\n        if (removedRowHash) {\n          for (columnId in removedRowHash) {\n            if (!addedRowHash || removedRowHash[columnId] != addedRowHash[columnId]) {\n              node = getCellNode(row, getColumnIndex(columnId));\n\n              if (node) {\n                $(node).removeClass(removedRowHash[columnId]);\n              }\n            }\n          }\n        }\n\n        if (addedRowHash) {\n          for (columnId in addedRowHash) {\n            if (!removedRowHash || removedRowHash[columnId] != addedRowHash[columnId]) {\n              node = getCellNode(row, getColumnIndex(columnId));\n\n              if (node) {\n                $(node).addClass(addedRowHash[columnId]);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    function addCellCssStyles(key, hash) {\n      if (cellCssClasses[key]) {\n        throw \"addCellCssStyles: cell CSS hash with key '\" + key + \"' already exists.\";\n      }\n\n      cellCssClasses[key] = hash;\n      updateCellCssStylesOnRenderedRows(hash, null);\n      trigger(self.onCellCssStylesChanged, {\n        key: key,\n        hash: hash\n      });\n    }\n\n    function removeCellCssStyles(key) {\n      if (!cellCssClasses[key]) {\n        return;\n      }\n\n      updateCellCssStylesOnRenderedRows(null, cellCssClasses[key]);\n      delete cellCssClasses[key];\n      trigger(self.onCellCssStylesChanged, {\n        key: key,\n        hash: null\n      });\n    }\n\n    function setCellCssStyles(key, hash) {\n      var prevHash = cellCssClasses[key];\n      cellCssClasses[key] = hash;\n      updateCellCssStylesOnRenderedRows(hash, prevHash);\n      trigger(self.onCellCssStylesChanged, {\n        key: key,\n        hash: hash\n      });\n    }\n\n    function getCellCssStyles(key) {\n      return cellCssClasses[key];\n    }\n\n    function flashCell(row, cell, speed) {\n      speed = speed || 100;\n\n      if (rowsCache[row]) {\n        var $cell = $(getCellNode(row, cell));\n\n        var toggleCellClass = function (times) {\n          if (!times) {\n            return;\n          }\n\n          setTimeout(() => {\n            $cell.queue(() => {\n              $cell.toggleClass(options.cellFlashingCssClass).dequeue();\n              toggleCellClass(times - 1);\n            });\n          }, speed);\n        };\n\n        toggleCellClass(4);\n      }\n    } // ////////////////////////////////////////////////////////////////////////////////////////////\n    // Interactivity\n\n\n    function handleDragInit(e, dd) {\n      var cell = getCellFromEvent(e);\n\n      if (!cell || !cellExists(cell.row, cell.cell)) {\n        return false;\n      }\n\n      var retval = trigger(self.onDragInit, dd, e);\n\n      if (e.isImmediatePropagationStopped()) {\n        return retval;\n      } // if nobody claims to be handling drag'n'drop by stopping immediate propagation,\n      // cancel out of it\n\n\n      return false;\n    }\n\n    function handleDragStart(e, dd) {\n      var cell = getCellFromEvent(e);\n\n      if (!cell || !cellExists(cell.row, cell.cell)) {\n        return false;\n      }\n\n      var retval = trigger(self.onDragStart, dd, e);\n\n      if (e.isImmediatePropagationStopped()) {\n        return retval;\n      }\n\n      return false;\n    }\n\n    function handleDrag(e, dd) {\n      return trigger(self.onDrag, dd, e);\n    }\n\n    function handleDragEnd(e, dd) {\n      trigger(self.onDragEnd, dd, e);\n    }\n\n    function handleKeyDown(e) {\n      trigger(self.onKeyDown, {\n        row: activeRow,\n        cell: activeCell\n      }, e); // Canvas Hack: SlickGrid has unreasonable default behavior that is unavoidable without an early return here.\n\n      if (e.originalEvent.skipSlickGridDefaults) {\n        return;\n      }\n\n      var handled = e.isImmediatePropagationStopped();\n\n      if (!handled) {\n        if (!e.shiftKey && !e.altKey && !e.ctrlKey) {\n          if (e.which == 27) {\n            if (!getEditorLock().isActive()) {\n              return; // no editing mode to cancel, allow bubbling and default processing (exit without cancelling the event)\n            }\n\n            cancelEditAndSetFocus();\n          } else if (e.which == 34) {\n            navigatePageDown();\n            handled = true;\n          } else if (e.which == 33) {\n            navigatePageUp();\n            handled = true;\n          } else if (e.which == 37) {\n            handled = navigateLeft();\n          } else if (e.which == 39) {\n            handled = navigateRight();\n          } else if (e.which == 38) {\n            handled = navigateUp();\n          } else if (e.which == 40) {\n            handled = navigateDown();\n          } else if (e.which == 9) {\n            handled = navigateNext();\n          } else if (e.which == 13) {\n            if (options.editable) {\n              if (currentEditor) {\n                // adding new row\n                if (activeRow === getDataLength()) {\n                  navigateDown();\n                } else {\n                  commitEditAndSetFocus();\n                }\n              } else if (getEditorLock().commitCurrentEdit()) {\n                makeActiveCellEditable();\n              }\n            }\n\n            handled = true;\n          }\n        } else if (e.which == 9 && e.shiftKey && !e.ctrlKey && !e.altKey) {\n          handled = navigatePrev();\n        }\n      }\n\n      if (handled) {\n        // the event has been handled so don't let parent element (bubbling/propagation) or browser (default) handle it\n        e.stopPropagation();\n        e.preventDefault();\n\n        try {\n          e.originalEvent.keyCode = 0; // prevent default behaviour for special keys in IE browsers (F3, F5, etc.)\n        } catch (error) {// ignore exceptions - setting the original event's keycode throws access denied exception for \"Ctrl\"\n          // (hitting control key only, nothing else), \"Shift\" (maybe others)\n        }\n      }\n    }\n\n    function handleClick(e) {\n      if (!currentEditor) {\n        // if this click resulted in some cell child node getting focus,\n        // don't steal it back - keyboard events will still bubble up\n        // IE9+ seems to default DIVs to tabIndex=0 instead of -1, so check for cell clicks directly.\n        if (e.target != document.activeElement || $(e.target).hasClass('slick-cell')) {\n          setFocus();\n        }\n      }\n\n      var cell = getCellFromEvent(e);\n\n      if (!cell || currentEditor !== null && activeRow == cell.row && activeCell == cell.cell) {\n        return;\n      }\n\n      trigger(self.onClick, {\n        row: cell.row,\n        cell: cell.cell\n      }, e);\n\n      if (e.isImmediatePropagationStopped()) {\n        return;\n      }\n\n      if ((activeCell != cell.cell || activeRow != cell.row) && canCellBeActive(cell.row, cell.cell)) {\n        if (!getEditorLock().isActive() || getEditorLock().commitCurrentEdit()) {\n          scrollRowIntoView(cell.row, false); // Always switch to edit mode if possible in response to a click\n\n          setActiveCellInternal(getCellNode(cell.row, cell.cell), true);\n        }\n      }\n    }\n\n    function handleContextMenu(e) {\n      var $cell = $(e.target).closest('.slick-cell', $canvas_1);\n\n      if ($cell.length === 0) {\n        return;\n      } // are we editing this cell?\n\n\n      if (activeCellNode === $cell[0] && currentEditor !== null) {\n        return;\n      }\n\n      trigger(self.onContextMenu, {}, e);\n    }\n\n    function handleDblClick(e) {\n      var cell = getCellFromEvent(e);\n\n      if (!cell || currentEditor !== null && activeRow == cell.row && activeCell == cell.cell) {\n        return;\n      }\n\n      trigger(self.onDblClick, {\n        row: cell.row,\n        cell: cell.cell\n      }, e);\n\n      if (e.isImmediatePropagationStopped()) {\n        return;\n      }\n\n      if (options.editable) {\n        gotoCell(cell.row, cell.cell, true);\n      }\n    }\n\n    function handleHeaderMouseEnter(e) {\n      trigger(self.onHeaderMouseEnter, {\n        column: $(this).data('column')\n      }, e);\n    }\n\n    function handleHeaderMouseLeave(e) {\n      trigger(self.onHeaderMouseLeave, {\n        column: $(this).data('column')\n      }, e);\n    }\n\n    function handleHeaderContextMenu(e) {\n      var $header = $(e.target).closest('.slick-header-column', '.slick-header-columns');\n      var column = $header && $header.data('column');\n      trigger(self.onHeaderContextMenu, {\n        column: column\n      }, e);\n    }\n\n    function handleHeaderClick(e) {\n      var $header = $(e.target).closest('.slick-header-column', '.slick-header-columns');\n      var column = $header && $header.data('column');\n\n      if (column) {\n        trigger(self.onHeaderClick, {\n          column: column\n        }, e);\n      }\n    }\n\n    function handleMouseEnter(e) {\n      trigger(self.onMouseEnter, {}, e);\n    }\n\n    function handleMouseLeave(e) {\n      trigger(self.onMouseLeave, {}, e);\n    }\n\n    function cellExists(row, cell) {\n      return !(row < 0 || row >= getDataLength() || cell < 0 || cell >= columns.length);\n    }\n\n    function getCellFromPoint(x, y) {\n      var row = getRowFromPosition(y);\n      var cell = 0;\n      var w = 0;\n\n      for (var i = 0; i < columns.length && w < x; i++) {\n        w += columns[i].width;\n        cell++;\n      }\n\n      if (cell < 0) {\n        cell = 0;\n      }\n\n      return {\n        row: row,\n        cell: cell - 1\n      };\n    }\n\n    function getCellFromNode(cellNode) {\n      // read column number from .b<columnNumber> CSS class\n      var cls = /b\\d+/.exec(cellNode.className);\n\n      if (!cls) {\n        throw 'getCellFromNode: cannot get cell - ' + cellNode.className;\n      }\n\n      return parseInt(cls[0].substr(1, cls[0].length - 1), 10);\n    }\n\n    function getRowFromNode(rowNode) {\n      for (var row in rowsCache) {\n        var rowItem = rowsCache[row].rowNode;\n\n        if (rowItem.frozen === rowNode || rowItem.nonFrozen === rowNode) {\n          return row | 0;\n        }\n      }\n\n      return null;\n    }\n\n    function getCanvasFromEvent(e) {\n      return jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest('.grid-canvas');\n    }\n\n    function getCellFromEvent(e) {\n      var closestCanvas = getCanvasFromEvent(e);\n      var $cell = $(e.target).closest('.slick-cell', closestCanvas);\n\n      if (!$cell.length) {\n        return null;\n      }\n\n      var row = getRowFromNode($cell[0].parentNode);\n      var cell = getCellFromNode($cell[0]);\n\n      if (row == null || cell == null) {\n        return null;\n      } else {\n        return {\n          row: row,\n          cell: cell\n        };\n      }\n    }\n\n    function getCellNodeBox(row, cell) {\n      if (!cellExists(row, cell)) {\n        return null;\n      }\n\n      var y1 = getRowTop(row);\n      var y2 = y1 + options.rowHeight - 1;\n      var x1 = 0;\n\n      for (var i = 0; i < cell; i++) {\n        x1 += columns[i].width;\n      }\n\n      var x2 = x1 + columns[cell].width;\n      return {\n        top: y1,\n        [rear]: x1,\n        bottom: y2,\n        [front]: x2\n      };\n    } // ////////////////////////////////////////////////////////////////////////////////////////////\n    // Cell switching\n\n\n    function resetActiveCell() {\n      setActiveCellInternal(null, false);\n    }\n\n    function setFocus() {\n      if (tabbingDirection == -1) {\n        $focusSink[0].focus();\n      } else {\n        $focusSink2[0].focus();\n      }\n    }\n\n    function scrollCellIntoView(row, cell, doPaging) {\n      scrollRowIntoView(row, doPaging);\n      var colspan = getColspan(row, cell);\n      var rearVal = columnPosRear[cell],\n          frontVal = columnPosFront[cell + (colspan > 1 ? colspan - 1 : 0)],\n          scrollRight = scrollLeft + viewportW_1;\n\n      if ((rtl ? adjustXToRight(frontVal) : rearVal) < scrollLeft) {\n        // cell is to left of displayed cells\n        setScrollLeft($viewport_1[0], rtl ? Math.max(0, adjustXToRight(frontVal)) : rearVal);\n        handleScroll();\n        render();\n      } else if ((rtl ? adjustXToRight(rearVal) : frontVal) > scrollRight) {\n        // cell is to right of displayed cells\n        setScrollLeft($viewport_1[0], rtl ? adjustXToRight(frontVal) : Math.min(rearVal, frontVal - $viewport_1[0].clientWidth));\n        handleScroll();\n        render();\n      }\n    }\n\n    function setActiveCellInternal(newCell, opt_editMode) {\n      if (activeCellNode !== null) {\n        makeActiveCellNormal();\n        $(activeCellNode).removeClass('active');\n\n        if (rowsCache[activeRow]) {\n          $(rowsCache[activeRow].rowNode.frozen).removeClass('active');\n          $(rowsCache[activeRow].rowNode.nonFrozen).removeClass('active');\n        }\n      }\n\n      var activeCellChanged = activeCellNode !== newCell;\n      activeCellNode = newCell;\n\n      if (activeCellNode != null) {\n        activeRow = getRowFromNode(activeCellNode.parentNode);\n        activeCell = activePosX = getCellFromNode(activeCellNode);\n\n        if (opt_editMode == null) {\n          opt_editMode = (activeRow == getDataLength() || options.autoEdit) && !isCustomColumn(activeCell);\n        }\n\n        $(activeCellNode).addClass('active');\n        $(rowsCache[activeRow].rowNode.frozen).addClass('active');\n        $(rowsCache[activeRow].rowNode.nonFrozen).addClass('active');\n\n        if (options.editable && opt_editMode && isCellPotentiallyEditable(activeRow, activeCell)) {\n          clearTimeout(h_editorLoader);\n\n          if (options.asyncEditorLoading) {\n            h_editorLoader = setTimeout(() => {\n              makeActiveCellEditable();\n            }, options.asyncEditorLoadDelay);\n          } else {\n            makeActiveCellEditable();\n          }\n        }\n      } else {\n        activeRow = activeCell = null;\n      }\n\n      if (activeCellChanged) {\n        trigger(self.onActiveCellChanged, getActiveCell());\n      }\n    }\n\n    function clearTextSelection() {\n      if (document.selection && document.selection.empty) {\n        try {\n          // IE fails here if selected element is not in dom\n          document.selection.empty();\n        } catch (e) {}\n      } else if (window.getSelection) {\n        var sel = window.getSelection();\n\n        if (sel && sel.removeAllRanges) {\n          sel.removeAllRanges();\n        }\n      }\n    }\n\n    function isCellPotentiallyEditable(row, cell) {\n      // is the data for this row loaded?\n      if (row < getDataLength() && !getDataItem(row)) {\n        return false;\n      } // are we in the Add New row?  can we create new from this cell?\n\n\n      if (columns[cell].cannotTriggerInsert && row >= getDataLength()) {\n        return false;\n      } // does this cell have an editor?\n\n\n      if (!getEditor(row, cell)) {\n        return false;\n      }\n\n      return true;\n    }\n\n    function makeActiveCellNormal() {\n      if (!currentEditor) {\n        return;\n      }\n\n      trigger(self.onBeforeCellEditorDestroy, {\n        editor: currentEditor\n      });\n      currentEditor.destroy();\n      currentEditor = null;\n\n      if (activeCellNode) {\n        var d = getDataItem(activeRow);\n        $(activeCellNode).removeClass('editable invalid');\n\n        if (d) {\n          var column = columns[activeCell];\n          var formatter = getFormatter(activeRow, column);\n          activeCellNode.innerHTML = formatter(activeRow, activeCell, getDataItemValueForColumn(d, column), column, d);\n          invalidatePostProcessingResults(activeRow);\n        }\n      } // if there previously was text selected on a page (such as selected text in the edit cell just removed),\n      // IE can't set focus to anything else correctly\n\n\n      if (navigator.userAgent.toLowerCase().match(/msie/)) {\n        clearTextSelection();\n      }\n\n      getEditorLock().deactivate(editController);\n    }\n\n    function makeActiveCellEditable(editor) {\n      if (!activeCellNode) {\n        return;\n      }\n\n      if (!options.editable) {\n        throw 'Grid : makeActiveCellEditable : should never get called when options.editable is false';\n      } // cancel pending async call if there is one\n\n\n      clearTimeout(h_editorLoader);\n\n      if (!isCellPotentiallyEditable(activeRow, activeCell)) {\n        return;\n      }\n\n      var columnDef = columns[activeCell];\n      var item = getDataItem(activeRow);\n\n      if (trigger(self.onBeforeEditCell, {\n        row: activeRow,\n        cell: activeCell,\n        item: item,\n        column: columnDef\n      }) === false) {\n        setFocus();\n        return;\n      }\n\n      getEditorLock().activate(editController);\n      $(activeCellNode).addClass('editable'); // don't clear the cell if a custom editor is passed through\n\n      if (!editor) {\n        activeCellNode.innerHTML = '';\n      }\n\n      currentEditor = new (editor || getEditor(activeRow, activeCell))({\n        grid: self,\n        gridPosition: absBox($outerContainer[0]),\n        position: absBox(activeCellNode),\n        container: activeCellNode,\n        column: columnDef,\n        item: item || {},\n        commitChanges: commitEditAndSetFocus,\n        cancelChanges: cancelEditAndSetFocus,\n        maxLength: columns[activeCell].maxLength\n      });\n\n      if (item) {\n        currentEditor.loadValue(item);\n      }\n\n      serializedEditorValue = currentEditor.serializeValue();\n\n      if (currentEditor.position) {\n        handleActiveCellPositionChange();\n      }\n    }\n\n    function commitEditAndSetFocus() {\n      // if the commit fails, it would do so due to a validation error\n      // if so, do not steal the focus from the editor\n      if (getEditorLock().commitCurrentEdit()) {\n        setFocus();\n\n        if (options.autoEdit && !isCustomColumn(activeCell)) {\n          navigateDown();\n        }\n      }\n    }\n\n    function cancelEditAndSetFocus() {\n      if (getEditorLock().cancelCurrentEdit()) {\n        setFocus();\n      }\n    }\n\n    function adjustXToRight(x) {\n      return canvasWidth_1 - x;\n    }\n\n    function getScrollLeft(elm) {\n      return elm.scrollLeft;\n    }\n\n    function setScrollLeft(elm, val) {\n      elm.scrollLeft = val;\n    }\n\n    function getOffsetLeft(elm) {\n      return elm.offsetLeft;\n    }\n\n    function getOffsetRight(elm) {\n      return document.body.offsetWidth - (elm.offsetLeft + elm.offsetWidth);\n    }\n\n    getOffsetRear = getOffsetLeft;\n\n    function absBox(elem) {\n      var box = {\n        top: elem.offsetTop,\n        bottom: 0,\n        width: $(elem).outerWidth(),\n        height: $(elem).outerHeight(),\n        visible: true\n      };\n      box.bottom = box.top + box.height;\n      box[rear] = getOffsetRear(elem);\n      box[front] = box[rear] + box.width; // walk up the tree\n\n      var offsetParent = elem.offsetParent;\n\n      while ((elem = elem.parentNode) != document.body) {\n        if (box.visible && elem.scrollHeight != elem.offsetHeight && $(elem).css('overflowY') != 'visible') {\n          box.visible = box.bottom > elem.scrollTop && box.top < elem.scrollTop + elem.clientHeight;\n        }\n\n        if (box.visible && elem.scrollWidth != elem.offsetWidth && $(elem).css('overflowX') != 'visible') {\n          box.visible = box[front] > elem.scrollLeft && box[rear] < elem.scrollLeft + elem.clientWidth;\n        }\n\n        box[rear] -= elem.scrollLeft;\n        box.top -= elem.scrollTop;\n\n        if (elem === offsetParent) {\n          box[rear] += elem.scrollLeft;\n          box.top += elem.offsetTop;\n          offsetParent = elem.offsetParent;\n        }\n\n        box.bottom = box.top + box.height;\n        box[front] = box[rear] + box.width;\n      }\n\n      return box;\n    }\n\n    function getActiveCellPosition() {\n      return absBox(activeCellNode);\n    }\n\n    function getGridPosition() {\n      return absBox($outerContainer[0]);\n    }\n\n    function handleActiveCellPositionChange() {\n      if (!activeCellNode) {\n        return;\n      }\n\n      trigger(self.onActiveCellPositionChanged, {});\n\n      if (currentEditor) {\n        var cellBox = getActiveCellPosition();\n\n        if (currentEditor.show && currentEditor.hide) {\n          if (!cellBox.visible) {\n            currentEditor.hide();\n          } else {\n            currentEditor.show();\n          }\n        }\n\n        if (currentEditor.position) {\n          currentEditor.position(cellBox);\n        }\n      }\n    }\n\n    function getCellEditor() {\n      return currentEditor;\n    }\n\n    function getActiveCell() {\n      if (!activeCellNode) {\n        return null;\n      } else {\n        return {\n          row: activeRow,\n          cell: activeCell\n        };\n      }\n    }\n\n    function getActiveCellNode() {\n      return activeCellNode;\n    }\n\n    function scrollRowIntoView(row, doPaging) {\n      var rowAtTop = row * options.rowHeight;\n      var rowAtBottom = (row + 1) * options.rowHeight - viewportH_1 + (viewportHasHScroll_1 ? scrollbarDimensions.height : 0); // need to page down?\n\n      if ((row + 1) * options.rowHeight > scrollTop + viewportH_1 + offset) {\n        scrollTo(doPaging ? rowAtTop : rowAtBottom);\n        render();\n      } // or page up?\n      else if (row * options.rowHeight < scrollTop + offset) {\n        scrollTo(doPaging ? rowAtBottom : rowAtTop);\n        render();\n      }\n    }\n\n    function scrollRowToTop(row) {\n      scrollTo(row * options.rowHeight);\n      render();\n    }\n\n    function scrollPage(dir) {\n      var deltaRows = dir * numVisibleRows;\n      scrollTo((getRowFromPosition(scrollTop) + deltaRows) * options.rowHeight);\n      render();\n\n      if (options.enableCellNavigation && activeRow != null) {\n        var row = activeRow + deltaRows;\n\n        if (row >= getDataLengthIncludingAddNew()) {\n          row = getDataLengthIncludingAddNew() - 1;\n        }\n\n        if (row < 0) {\n          row = 0;\n        }\n\n        var cell = 0,\n            prevCell = null;\n        var prevActivePosX = activePosX;\n\n        while (cell <= activePosX) {\n          if (canCellBeActive(row, cell)) {\n            prevCell = cell;\n          }\n\n          cell += getColspan(row, cell);\n        }\n\n        if (prevCell !== null) {\n          setActiveCellInternal(getCellNode(row, prevCell));\n          activePosX = prevActivePosX;\n        } else {\n          resetActiveCell();\n        }\n      }\n    }\n\n    function navigatePageDown() {\n      scrollPage(1);\n    }\n\n    function navigatePageUp() {\n      scrollPage(-1);\n    }\n\n    function getColspan(row, cell) {\n      var metadata = data.getItemMetadata && data.getItemMetadata(row);\n\n      if (!metadata || !metadata.columns) {\n        return 1;\n      }\n\n      var columnData = metadata.columns[columns[cell].id] || metadata.columns[cell];\n      var colspan = columnData && columnData.colspan;\n\n      if (colspan === '*') {\n        colspan = columns.length - cell;\n      } else {\n        colspan = colspan || 1;\n      }\n\n      return colspan;\n    }\n\n    function findFirstFocusableCell(row) {\n      var cell = 0;\n\n      while (cell < columns.length) {\n        if (canCellBeActive(row, cell)) {\n          return cell;\n        }\n\n        cell += getColspan(row, cell);\n      }\n\n      return null;\n    }\n\n    function findLastFocusableCell(row) {\n      var cell = 0;\n      var lastFocusableCell = null;\n\n      while (cell < columns.length) {\n        if (canCellBeActive(row, cell)) {\n          lastFocusableCell = cell;\n        }\n\n        cell += getColspan(row, cell);\n      }\n\n      return lastFocusableCell;\n    }\n\n    function gotoFront(row, cell, _posX) {\n      if (cell >= columns.length) {\n        return null;\n      }\n\n      do {\n        cell += getColspan(row, cell);\n      } while (cell < columns.length && !canCellBeActive(row, cell));\n\n      if (cell < columns.length) {\n        return {\n          row: row,\n          cell: cell,\n          posX: cell\n        };\n      }\n\n      return null;\n    }\n\n    function gotoRear(row, cell, _posX) {\n      if (cell <= 0) {\n        return null;\n      }\n\n      var firstFocusableCell = findFirstFocusableCell(row);\n\n      if (firstFocusableCell === null || firstFocusableCell >= cell) {\n        return null;\n      }\n\n      var prev = {\n        row: row,\n        cell: firstFocusableCell,\n        posX: firstFocusableCell\n      };\n      var pos;\n\n      while (true) {\n        pos = gotoFront(prev.row, prev.cell, prev.posX);\n\n        if (!pos) {\n          return null;\n        }\n\n        if (pos.cell >= cell) {\n          return prev;\n        }\n\n        prev = pos;\n      }\n    }\n\n    gotoRight = gotoFront;\n    gotoLeft = gotoRear;\n\n    function gotoDown(row, cell, posX) {\n      var prevCell;\n\n      while (true) {\n        if (++row >= getDataLengthIncludingAddNew()) {\n          return null;\n        }\n\n        prevCell = cell = 0;\n\n        while (cell <= posX) {\n          prevCell = cell;\n          cell += getColspan(row, cell);\n        }\n\n        if (canCellBeActive(row, prevCell)) {\n          return {\n            row: row,\n            cell: prevCell,\n            posX: posX\n          };\n        }\n      }\n    }\n\n    function gotoUp(row, cell, posX) {\n      var prevCell;\n\n      while (true) {\n        if (--row < 0) {\n          return null;\n        }\n\n        prevCell = cell = 0;\n\n        while (cell <= posX) {\n          prevCell = cell;\n          cell += getColspan(row, cell);\n        }\n\n        if (canCellBeActive(row, prevCell)) {\n          return {\n            row: row,\n            cell: prevCell,\n            posX: posX\n          };\n        }\n      }\n    }\n\n    function gotoNext(row, cell, posX) {\n      if (row == null && cell == null) {\n        row = cell = posX = 0;\n\n        if (canCellBeActive(row, cell)) {\n          return {\n            row: row,\n            cell: cell,\n            posX: cell\n          };\n        }\n      }\n\n      var pos = gotoFront(row, cell, posX);\n\n      if (pos) {\n        return pos;\n      }\n\n      var firstFocusableCell = null;\n\n      while (++row < getDataLengthIncludingAddNew()) {\n        firstFocusableCell = findFirstFocusableCell(row);\n\n        if (firstFocusableCell !== null) {\n          return {\n            row: row,\n            cell: firstFocusableCell,\n            posX: firstFocusableCell\n          };\n        }\n      }\n\n      return null;\n    }\n\n    function gotoPrev(row, cell, posX) {\n      if (row == null && cell == null) {\n        row = getDataLengthIncludingAddNew() - 1;\n        cell = posX = columns.length - 1;\n\n        if (canCellBeActive(row, cell)) {\n          return {\n            row: row,\n            cell: cell,\n            posX: cell\n          };\n        }\n      }\n\n      var pos;\n      var lastSelectableCell;\n\n      while (!pos) {\n        pos = gotoRear(row, cell, posX);\n\n        if (pos) {\n          break;\n        }\n\n        if (--row < 0) {\n          return null;\n        }\n\n        cell = 0;\n        lastSelectableCell = findLastFocusableCell(row);\n\n        if (lastSelectableCell !== null) {\n          pos = {\n            row: row,\n            cell: lastSelectableCell,\n            posX: lastSelectableCell\n          };\n        }\n      }\n\n      return pos;\n    }\n\n    function navigateRight() {\n      return navigate('right');\n    }\n\n    function navigateLeft() {\n      return navigate('left');\n    }\n\n    function navigateDown() {\n      return navigate('down');\n    }\n\n    function navigateUp() {\n      return navigate('up');\n    }\n\n    function navigateNext() {\n      return navigate('next');\n    }\n\n    function navigatePrev() {\n      return navigate('prev');\n    }\n    /**\n     * @param {string} dir Navigation direction.\n     * @return {boolean} Whether navigation resulted in a change of active cell.\n     */\n\n\n    function navigate(dir) {\n      if (!options.enableCellNavigation) {\n        return false;\n      }\n\n      if (!activeCellNode && dir != 'prev' && dir != 'next') {\n        return false;\n      }\n\n      if (!getEditorLock().commitCurrentEdit()) {\n        return true;\n      }\n\n      setFocus();\n      var tabbingDirections = {\n        up: -1,\n        down: 1,\n        left: -1,\n        right: 1,\n        prev: -1,\n        next: 1\n      };\n      tabbingDirection = tabbingDirections[dir];\n      var stepFunctions = {\n        up: gotoUp,\n        down: gotoDown,\n        left: gotoLeft,\n        right: gotoRight,\n        prev: gotoPrev,\n        next: gotoNext\n      };\n      var stepFn = stepFunctions[dir];\n      var pos = stepFn(activeRow, activeCell, activePosX);\n\n      if (pos) {\n        var isAddNewRow = pos.row == getDataLength();\n        scrollCellIntoView(pos.row, pos.cell, !isAddNewRow);\n        setActiveCellInternal(getCellNode(pos.row, pos.cell));\n        activePosX = pos.posX;\n        return true;\n      } else if (activeRow === getDataLength() - 1) {\n        if (activeCell === columns.length - 1) {\n          // When focus is on the last cell in a row\n          // and the last cell in a column.\n          // Move focus outside of SlickGrid.\n          return false;\n        } // Otherwise, when focus is on the last cell in a column.\n        // Move focus to the first cell of the next column.\n\n\n        setActiveCell(0, activeCell + 1);\n        return true;\n      }\n    }\n\n    function getCellNode(row, cell) {\n      if (rowsCache[row]) {\n        ensureCellNodesInRowsCache(row);\n        return rowsCache[row].cellNodesByColumnIdx[cell];\n      }\n\n      return null;\n    }\n\n    function setActiveCell(row, cell) {\n      if (!initialized) {\n        return;\n      }\n\n      if (row > getDataLength() || row < 0 || cell >= columns.length || cell < 0) {\n        return;\n      }\n\n      if (!options.enableCellNavigation) {\n        return;\n      }\n\n      scrollCellIntoView(row, cell, false);\n      setActiveCellInternal(getCellNode(row, cell), false);\n    }\n\n    function canCellBeActive(row, cell) {\n      if (!options.enableCellNavigation || row >= getDataLengthIncludingAddNew() || row < 0 || cell >= columns.length || cell < 0) {\n        return false;\n      }\n\n      var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n\n      if (rowMetadata && typeof rowMetadata.focusable === 'boolean') {\n        return rowMetadata.focusable;\n      }\n\n      var columnMetadata = rowMetadata && rowMetadata.columns;\n\n      if (columnMetadata && columnMetadata[columns[cell].id] && typeof columnMetadata[columns[cell].id].focusable === 'boolean') {\n        return columnMetadata[columns[cell].id].focusable;\n      }\n\n      if (columnMetadata && columnMetadata[cell] && typeof columnMetadata[cell].focusable === 'boolean') {\n        return columnMetadata[cell].focusable;\n      }\n\n      return columns[cell].focusable;\n    }\n\n    function canCellBeSelected(row, cell) {\n      if (row >= getDataLength() || row < 0 || cell >= columns.length || cell < 0) {\n        return false;\n      }\n\n      var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n\n      if (rowMetadata && typeof rowMetadata.selectable === 'boolean') {\n        return rowMetadata.selectable;\n      }\n\n      var columnMetadata = rowMetadata && rowMetadata.columns && (rowMetadata.columns[columns[cell].id] || rowMetadata.columns[cell]);\n\n      if (columnMetadata && typeof columnMetadata.selectable === 'boolean') {\n        return columnMetadata.selectable;\n      }\n\n      return columns[cell].selectable;\n    }\n\n    function gotoCell(row, cell, forceEdit) {\n      if (!initialized) {\n        return;\n      }\n\n      if (!canCellBeActive(row, cell)) {\n        return;\n      }\n\n      if (!getEditorLock().commitCurrentEdit()) {\n        return;\n      }\n\n      scrollCellIntoView(row, cell, false);\n      var newCell = getCellNode(row, cell); // Custom columns should not auto-edit when accessed via keyboard navigation\n\n      const autoEditDestinationCell = options.autoEdit && !isCustomColumn(cell); // if selecting the 'add new' row, start editing right away\n\n      setActiveCellInternal(newCell, forceEdit || row === getDataLength() || autoEditDestinationCell); // if no editor was created, set the focus back on the grid\n\n      if (!currentEditor) {\n        setFocus();\n      }\n    } // ////////////////////////////////////////////////////////////////////////////////////////////\n    // IEditor implementation for the editor lock\n\n\n    function commitCurrentEdit() {\n      var item = getDataItem(activeRow);\n      var column = columns[activeCell];\n\n      if (currentEditor) {\n        if (currentEditor.isValueChanged()) {\n          var validationResults = currentEditor.validate();\n\n          if (validationResults.valid) {\n            if (activeRow < getDataLength()) {\n              var editCommand = {\n                row: activeRow,\n                cell: activeCell,\n                editor: currentEditor,\n                serializedValue: currentEditor.serializeValue(),\n                prevSerializedValue: serializedEditorValue,\n                execute: function () {\n                  this.editor.applyValue(item, this.serializedValue);\n                  updateRow(this.row);\n                },\n                undo: function () {\n                  this.editor.applyValue(item, this.prevSerializedValue);\n                  updateRow(this.row);\n                }\n              };\n\n              if (options.editCommandHandler) {\n                makeActiveCellNormal();\n                options.editCommandHandler(item, column, editCommand);\n              } else {\n                editCommand.execute();\n                makeActiveCellNormal();\n              }\n\n              trigger(self.onCellChange, {\n                row: activeRow,\n                cell: activeCell,\n                column: column,\n                item: item\n              });\n            } else {\n              var newItem = {};\n              currentEditor.applyValue(newItem, currentEditor.serializeValue());\n              makeActiveCellNormal();\n              trigger(self.onAddNewRow, {\n                item: newItem,\n                column: column\n              });\n            } // check whether the lock has been re-acquired by event handlers\n\n\n            return !getEditorLock().isActive();\n          } else {\n            // Re-add the CSS class to trigger transitions, if any.\n            $(activeCellNode).removeClass('invalid');\n            $(activeCellNode).width(); // force layout\n\n            $(activeCellNode).addClass('invalid');\n            trigger(self.onValidationError, {\n              editor: currentEditor,\n              cellNode: activeCellNode,\n              validationResults: validationResults,\n              row: activeRow,\n              cell: activeCell,\n              column: column\n            });\n            currentEditor.focus();\n            return false;\n          }\n        }\n\n        makeActiveCellNormal();\n      }\n\n      return true;\n    }\n\n    function cancelCurrentEdit() {\n      makeActiveCellNormal();\n      return true;\n    }\n\n    function rowsToRanges(rows) {\n      var ranges = [];\n      var lastCell = columns.length - 1;\n\n      for (var i = 0; i < rows.length; i++) {\n        ranges.push(new Slick.Range(rows[i], 0, rows[i], lastCell));\n      }\n\n      return ranges;\n    }\n\n    function getSelectedRows() {\n      if (!selectionModel) {\n        throw 'Selection model is not set';\n      }\n\n      return selectedRows;\n    }\n\n    function setSelectedRows(rows) {\n      if (!selectionModel) {\n        throw 'Selection model is not set';\n      }\n\n      selectionModel.setSelectedRanges(rowsToRanges(rows));\n    }\n\n    function isCustomColumn(cell) {\n      var _columns$cell;\n\n      return ((_columns$cell = columns[cell]) === null || _columns$cell === void 0 ? void 0 : _columns$cell.type) === 'custom_column';\n    } // ////////////////////////////////////////////////////////////////////////////////////////////\n    // Debug\n\n\n    this.debug = function () {\n      var s = '';\n      s += '\\n' + 'counter_rows_rendered:  ' + counter_rows_rendered;\n      s += '\\n' + 'counter_rows_removed:  ' + counter_rows_removed;\n      s += '\\n' + 'renderedRows:  ' + renderedRows;\n      s += '\\n' + 'numVisibleRows:  ' + numVisibleRows;\n      s += '\\n' + 'maxSupportedCssHeight:  ' + maxSupportedCssHeight;\n      s += '\\n' + 'n(umber of pages):  ' + n;\n      s += '\\n' + '(current) page:  ' + page;\n      s += '\\n' + 'page height (ph):  ' + ph;\n      s += '\\n' + 'vScrollDir:  ' + vScrollDir;\n      alert(s);\n    }; // a debug helper to be able to access private members\n\n\n    this.eval = function (expr) {\n      return eval(expr);\n    }; // ////////////////////////////////////////////////////////////////////////////////////////////\n    // Public API\n\n\n    $.extend(this, {\n      slickGridVersion: '2.1',\n      // Events\n      onScroll: new Slick.Event(),\n      onSort: new Slick.Event(),\n      onHeaderMouseEnter: new Slick.Event(),\n      onHeaderMouseLeave: new Slick.Event(),\n      onHeaderContextMenu: new Slick.Event(),\n      onHeaderClick: new Slick.Event(),\n      onHeaderCellRendered: new Slick.Event(),\n      onBeforeHeaderCellDestroy: new Slick.Event(),\n      onHeaderRowCellRendered: new Slick.Event(),\n      onBeforeHeaderRowCellDestroy: new Slick.Event(),\n      onMouseEnter: new Slick.Event(),\n      onMouseLeave: new Slick.Event(),\n      onClick: new Slick.Event(),\n      onDblClick: new Slick.Event(),\n      onContextMenu: new Slick.Event(),\n      onKeyDown: new Slick.Event(),\n      onAddNewRow: new Slick.Event(),\n      onValidationError: new Slick.Event(),\n      onViewportChanged: new Slick.Event(),\n      onColumnsReordered: new Slick.Event(),\n      onColumnsResized: new Slick.Event(),\n      onCellChange: new Slick.Event(),\n      onBeforeEditCell: new Slick.Event(),\n      onBeforeCellEditorDestroy: new Slick.Event(),\n      onBeforeDestroy: new Slick.Event(),\n      onActiveCellChanged: new Slick.Event(),\n      onActiveCellPositionChanged: new Slick.Event(),\n      onDragInit: new Slick.Event(),\n      onDragStart: new Slick.Event(),\n      onDrag: new Slick.Event(),\n      onDragEnd: new Slick.Event(),\n      onSelectedRowsChanged: new Slick.Event(),\n      onCellCssStylesChanged: new Slick.Event(),\n      // Methods\n      registerPlugin: registerPlugin,\n      unregisterPlugin: unregisterPlugin,\n      getColumns: getColumns,\n      setColumns: setColumns,\n      getColumnIndex: getColumnIndex,\n      updateColumnHeader: updateColumnHeader,\n      setNumberOfColumnsToFreeze: setNumberOfColumnsToFreeze,\n      setSortColumn: setSortColumn,\n      setSortColumns: setSortColumns,\n      getSortColumns: getSortColumns,\n      autosizeColumns: autosizeColumns,\n      getOptions: getOptions,\n      setOptions: setOptions,\n      getData: getData,\n      getDataLength: getDataLength,\n      getDataItem: getDataItem,\n      setData: setData,\n      getSelectionModel: getSelectionModel,\n      setSelectionModel: setSelectionModel,\n      getSelectedRows: getSelectedRows,\n      setSelectedRows: setSelectedRows,\n      getContainerNode: getContainerNode,\n      render: render,\n      invalidate: invalidate,\n      invalidateRow: invalidateRow,\n      invalidateRows: invalidateRows,\n      invalidateAllRows: invalidateAllRows,\n      updateCell: updateCell,\n      updateRow: updateRow,\n      getViewport: getVisibleRange,\n      getRenderedRange: getRenderedRange,\n      resizeCanvas: resizeCanvas,\n      updateRowCount: updateRowCount,\n      scrollRowIntoView: scrollRowIntoView,\n      scrollRowToTop: scrollRowToTop,\n      scrollCellIntoView: scrollCellIntoView,\n      getCanvasNode: getCanvasNode,\n      focus: setFocus,\n      getCellFromPoint: getCellFromPoint,\n      getCellFromEvent: getCellFromEvent,\n      getActiveCell: getActiveCell,\n      setActiveCell: setActiveCell,\n      getActiveCellNode: getActiveCellNode,\n      getActiveCellPosition: getActiveCellPosition,\n      resetActiveCell: resetActiveCell,\n      editActiveCell: makeActiveCellEditable,\n      getCellEditor: getCellEditor,\n      getCellNode: getCellNode,\n      getCellNodeBox: getCellNodeBox,\n      canCellBeSelected: canCellBeSelected,\n      canCellBeActive: canCellBeActive,\n      navigatePrev: navigatePrev,\n      navigateNext: navigateNext,\n      navigateUp: navigateUp,\n      navigateDown: navigateDown,\n      navigateLeft: navigateLeft,\n      navigateRight: navigateRight,\n      navigatePageUp: navigatePageUp,\n      navigatePageDown: navigatePageDown,\n      gotoCell: gotoCell,\n      getTopPanel: getTopPanel,\n      setTopPanelVisibility: setTopPanelVisibility,\n      setHeaderRowVisibility: setHeaderRowVisibility,\n      getHeaderRow: getHeaderRow,\n      getHeaderRowColumn: getHeaderRowColumn,\n      getColumnHeaderNode: getColumnHeaderNode,\n      getGridPosition: getGridPosition,\n      flashCell: flashCell,\n      addCellCssStyles: addCellCssStyles,\n      setCellCssStyles: setCellCssStyles,\n      removeCellCssStyles: removeCellCssStyles,\n      getCellCssStyles: getCellCssStyles,\n      getUID: getUID,\n      init: finishInitialization,\n      destroy: destroy,\n      // IEditor implementation\n      getEditorLock: getEditorLock,\n      getEditController: getEditController\n    });\n    init();\n  }\n})(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\n\n//# sourceURL=webpack:///./packages/slickgrid/slick.grid.js?");

/***/ }),

/***/ "l/ju":
/*!*********************************************!*\
  !*** ./packages/slickgrid/slick.editors.js ***!
  \*********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"ouhR\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _slick_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slick.core */ \"sbct\");\n/*\n * Copyright (c) 2010 Michael Leibman, http://github.com/mleibman/slickgrid\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n(function ($) {\n  // register namespace\n  $.extend(true, window, {\n    Slick: {\n      Editors: {\n        Text: TextEditor,\n        Integer: IntegerEditor,\n        Date: DateEditor,\n        YesNoSelect: YesNoSelectEditor,\n        Checkbox: CheckboxEditor,\n        PercentComplete: PercentCompleteEditor,\n        LongText: LongTextEditor,\n        UploadGradeCellEditor\n      }\n    }\n  });\n\n  function TextEditor(args) {\n    let $input;\n    let defaultValue;\n    const scope = this;\n\n    this.init = function () {\n      $input = $(\"<INPUT type=text class='editor-text' />\").appendTo(args.container).bind('keydown.nav', e => {\n        if (e.keyCode === $.ui.keyCode.LEFT || e.keyCode === $.ui.keyCode.RIGHT) {\n          e.stopImmediatePropagation();\n        }\n      }).focus().select();\n    };\n\n    this.destroy = function () {\n      $input.remove();\n    };\n\n    this.focus = function () {\n      $input.focus();\n    };\n\n    this.getValue = function () {\n      return $input.val();\n    };\n\n    this.setValue = function (val) {\n      $input.val(val);\n    };\n\n    this.loadValue = function (item) {\n      defaultValue = item[args.column.field] || '';\n      $input.val(defaultValue);\n      $input[0].defaultValue = defaultValue;\n      $input.select();\n    };\n\n    this.serializeValue = function () {\n      return $input.val();\n    };\n\n    this.applyValue = function (item, state) {\n      item[args.column.field] = state;\n    };\n\n    this.isValueChanged = function () {\n      return !($input.val() == '' && defaultValue == null) && $input.val() != defaultValue;\n    };\n\n    this.validate = function () {\n      if (args.column.validator) {\n        const validationResults = args.column.validator($input.val());\n\n        if (!validationResults.valid) {\n          return validationResults;\n        }\n      }\n\n      return {\n        valid: true,\n        msg: null\n      };\n    };\n\n    this.init();\n  }\n\n  function IntegerEditor(args) {\n    let $input;\n    let defaultValue;\n    const scope = this;\n\n    this.init = function () {\n      $input = $(\"<INPUT type=text class='editor-text' />\");\n      $input.bind('keydown.nav', e => {\n        if (e.keyCode === $.ui.keyCode.LEFT || e.keyCode === $.ui.keyCode.RIGHT) {\n          e.stopImmediatePropagation();\n        }\n      });\n      $input.appendTo(args.container);\n      $input.focus().select();\n    };\n\n    this.destroy = function () {\n      $input.remove();\n    };\n\n    this.focus = function () {\n      $input.focus();\n    };\n\n    this.loadValue = function (item) {\n      defaultValue = item[args.column.field];\n      $input.val(defaultValue);\n      $input[0].defaultValue = defaultValue;\n      $input.select();\n    };\n\n    this.serializeValue = function () {\n      return parseInt($input.val(), 10) || 0;\n    };\n\n    this.applyValue = function (item, state) {\n      item[args.column.field] = state;\n    };\n\n    this.isValueChanged = function () {\n      return !($input.val() == '' && defaultValue == null) && $input.val() != defaultValue;\n    };\n\n    this.validate = function () {\n      if (isNaN($input.val())) {\n        return {\n          valid: false,\n          msg: 'Please enter a valid integer'\n        };\n      }\n\n      return {\n        valid: true,\n        msg: null\n      };\n    };\n\n    this.init();\n  }\n\n  function DateEditor(args) {\n    let $input;\n    let defaultValue;\n    const scope = this;\n    let calendarOpen = false;\n\n    this.init = function () {\n      $input = $(\"<INPUT type=text class='editor-text' />\");\n      $input.appendTo(args.container);\n      $input.focus().select();\n      $input.datepicker({\n        showOn: 'button',\n        buttonImageOnly: true,\n        buttonImage: '../images/calendar.gif',\n\n        beforeShow() {\n          calendarOpen = true;\n        },\n\n        onClose() {\n          calendarOpen = false;\n        }\n\n      });\n      $input.width($input.width() - 18);\n    };\n\n    this.destroy = function () {\n      $.datepicker.dpDiv.stop(true, true);\n      $input.datepicker('hide');\n      $input.datepicker('destroy');\n      $input.remove();\n    };\n\n    this.show = function () {\n      if (calendarOpen) {\n        $.datepicker.dpDiv.stop(true, true).show();\n      }\n    };\n\n    this.hide = function () {\n      if (calendarOpen) {\n        $.datepicker.dpDiv.stop(true, true).hide();\n      }\n    };\n\n    this.position = function (position) {\n      if (!calendarOpen) {\n        return;\n      }\n\n      $.datepicker.dpDiv.css('top', position.top + 30).css('left', position.left);\n    };\n\n    this.focus = function () {\n      $input.focus();\n    };\n\n    this.loadValue = function (item) {\n      defaultValue = item[args.column.field];\n      $input.val(defaultValue);\n      $input[0].defaultValue = defaultValue;\n      $input.select();\n    };\n\n    this.serializeValue = function () {\n      return $input.val();\n    };\n\n    this.applyValue = function (item, state) {\n      item[args.column.field] = state;\n    };\n\n    this.isValueChanged = function () {\n      return !($input.val() == '' && defaultValue == null) && $input.val() != defaultValue;\n    };\n\n    this.validate = function () {\n      return {\n        valid: true,\n        msg: null\n      };\n    };\n\n    this.init();\n  }\n\n  function YesNoSelectEditor(args) {\n    let $select;\n    let defaultValue;\n    const scope = this;\n\n    this.init = function () {\n      $select = $(\"<SELECT tabIndex='0' class='editor-yesno'><OPTION value='yes'>Yes</OPTION><OPTION value='no'>No</OPTION></SELECT>\");\n      $select.appendTo(args.container);\n      $select.focus();\n    };\n\n    this.destroy = function () {\n      $select.remove();\n    };\n\n    this.focus = function () {\n      $select.focus();\n    };\n\n    this.loadValue = function (item) {\n      $select.val((defaultValue = item[args.column.field]) ? 'yes' : 'no');\n      $select.select();\n    };\n\n    this.serializeValue = function () {\n      return $select.val() == 'yes';\n    };\n\n    this.applyValue = function (item, state) {\n      item[args.column.field] = state;\n    };\n\n    this.isValueChanged = function () {\n      return $select.val() != defaultValue;\n    };\n\n    this.validate = function () {\n      return {\n        valid: true,\n        msg: null\n      };\n    };\n\n    this.init();\n  }\n\n  function CheckboxEditor(args) {\n    let $select;\n    let defaultValue;\n    const scope = this;\n\n    this.init = function () {\n      $select = $(\"<INPUT type=checkbox value='true' class='editor-checkbox' hideFocus>\");\n      $select.appendTo(args.container);\n      $select.focus();\n    };\n\n    this.destroy = function () {\n      $select.remove();\n    };\n\n    this.focus = function () {\n      $select.focus();\n    };\n\n    this.loadValue = function (item) {\n      defaultValue = !!item[args.column.field];\n\n      if (defaultValue) {\n        $select.prop('checked', true);\n      } else {\n        $select.prop('checked', false);\n      }\n    };\n\n    this.serializeValue = function () {\n      return $select.prop('checked');\n    };\n\n    this.applyValue = function (item, state) {\n      item[args.column.field] = state;\n    };\n\n    this.isValueChanged = function () {\n      return this.serializeValue() !== defaultValue;\n    };\n\n    this.validate = function () {\n      return {\n        valid: true,\n        msg: null\n      };\n    };\n\n    this.init();\n  }\n\n  function PercentCompleteEditor(args) {\n    let $input, $picker;\n    let defaultValue;\n    const scope = this;\n\n    this.init = function () {\n      $input = $(\"<INPUT type=text class='editor-percentcomplete' />\");\n      $input.width($(args.container).innerWidth() - 25);\n      $input.appendTo(args.container);\n      $picker = $(\"<div class='editor-percentcomplete-picker' />\").appendTo(args.container);\n      $picker.append(\"<div class='editor-percentcomplete-helper'><div class='editor-percentcomplete-wrapper'><div class='editor-percentcomplete-slider' /><div class='editor-percentcomplete-buttons' /></div></div>\");\n      $picker.find('.editor-percentcomplete-buttons').append('<button val=0>Not started</button><br/><button val=50>In Progress</button><br/><button val=100>Complete</button>');\n      $input.focus().select();\n      $picker.find('.editor-percentcomplete-slider').slider({\n        orientation: 'vertical',\n        range: 'min',\n        value: defaultValue,\n\n        slide(event, ui) {\n          $input.val(ui.value);\n        }\n\n      });\n      $picker.find('.editor-percentcomplete-buttons button').bind('click', function (e) {\n        $input.val($(this).attr('val'));\n        $picker.find('.editor-percentcomplete-slider').slider('value', $(this).attr('val'));\n      });\n    };\n\n    this.destroy = function () {\n      $input.remove();\n      $picker.remove();\n    };\n\n    this.focus = function () {\n      $input.focus();\n    };\n\n    this.loadValue = function (item) {\n      $input.val(defaultValue = item[args.column.field]);\n      $input.select();\n    };\n\n    this.serializeValue = function () {\n      return parseInt($input.val(), 10) || 0;\n    };\n\n    this.applyValue = function (item, state) {\n      item[args.column.field] = state;\n    };\n\n    this.isValueChanged = function () {\n      return !($input.val() == '' && defaultValue == null) && (parseInt($input.val(), 10) || 0) != defaultValue;\n    };\n\n    this.validate = function () {\n      if (isNaN(parseInt($input.val(), 10))) {\n        return {\n          valid: false,\n          msg: 'Please enter a valid positive number'\n        };\n      }\n\n      return {\n        valid: true,\n        msg: null\n      };\n    };\n\n    this.init();\n  }\n  /*\n   * An example of a \"detached\" editor.\n   * The UI is added onto document BODY and .position(), .show() and .hide() are implemented.\n   * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.\n   */\n\n\n  function LongTextEditor(args) {\n    let $input, $wrapper;\n    let defaultValue;\n    const scope = this;\n\n    this.init = function () {\n      const $container = $('body');\n      $wrapper = $(\"<DIV style='z-index:10000;position:absolute;background:white;padding:5px;border:3px solid gray; -moz-border-radius:10px; border-radius:10px;'/>\").appendTo($container);\n      $input = $(\"<TEXTAREA hidefocus rows=5 style='backround:white;width:250px;height:80px;border:0;outline:0'>\").appendTo($wrapper);\n      $(\"<DIV style='text-align:right'><BUTTON>Save</BUTTON><BUTTON>Cancel</BUTTON></DIV>\").appendTo($wrapper);\n      $wrapper.find('button:first').bind('click', this.save);\n      $wrapper.find('button:last').bind('click', this.cancel);\n      $input.bind('keydown', this.handleKeyDown);\n      scope.position(args.position);\n      $input.focus().select();\n    };\n\n    this.handleKeyDown = function (e) {\n      if (e.which == $.ui.keyCode.ENTER && e.ctrlKey) {\n        scope.save();\n      } else if (e.which == $.ui.keyCode.ESCAPE) {\n        e.preventDefault();\n        scope.cancel();\n      } else if (e.which == $.ui.keyCode.TAB && e.shiftKey) {\n        e.preventDefault();\n        args.grid.navigatePrev();\n      } else if (e.which == $.ui.keyCode.TAB) {\n        e.preventDefault();\n        args.grid.navigateNext();\n      }\n    };\n\n    this.save = function () {\n      args.commitChanges();\n    };\n\n    this.cancel = function () {\n      $input.val(defaultValue);\n      args.cancelChanges();\n    };\n\n    this.hide = function () {\n      $wrapper.hide();\n    };\n\n    this.show = function () {\n      $wrapper.show();\n    };\n\n    this.position = function (position) {\n      $wrapper.css('top', position.top - 5).css('left', position.left - 5);\n    };\n\n    this.destroy = function () {\n      $wrapper.remove();\n    };\n\n    this.focus = function () {\n      $input.focus();\n    };\n\n    this.loadValue = function (item) {\n      $input.val(defaultValue = item[args.column.field]);\n      $input.select();\n    };\n\n    this.serializeValue = function () {\n      return $input.val();\n    };\n\n    this.applyValue = function (item, state) {\n      item[args.column.field] = state;\n    };\n\n    this.isValueChanged = function () {\n      return !($input.val() == '' && defaultValue == null) && $input.val() != defaultValue;\n    };\n\n    this.validate = function () {\n      return {\n        valid: true,\n        msg: null\n      };\n    };\n\n    this.init();\n  }\n\n  function UploadGradeCellEditor(args) {\n    let $container = args.container,\n        columnDef = args.column,\n        value = args.item[columnDef.id];\n\n    if (columnDef.active) {\n      value = value || {};\n      var $input;\n      let defaultValue;\n\n      if (columnDef.editorFormatter === 'custom_column') {\n        defaultValue = value.new_content;\n      } else if (columnDef.editorFormatter === 'override_score') {\n        defaultValue = value.new_score;\n      } else {\n        defaultValue = value.grade;\n      }\n\n      const scope = this;\n\n      this.init = function () {\n        switch (columnDef.grading_type) {\n          case 'letter_grade':\n            var letterGrades = [{\n              text: '--',\n              value: ''\n            }, {\n              text: 'A',\n              value: 'A'\n            }, {\n              text: 'A-',\n              value: 'A-'\n            }, {\n              text: 'B+',\n              value: 'B+'\n            }, {\n              text: 'B',\n              value: 'B'\n            }, {\n              text: 'B-',\n              value: 'B-'\n            }, {\n              text: 'C+',\n              value: 'C+'\n            }, {\n              text: 'C-',\n              value: 'C-'\n            }, {\n              text: 'D+',\n              value: 'D+'\n            }, {\n              text: 'D',\n              value: 'D'\n            }, {\n              text: 'D-',\n              value: 'D-'\n            }, {\n              text: 'F',\n              value: 'F'\n            }];\n            var outputString = '';\n            $.each(letterGrades, function () {\n              outputString += `<option value=\"${this.value}\" ${this.value === value.grade ? 'selected' : ''}>${this.text}</option>`;\n            });\n            $input = $(`<select>${outputString}</select>`);\n            break;\n\n          default:\n            $input = $(\"<INPUT type=text class='editor-text' />\");\n        } // if there is something typed in to the grade,\n        // can't do if (value.grade) because if they had a grade of 0 it would break.\n\n\n        if (typeof value.grade !== 'undefined' && `${value.grade}` !== '') {\n          if (typeof columnDef.editorFormatter === 'function') {\n            $input[0].defaultValue = columnDef.editorFormatter(value.grade);\n            $input.val($input[0].defaultValue);\n          } else {\n            $input[0].defaultValue = value.grade;\n            $input.val(defaultValue);\n          }\n        } else if (columnDef.editorFormatter === 'custom_column') {\n          $input[0].defaultValue = value.new_content;\n          $input.val(defaultValue);\n        } else if (columnDef.editorFormatter === 'override_score') {\n          $input[0].defaultValue = value.new_score;\n          $input.val(defaultValue);\n        }\n\n        $input.appendTo($container);\n        $input.focus().select();\n\n        if (typeof value.uploaded_grade === 'undefined') {\n          value.uploaded_grade = value.grade;\n        }\n      };\n\n      this.serializeValue = function serializeValue() {\n        return $input.val();\n      };\n\n      this.loadValue = function () {};\n\n      this.destroy = function () {\n        $input.remove();\n      };\n\n      this.focus = function () {\n        $input.focus();\n      };\n\n      this.applyValue = function (item, state) {\n        if (typeof columnDef.editorParser === 'function') {\n          item[columnDef.id].grade = columnDef.editorParser(state);\n        } else if (columnDef.editorParser === 'custom_column') {\n          item[columnDef.id].new_content = state;\n        } else if (columnDef.editorParser === 'override_score') {\n          item[columnDef.id].new_score = state;\n        } else {\n          item[columnDef.id].grade = state;\n        }\n      };\n\n      this.getValue = function () {\n        return $input.val();\n      };\n\n      this.isValueChanged = function () {\n        return !($input.val() === '' && defaultValue == null) && $input.val() !== defaultValue;\n      };\n\n      this.validate = function () {\n        if (columnDef.validator) {\n          const validationResults = columnDef.validator(scope.getValue());\n          if (!validationResults.valid) return validationResults;\n        }\n\n        return {\n          valid: true,\n          msg: null\n        };\n      };\n\n      this.init();\n    } else {\n      var $input;\n\n      this.init = function () {\n        const html = value ? value.grade : '';\n        $container.removeClass('selected editable').html(html);\n      };\n\n      this.destroy = function () {};\n\n      this.focus = function () {};\n\n      this.setValue = function () {};\n\n      this.getValue = function () {\n        return value;\n      };\n\n      this.isValueChanged = function () {\n        return false;\n      };\n\n      this.validate = function () {\n        return {\n          valid: true,\n          msg: null\n        };\n      };\n\n      this.init();\n    }\n  }\n})(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\n\n//# sourceURL=webpack:///./packages/slickgrid/slick.editors.js?");

/***/ }),

/***/ "o6Wt":
/*!*****************************************************!*\
  !*** ./packages/slickgrid/jquery.event.drag-2.2.js ***!
  \*****************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"ouhR\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n\n\n(function ($) {\n  // add the jquery instance method\n  $.fn.drag = function (str, arg, opts) {\n    // figure out the event type\n    var type = typeof str == 'string' ? str : '',\n        // figure out the event handler...\n    fn = $.isFunction(str) ? str : $.isFunction(arg) ? arg : null; // fix the event type\n\n    if (type.indexOf('drag') !== 0) type = 'drag' + type; // were options passed\n\n    opts = (str == fn ? arg : opts) || {}; // trigger or bind event handler\n\n    return fn ? this.bind(type, opts, fn) : this.trigger(type);\n  }; // local refs (increase compression)\n\n\n  var $event = $.event,\n      $special = $event.special,\n      // configure the drag special event\n  drag = $special.drag = {\n    // these are the default settings\n    defaults: {\n      which: 1,\n      // mouse button pressed to start drag sequence\n      distance: 0,\n      // distance dragged before dragstart\n      not: ':input',\n      // selector to suppress dragging on target elements\n      handle: null,\n      // selector to match handle target elements\n      relative: false,\n      // true to use \"position\", false to use \"offset\"\n      drop: true,\n      // false to suppress drop events, true or selector to allow\n      click: false // false to suppress click events after dragend (no proxy)\n\n    },\n    // the key name for stored drag data\n    datakey: 'dragdata',\n    // prevent bubbling for better performance\n    noBubble: true,\n    // count bound related events\n    add: function (obj) {\n      // read the interaction data\n      var data = $.data(this, drag.datakey),\n          // read any passed options\n      opts = obj.data || {}; // count another realted event\n\n      data.related += 1; // extend data options bound with this event\n      // don't iterate \"opts\" in case it is a node\n\n      $.each(drag.defaults, function (key, def) {\n        if (opts[key] !== void 0) data[key] = opts[key];\n      });\n    },\n    // forget unbound related events\n    remove: function () {\n      $.data(this, drag.datakey).related -= 1;\n    },\n    // configure interaction, capture settings\n    setup: function () {\n      // check for related events\n      if ($.data(this, drag.datakey)) return; // initialize the drag data with copied defaults\n\n      var data = $.extend({\n        related: 0\n      }, drag.defaults); // store the interaction data\n\n      $.data(this, drag.datakey, data); // bind the mousedown event, which starts drag interactions\n\n      $event.add(this, 'touchstart mousedown', drag.init, data); // prevent image dragging in IE...\n\n      if (this.attachEvent) this.attachEvent('ondragstart', drag.dontstart);\n    },\n    // destroy configured interaction\n    teardown: function () {\n      var data = $.data(this, drag.datakey) || {}; // check for related events\n\n      if (data.related) return; // remove the stored data\n\n      $.removeData(this, drag.datakey); // remove the mousedown event\n\n      $event.remove(this, 'touchstart mousedown', drag.init); // enable text selection\n\n      drag.textselect(true); // un-prevent image dragging in IE...\n\n      if (this.detachEvent) this.detachEvent('ondragstart', drag.dontstart);\n    },\n    // initialize the interaction\n    init: function (event) {\n      // sorry, only one touch at a time\n      if (drag.touched) return; // the drag/drop interaction data\n\n      var dd = event.data,\n          results; // check the which directive\n\n      if (event.which != 0 && dd.which > 0 && event.which != dd.which) return; // check for suppressed selector\n\n      if ($(event.target).is(dd.not)) return; // check for handle selector\n\n      if (dd.handle && !$(event.target).closest(dd.handle, event.currentTarget).length) return;\n      drag.touched = event.type == 'touchstart' ? this : null;\n      dd.propagates = 1;\n      dd.mousedown = this;\n      dd.interactions = [drag.interaction(this, dd)];\n      dd.target = event.target;\n      dd.pageX = event.pageX;\n      dd.pageY = event.pageY;\n      dd.dragging = null; // handle draginit event...\n\n      results = drag.hijack(event, 'draginit', dd); // early cancel\n\n      if (!dd.propagates) return; // flatten the result set\n\n      results = drag.flatten(results); // insert new interaction elements\n\n      if (results && results.length) {\n        dd.interactions = [];\n        $.each(results, function () {\n          dd.interactions.push(drag.interaction(this, dd));\n        });\n      } // remember how many interactions are propagating\n\n\n      dd.propagates = dd.interactions.length; // locate and init the drop targets\n\n      if (dd.drop !== false && $special.drop) $special.drop.handler(event, dd); // disable text selection\n\n      drag.textselect(false); // bind additional events...\n\n      if (drag.touched) $event.add(drag.touched, 'touchmove touchend', drag.handler, dd);else $event.add(document, 'mousemove mouseup', drag.handler, dd); // helps prevent text selection or scrolling\n\n      if (!drag.touched || dd.live) return false;\n    },\n    // returns an interaction object\n    interaction: function (elem, dd) {\n      var offset = $(elem)[dd.relative ? 'position' : 'offset']() || {\n        top: 0,\n        left: 0\n      };\n      return {\n        drag: elem,\n        callback: new drag.callback(),\n        droppable: [],\n        offset: offset\n      };\n    },\n    // handle drag-releatd DOM events\n    handler: function (event) {\n      // read the data before hijacking anything\n      var dd = event.data; // handle various events\n\n      switch (event.type) {\n        // mousemove, check distance, start dragging\n        case !dd.dragging && 'touchmove':\n          event.preventDefault();\n\n        case !dd.dragging && 'mousemove':\n          //  drag tolerance, x≤ + y≤ = distance≤\n          if (Math.pow(event.pageX - dd.pageX, 2) + Math.pow(event.pageY - dd.pageY, 2) < Math.pow(dd.distance, 2)) break; // distance tolerance not reached\n\n          event.target = dd.target; // force target from \"mousedown\" event (fix distance issue)\n\n          drag.hijack(event, 'dragstart', dd); // trigger \"dragstart\"\n\n          if (dd.propagates) // \"dragstart\" not rejected\n            dd.dragging = true;\n        // activate interaction\n        // mousemove, dragging\n\n        case 'touchmove':\n          event.preventDefault();\n\n        case 'mousemove':\n          if (dd.dragging) {\n            // trigger \"drag\"\n            drag.hijack(event, 'drag', dd);\n\n            if (dd.propagates) {\n              // manage drop events\n              if (dd.drop !== false && $special.drop) $special.drop.handler(event, dd); // \"dropstart\", \"dropend\"\n\n              break; // \"drag\" not rejected, stop\n            }\n\n            event.type = 'mouseup'; // helps \"drop\" handler behave\n          }\n\n        // mouseup, stop dragging\n\n        case 'touchend':\n        case 'mouseup':\n        default:\n          if (drag.touched) $event.remove(drag.touched, 'touchmove touchend', drag.handler); // remove touch events\n          else $event.remove(document, 'mousemove mouseup', drag.handler); // remove page events\n\n          if (dd.dragging) {\n            if (dd.drop !== false && $special.drop) $special.drop.handler(event, dd); // \"drop\"\n\n            drag.hijack(event, 'dragend', dd); // trigger \"dragend\"\n          }\n\n          drag.textselect(true); // enable text selection\n          // if suppressing click events...\n\n          if (dd.click === false && dd.dragging) $.data(dd.mousedown, 'suppress.click', new Date().getTime() + 5);\n          dd.dragging = drag.touched = false; // deactivate element\n\n          break;\n      }\n    },\n    // re-use event object for custom events\n    hijack: function (event, type, dd, x, elem) {\n      // not configured\n      if (!dd) return; // remember the original event and type\n\n      var orig = {\n        event: event.originalEvent,\n        type: event.type\n      },\n          // is the event drag related or drog related?\n      mode = type.indexOf('drop') ? 'drag' : 'drop',\n          // iteration vars\n      result,\n          i = x || 0,\n          ia,\n          $elems,\n          callback,\n          len = !isNaN(x) ? x : dd.interactions.length; // modify the event type\n\n      event.type = type; // remove the original event\n\n      event.originalEvent = null; // initialize the results\n\n      dd.results = []; // handle each interacted element\n\n      do if (ia = dd.interactions[i]) {\n        // validate the interaction\n        if (type !== 'dragend' && ia.cancelled) continue; // set the dragdrop properties on the event object\n\n        callback = drag.properties(event, dd, ia); // prepare for more results\n\n        ia.results = []; // handle each element\n\n        $(elem || ia[mode] || dd.droppable).each(function (p, subject) {\n          // identify drag or drop targets individually\n          callback.target = subject; // force propagtion of the custom event\n\n          event.isPropagationStopped = function () {\n            return false;\n          }; // handle the event\n\n\n          result = subject ? $event.dispatch.call(subject, event, callback) : null; // stop the drag interaction for this element\n\n          if (result === false) {\n            if (mode == 'drag') {\n              ia.cancelled = true;\n              dd.propagates -= 1;\n            }\n\n            if (type == 'drop') {\n              ia[mode][p] = null;\n            }\n          } // assign any dropinit elements\n          else if (type == 'dropinit') ia.droppable.push(drag.element(result) || subject); // accept a returned proxy element\n\n\n          if (type == 'dragstart') ia.proxy = $(drag.element(result) || ia.drag)[0]; // remember this result\n\n          ia.results.push(result); // forget the event result, for recycling\n\n          delete event.result; // break on cancelled handler\n\n          if (type !== 'dropinit') return result;\n        }); // flatten the results\n\n        dd.results[i] = drag.flatten(ia.results); // accept a set of valid drop targets\n\n        if (type == 'dropinit') ia.droppable = drag.flatten(ia.droppable); // locate drop targets\n\n        if (type == 'dragstart' && !ia.cancelled) callback.update();\n      } while (++i < len); // restore the original event & type\n\n\n      event.type = orig.type;\n      event.originalEvent = orig.event; // return all handler results\n\n      return drag.flatten(dd.results);\n    },\n    // extend the callback object with drag/drop properties...\n    properties: function (event, dd, ia) {\n      var obj = ia.callback; // elements\n\n      obj.drag = ia.drag;\n      obj.proxy = ia.proxy || ia.drag; // starting mouse position\n\n      obj.startX = dd.pageX;\n      obj.startY = dd.pageY; // current distance dragged\n\n      obj.deltaX = event.pageX - dd.pageX;\n      obj.deltaY = event.pageY - dd.pageY; // original element position\n\n      obj.originalX = ia.offset.left;\n      obj.originalY = ia.offset.top; // adjusted element position\n\n      obj.offsetX = obj.originalX + obj.deltaX;\n      obj.offsetY = obj.originalY + obj.deltaY; // assign the drop targets information\n\n      obj.drop = drag.flatten((ia.drop || []).slice());\n      obj.available = drag.flatten((ia.droppable || []).slice());\n      return obj;\n    },\n    // determine is the argument is an element or jquery instance\n    element: function (arg) {\n      if (arg && (arg.jquery || arg.nodeType == 1)) return arg;\n    },\n    // flatten nested jquery objects and arrays into a single dimension array\n    flatten: function (arr) {\n      return $.map(arr, function (member) {\n        return member && member.jquery ? $.makeArray(member) : member && member.length ? drag.flatten(member) : member;\n      });\n    },\n    // toggles text selection attributes ON (true) or OFF (false)\n    textselect: function (bool) {\n      $(document)[bool ? 'unbind' : 'bind']('selectstart', drag.dontstart).css('MozUserSelect', bool ? '' : 'none'); // .attr(\"unselectable\", bool ? \"off\" : \"on\" )\n\n      document.unselectable = bool ? 'off' : 'on';\n    },\n    // suppress \"selectstart\" and \"ondragstart\" events\n    dontstart: function () {\n      return false;\n    },\n    // a callback instance contructor\n    callback: function () {}\n  }; // callback methods\n\n  drag.callback.prototype = {\n    update: function () {\n      if ($special.drop && this.available.length) $.each(this.available, function (i) {\n        $special.drop.locate(this, i);\n      });\n    }\n  }; // patch $.event.$dispatch to allow suppressing clicks\n\n  var $dispatch = $event.dispatch;\n\n  $event.dispatch = function (event) {\n    if ($.data(this, 'suppress.' + event.type) - new Date().getTime() > 0) {\n      $.removeData(this, 'suppress.' + event.type);\n      return;\n    }\n\n    return $dispatch.apply(this, arguments);\n  }; // event fix hooks for touch events...\n\n\n  var touchHooks = $event.fixHooks.touchstart = $event.fixHooks.touchmove = $event.fixHooks.touchend = $event.fixHooks.touchcancel = {\n    props: 'clientX clientY pageX pageY screenX screenY'.split(' '),\n    filter: function (event, orig) {\n      if (orig) {\n        var touched = orig.touches && orig.touches[0] || orig.changedTouches && orig.changedTouches[0] || null; // iOS webkit: touchstart, touchmove, touchend\n\n        if (touched) $.each(touchHooks.props, function (i, prop) {\n          event[prop] = touched[prop];\n        });\n      }\n\n      return event;\n    }\n  }; // share the same special event configuration with related events...\n\n  $special.draginit = $special.dragstart = $special.dragend = drag;\n})(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\n\n//# sourceURL=webpack:///./packages/slickgrid/jquery.event.drag-2.2.js?");

/***/ }),

/***/ "sbFY":
/*!*************************************!*\
  !*** ./packages/slickgrid/index.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _slick_grid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./slick.grid */ \"C5mO\");\n/* harmony import */ var _slick_editors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slick.editors */ \"l/ju\");\n/* harmony import */ var _plugins_slick_rowselectionmodel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/slick.rowselectionmodel */ \"xLbl\");\n/*\n * Copyright (C) 2011 - present Instructure, Inc.\n *\n * This file is part of Canvas.\n *\n * Canvas is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, version 3 of the License.\n *\n * Canvas is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU Affero General Public License for more\n * details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n// add any plugins to slickgrid here\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Slick);\n\n//# sourceURL=webpack:///./packages/slickgrid/index.js?");

/***/ }),

/***/ "sbct":
/*!******************************************!*\
  !*** ./packages/slickgrid/slick.core.js ***!
  \******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"ouhR\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jquery_event_drag_2_2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jquery.event.drag-2.2 */ \"o6Wt\");\n/*\n * Copyright (c) 2010 Michael Leibman, http://github.com/mleibman/slickgrid\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n(function ($) {\n  // register namespace\n  $.extend(true, window, {\n    Slick: {\n      Event,\n      EventData,\n      EventHandler,\n      Range,\n      NonDataRow: NonDataItem,\n      Group,\n      GroupTotals,\n      EditorLock,\n\n      /** *\n       * A global singleton editor lock.\n       * @class GlobalEditorLock\n       * @static\n       * @constructor\n       */\n      GlobalEditorLock: new EditorLock()\n    }\n  });\n  /** *\n   * An event object for passing data to event handlers and letting them control propagation.\n   * <p>This is pretty much identical to how W3C and jQuery implement events.</p>\n   * @class EventData\n   * @constructor\n   */\n\n  function EventData() {\n    let isPropagationStopped = false;\n    let isImmediatePropagationStopped = false;\n    /** *\n     * Stops event from propagating up the DOM tree.\n     * @method stopPropagation\n     */\n\n    this.stopPropagation = function () {\n      isPropagationStopped = true;\n    };\n    /** *\n     * Returns whether stopPropagation was called on this event object.\n     * @method isPropagationStopped\n     * @return {Boolean}\n     */\n\n\n    this.isPropagationStopped = function () {\n      return isPropagationStopped;\n    };\n    /** *\n     * Prevents the rest of the handlers from being executed.\n     * @method stopImmediatePropagation\n     */\n\n\n    this.stopImmediatePropagation = function () {\n      isImmediatePropagationStopped = true;\n    };\n    /** *\n     * Returns whether stopImmediatePropagation was called on this event object.\\\n     * @method isImmediatePropagationStopped\n     * @return {Boolean}\n     */\n\n\n    this.isImmediatePropagationStopped = function () {\n      return isImmediatePropagationStopped;\n    };\n  }\n  /** *\n   * A simple publisher-subscriber implementation.\n   * @class Event\n   * @constructor\n   */\n\n\n  function Event() {\n    const handlers = [];\n    /** *\n     * Adds an event handler to be called when the event is fired.\n     * <p>Event handler will receive two arguments - an <code>EventData</code> and the <code>data</code>\n     * object the event was fired with.<p>\n     * @method subscribe\n     * @param fn {Function} Event handler.\n     */\n\n    this.subscribe = function (fn) {\n      handlers.push(fn);\n    };\n    /** *\n     * Removes an event handler added with <code>subscribe(fn)</code>.\n     * @method unsubscribe\n     * @param fn {Function} Event handler to be removed.\n     */\n\n\n    this.unsubscribe = function (fn) {\n      for (let i = handlers.length - 1; i >= 0; i--) {\n        if (handlers[i] === fn) {\n          handlers.splice(i, 1);\n        }\n      }\n    };\n    /** *\n     * Fires an event notifying all subscribers.\n     * @method notify\n     * @param args {Object} Additional data object to be passed to all handlers.\n     * @param e {EventData}\n     *      Optional.\n     *      An <code>EventData</code> object to be passed to all handlers.\n     *      For DOM events, an existing W3C/jQuery event object can be passed in.\n     * @param scope {Object}\n     *      Optional.\n     *      The scope (\"this\") within which the handler will be executed.\n     *      If not specified, the scope will be set to the <code>Event</code> instance.\n     */\n\n\n    this.notify = function (args, e, scope) {\n      e = e || new EventData();\n      scope = scope || this;\n      let returnValue;\n\n      for (let i = 0; i < handlers.length && !(e.isPropagationStopped() || e.isImmediatePropagationStopped()); i++) {\n        returnValue = handlers[i].call(scope, e, args);\n      }\n\n      return returnValue;\n    };\n  }\n\n  function EventHandler() {\n    let handlers = [];\n\n    this.subscribe = function (event, handler) {\n      handlers.push({\n        event,\n        handler\n      });\n      event.subscribe(handler);\n      return this; // allow chaining\n    };\n\n    this.unsubscribe = function (event, handler) {\n      let i = handlers.length;\n\n      while (i--) {\n        if (handlers[i].event === event && handlers[i].handler === handler) {\n          handlers.splice(i, 1);\n          event.unsubscribe(handler);\n          return;\n        }\n      }\n\n      return this; // allow chaining\n    };\n\n    this.unsubscribeAll = function () {\n      let i = handlers.length;\n\n      while (i--) {\n        handlers[i].event.unsubscribe(handlers[i].handler);\n      }\n\n      handlers = [];\n      return this; // allow chaining\n    };\n  }\n  /** *\n   * A structure containing a range of cells.\n   * @class Range\n   * @constructor\n   * @param fromRow {Integer} Starting row.\n   * @param fromCell {Integer} Starting cell.\n   * @param toRow {Integer} Optional. Ending row. Defaults to <code>fromRow</code>.\n   * @param toCell {Integer} Optional. Ending cell. Defaults to <code>fromCell</code>.\n   */\n\n\n  function Range(fromRow, fromCell, toRow, toCell) {\n    if (toRow === void 0 && toCell === void 0) {\n      toRow = fromRow;\n      toCell = fromCell;\n    }\n    /** *\n     * @property fromRow\n     * @type {Integer}\n     */\n\n\n    this.fromRow = Math.min(fromRow, toRow);\n    /** *\n     * @property fromCell\n     * @type {Integer}\n     */\n\n    this.fromCell = Math.min(fromCell, toCell);\n    /** *\n     * @property toRow\n     * @type {Integer}\n     */\n\n    this.toRow = Math.max(fromRow, toRow);\n    /** *\n     * @property toCell\n     * @type {Integer}\n     */\n\n    this.toCell = Math.max(fromCell, toCell);\n    /** *\n     * Returns whether a range represents a single row.\n     * @method isSingleRow\n     * @return {Boolean}\n     */\n\n    this.isSingleRow = function () {\n      return this.fromRow == this.toRow;\n    };\n    /** *\n     * Returns whether a range represents a single cell.\n     * @method isSingleCell\n     * @return {Boolean}\n     */\n\n\n    this.isSingleCell = function () {\n      return this.fromRow == this.toRow && this.fromCell == this.toCell;\n    };\n    /** *\n     * Returns whether a range contains a given cell.\n     * @method contains\n     * @param row {Integer}\n     * @param cell {Integer}\n     * @return {Boolean}\n     */\n\n\n    this.contains = function (row, cell) {\n      return row >= this.fromRow && row <= this.toRow && cell >= this.fromCell && cell <= this.toCell;\n    };\n    /** *\n     * Returns a readable representation of a range.\n     * @method toString\n     * @return {String}\n     */\n\n\n    this.toString = function () {\n      if (this.isSingleCell()) {\n        return `(${this.fromRow}:${this.fromCell})`;\n      } else {\n        return `(${this.fromRow}:${this.fromCell} - ${this.toRow}:${this.toCell})`;\n      }\n    };\n  }\n  /** *\n   * A base class that all special / non-data rows (like Group and GroupTotals) derive from.\n   * @class NonDataItem\n   * @constructor\n   */\n\n\n  function NonDataItem() {\n    this.__nonDataRow = true;\n  }\n  /** *\n   * Information about a group of rows.\n   * @class Group\n   * @extends Slick.NonDataItem\n   * @constructor\n   */\n\n\n  function Group() {\n    this.__group = true;\n    /**\n     * Grouping level, starting with 0.\n     * @property level\n     * @type {Number}\n     */\n\n    this.level = 0;\n    /** *\n     * Number of rows in the group.\n     * @property count\n     * @type {Integer}\n     */\n\n    this.count = 0;\n    /** *\n     * Grouping value.\n     * @property value\n     * @type {Object}\n     */\n\n    this.value = null;\n    /** *\n     * Formatted display value of the group.\n     * @property title\n     * @type {String}\n     */\n\n    this.title = null;\n    /** *\n     * Whether a group is collapsed.\n     * @property collapsed\n     * @type {Boolean}\n     */\n\n    this.collapsed = false;\n    /** *\n     * GroupTotals, if any.\n     * @property totals\n     * @type {GroupTotals}\n     */\n\n    this.totals = null;\n    /**\n     * Rows that are part of the group.\n     * @property rows\n     * @type {Array}\n     */\n\n    this.rows = [];\n    /**\n     * Sub-groups that are part of the group.\n     * @property groups\n     * @type {Array}\n     */\n\n    this.groups = null;\n    /**\n     * A unique key used to identify the group.  This key can be used in calls to DataView\n     * collapseGroup() or expandGroup().\n     * @property groupingKey\n     * @type {Object}\n     */\n\n    this.groupingKey = null;\n  }\n\n  Group.prototype = new NonDataItem();\n  /** *\n   * Compares two Group instances.\n   * @method equals\n   * @return {Boolean}\n   * @param group {Group} Group instance to compare to.\n   */\n\n  Group.prototype.equals = function (group) {\n    return this.value === group.value && this.count === group.count && this.collapsed === group.collapsed && this.title === group.title;\n  };\n  /** *\n   * Information about group totals.\n   * An instance of GroupTotals will be created for each totals row and passed to the aggregators\n   * so that they can store arbitrary data in it.  That data can later be accessed by group totals\n   * formatters during the display.\n   * @class GroupTotals\n   * @extends Slick.NonDataItem\n   * @constructor\n   */\n\n\n  function GroupTotals() {\n    this.__groupTotals = true;\n    /** *\n     * Parent Group.\n     * @param group\n     * @type {Group}\n     */\n\n    this.group = null;\n  }\n\n  GroupTotals.prototype = new NonDataItem();\n  /** *\n   * A locking helper to track the active edit controller and ensure that only a single controller\n   * can be active at a time.  This prevents a whole class of state and validation synchronization\n   * issues.  An edit controller (such as SlickGrid) can query if an active edit is in progress\n   * and attempt a commit or cancel before proceeding.\n   * @class EditorLock\n   * @constructor\n   */\n\n  function EditorLock() {\n    let activeEditController = null;\n    /** *\n     * Returns true if a specified edit controller is active (has the edit lock).\n     * If the parameter is not specified, returns true if any edit controller is active.\n     * @method isActive\n     * @param editController {EditController}\n     * @return {Boolean}\n     */\n\n    this.isActive = function (editController) {\n      return editController ? activeEditController === editController : activeEditController !== null;\n    };\n    /** *\n     * Sets the specified edit controller as the active edit controller (acquire edit lock).\n     * If another edit controller is already active, and exception will be thrown.\n     * @method activate\n     * @param editController {EditController} edit controller acquiring the lock\n     */\n\n\n    this.activate = function (editController) {\n      if (editController === activeEditController) {\n        // already activated?\n        return;\n      }\n\n      if (activeEditController !== null) {\n        throw \"SlickGrid.EditorLock.activate: an editController is still active, can't activate another editController\";\n      }\n\n      if (!editController.commitCurrentEdit) {\n        throw 'SlickGrid.EditorLock.activate: editController must implement .commitCurrentEdit()';\n      }\n\n      if (!editController.cancelCurrentEdit) {\n        throw 'SlickGrid.EditorLock.activate: editController must implement .cancelCurrentEdit()';\n      }\n\n      activeEditController = editController;\n    };\n    /** *\n     * Unsets the specified edit controller as the active edit controller (release edit lock).\n     * If the specified edit controller is not the active one, an exception will be thrown.\n     * @method deactivate\n     * @param editController {EditController} edit controller releasing the lock\n     */\n\n\n    this.deactivate = function (editController) {\n      if (activeEditController !== editController) {\n        throw 'SlickGrid.EditorLock.deactivate: specified editController is not the currently active one';\n      }\n\n      activeEditController = null;\n    };\n    /** *\n     * Attempts to commit the current edit by calling \"commitCurrentEdit\" method on the active edit\n     * controller and returns whether the commit attempt was successful (commit may fail due to validation\n     * errors, etc.).  Edit controller's \"commitCurrentEdit\" must return true if the commit has succeeded\n     * and false otherwise.  If no edit controller is active, returns true.\n     * @method commitCurrentEdit\n     * @return {Boolean}\n     */\n\n\n    this.commitCurrentEdit = function () {\n      return activeEditController ? activeEditController.commitCurrentEdit() : true;\n    };\n    /** *\n     * Attempts to cancel the current edit by calling \"cancelCurrentEdit\" method on the active edit\n     * controller and returns whether the edit was successfully cancelled.  If no edit controller is\n     * active, returns true.\n     * @method cancelCurrentEdit\n     * @return {Boolean}\n     */\n\n\n    this.cancelCurrentEdit = function cancelCurrentEdit() {\n      return activeEditController ? activeEditController.cancelCurrentEdit() : true;\n    };\n  }\n})(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\n\n//# sourceURL=webpack:///./packages/slickgrid/slick.core.js?");

/***/ }),

/***/ "xLbl":
/*!***************************************************************!*\
  !*** ./packages/slickgrid/plugins/slick.rowselectionmodel.js ***!
  \***************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"ouhR\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _slick_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../slick.core */ \"sbct\");\n/*\n * Copyright (c) 2010 Michael Leibman, http://github.com/mleibman/slickgrid\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\n(function ($) {\n  // register namespace\n  $.extend(true, window, {\n    Slick: {\n      RowSelectionModel\n    }\n  });\n\n  function RowSelectionModel(options) {\n    let _grid;\n\n    let _ranges = [];\n\n    const _self = this;\n\n    const _handler = new Slick.EventHandler();\n\n    let _inHandler;\n\n    let _options;\n\n    const _defaults = {\n      selectActiveRow: true\n    };\n\n    function init(grid) {\n      _options = $.extend(true, {}, _defaults, options);\n      _grid = grid;\n\n      _handler.subscribe(_grid.onActiveCellChanged, wrapHandler(handleActiveCellChange));\n\n      _handler.subscribe(_grid.onKeyDown, wrapHandler(handleKeyDown));\n\n      _handler.subscribe(_grid.onClick, wrapHandler(handleClick));\n    }\n\n    function destroy() {\n      _handler.unsubscribeAll();\n    }\n\n    function wrapHandler(handler) {\n      return function () {\n        if (!_inHandler) {\n          _inHandler = true;\n          handler.apply(this, arguments);\n          _inHandler = false;\n        }\n      };\n    }\n\n    function rangesToRows(ranges) {\n      const rows = [];\n\n      for (let i = 0; i < ranges.length; i++) {\n        for (let j = ranges[i].fromRow; j <= ranges[i].toRow; j++) {\n          rows.push(j);\n        }\n      }\n\n      return rows;\n    }\n\n    function rowsToRanges(rows) {\n      const ranges = [];\n      const lastCell = _grid.getColumns().length - 1;\n\n      for (let i = 0; i < rows.length; i++) {\n        ranges.push(new Slick.Range(rows[i], 0, rows[i], lastCell));\n      }\n\n      return ranges;\n    }\n\n    function getRowsRange(from, to) {\n      let i,\n          rows = [];\n\n      for (i = from; i <= to; i++) {\n        rows.push(i);\n      }\n\n      for (i = to; i < from; i++) {\n        rows.push(i);\n      }\n\n      return rows;\n    }\n\n    function getSelectedRows() {\n      return rangesToRows(_ranges);\n    }\n\n    function setSelectedRows(rows) {\n      setSelectedRanges(rowsToRanges(rows));\n    }\n\n    function setSelectedRanges(ranges) {\n      _ranges = ranges;\n\n      _self.onSelectedRangesChanged.notify(_ranges);\n    }\n\n    function getSelectedRanges() {\n      return _ranges;\n    }\n\n    function handleActiveCellChange(e, data) {\n      if (_options.selectActiveRow && data.row != null) {\n        setSelectedRanges([new Slick.Range(data.row, 0, data.row, _grid.getColumns().length - 1)]);\n      }\n    }\n\n    function handleKeyDown(e) {\n      const activeRow = _grid.getActiveCell();\n\n      if (activeRow && e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && (e.which == 38 || e.which == 40)) {\n        let selectedRows = getSelectedRows();\n        selectedRows.sort((x, y) => x - y);\n\n        if (!selectedRows.length) {\n          selectedRows = [activeRow.row];\n        }\n\n        let top = selectedRows[0];\n        let bottom = selectedRows[selectedRows.length - 1];\n        let active;\n\n        if (e.which == 40) {\n          active = activeRow.row < bottom || top == bottom ? ++bottom : ++top;\n        } else {\n          active = activeRow.row < bottom ? --bottom : --top;\n        }\n\n        if (active >= 0 && active < _grid.getDataLength()) {\n          _grid.scrollRowIntoView(active);\n\n          _ranges = rowsToRanges(getRowsRange(top, bottom));\n          setSelectedRanges(_ranges);\n        }\n\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n\n    function handleClick(e) {\n      const cell = _grid.getCellFromEvent(e);\n\n      if (!cell || !_grid.canCellBeActive(cell.row, cell.cell)) {\n        return false;\n      }\n\n      let selection = rangesToRows(_ranges);\n      const idx = $.inArray(cell.row, selection);\n\n      if (!e.ctrlKey && !e.shiftKey && !e.metaKey) {\n        return false;\n      } else if (_grid.getOptions().multiSelect) {\n        if (idx === -1 && (e.ctrlKey || e.metaKey)) {\n          selection.push(cell.row);\n\n          _grid.setActiveCell(cell.row, cell.cell);\n        } else if (idx !== -1 && (e.ctrlKey || e.metaKey)) {\n          selection = $.grep(selection, (o, i) => o !== cell.row);\n\n          _grid.setActiveCell(cell.row, cell.cell);\n        } else if (selection.length && e.shiftKey) {\n          const last = selection.pop();\n          const from = Math.min(cell.row, last);\n          const to = Math.max(cell.row, last);\n          selection = [];\n\n          for (let i = from; i <= to; i++) {\n            if (i !== last) {\n              selection.push(i);\n            }\n          }\n\n          selection.push(last);\n\n          _grid.setActiveCell(cell.row, cell.cell);\n        }\n      }\n\n      _ranges = rowsToRanges(selection);\n      setSelectedRanges(_ranges);\n      e.stopImmediatePropagation();\n      return true;\n    }\n\n    $.extend(this, {\n      getSelectedRows,\n      setSelectedRows,\n      getSelectedRanges,\n      setSelectedRanges,\n      init,\n      destroy,\n      onSelectedRangesChanged: new Slick.Event()\n    });\n  }\n})(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\n\n//# sourceURL=webpack:///./packages/slickgrid/plugins/slick.rowselectionmodel.js?");

/***/ })

}]);
(window["canvasWebpackJsonp"] = window["canvasWebpackJsonp"] || []).push([[44],{

/***/ "EyBU":
/*!****************************************!*\
  !*** ./ui/shared/upload-file/index.js ***!
  \****************************************/
/*! exports provided: uploadFile, completeUpload, submissionCommentAttachmentsUpload, uploadFiles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uploadFile\", function() { return uploadFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"completeUpload\", function() { return completeUpload; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"submissionCommentAttachmentsUpload\", function() { return submissionCommentAttachmentsUpload; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uploadFiles\", function() { return uploadFiles; });\n/* harmony import */ var _babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectSpread2 */ \"VTBJ\");\n/* harmony import */ var _canvas_axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @canvas/axios */ \"BrAc\");\n/* harmony import */ var qs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! qs */ \"Qyje\");\n/* harmony import */ var qs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(qs__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var i18n_upload_file__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! i18n!upload_file */ \"mNzZ\");\n/* harmony import */ var _canvas_progress_resolve_progress__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @canvas/progress/resolve_progress */ \"gBVS\");\n\n\n/*\n * Copyright (C) 2017 - present Instructure, Inc.\n *\n * This file is part of Canvas.\n *\n * Canvas is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, version 3 of the License.\n *\n * Canvas is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU Affero General Public License for more\n * details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n\n\n // error interpretations. specifically avoid reporting an unhelpful \"Network\n// Error\". TODO: more introspection of the errors for more detailed/specific\n// error messages.\n\nfunction preflightFailed(err) {\n  if (err.message === 'Network Error') {\n    const wrapped = new Error(i18n_upload_file__WEBPACK_IMPORTED_MODULE_3__[\"default\"].t('Canvas failed to initiate the upload.'));\n    wrapped.originalError = err;\n    return Promise.reject(wrapped);\n  }\n\n  return Promise.reject(err);\n}\n\nfunction fileUploadFailed(err) {\n  if (err.message === 'Network Error') {\n    // something broke in the attempt to upload the file before the storage\n    // service could give a proper response. most likely is that an\n    // authentication failure broke the OPTIONS pre-request, causing a CORS\n    // fault\n    const wrapped = new Error(i18n_upload_file__WEBPACK_IMPORTED_MODULE_3__[\"default\"].t('Unable to transmit file to the storage service. The service may be down or you may need to re-login to Canvas.'));\n    wrapped.originalError = err;\n    return Promise.reject(wrapped);\n  }\n\n  return Promise.reject(err);\n}\n\nfunction postUploadFailed(err) {\n  if (err.message === 'Network Error') {\n    const wrapped = new Error(i18n_upload_file__WEBPACK_IMPORTED_MODULE_3__[\"default\"].t('Canvas failed to complete the upload.'));\n    wrapped.originalError = err;\n    return Promise.reject(wrapped);\n  }\n\n  return Promise.reject(err);\n}\n/*\n * preflightUrl: usually something like\n *   `/api/v1/courses/:course_id/files` or\n *   `/api/v1/folders/:folder_id/files`\n * preflightData: see api, but something like\n *   `{ name, size, parent_folder_path, type, on_duplicate }`\n *   note that `no_redirect: true` will be forced\n * file: the file object to upload.\n *   To get this off of an input element: `input.files[0]`\n *   To get this off of a drop event: `e.dataTransfer.files[0]`\n */\n\n\nfunction uploadFile(preflightUrl, preflightData, file, ajaxLib = _canvas_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"], onProgress) {\n  if (!file && !preflightData.url) {\n    throw new Error('expected either a file to upload or a url to clone', {\n      file,\n      preflightData\n    });\n  } else if (file && preflightData.url) {\n    throw new Error(\"can't upload with both a file object and a url to clone\", {\n      file,\n      preflightData\n    });\n  } // force \"no redirect\" behavior. redirecting from the S3 POST breaks under\n  // CORS in this pathway\n\n\n  preflightData.no_redirect = true; // when preflightData is flat, won't parse right on server as JSON, so force\n  // into a query string\n\n  if (preflightData['attachment[context_code]']) {\n    preflightData = qs__WEBPACK_IMPORTED_MODULE_2___default.a.stringify(preflightData);\n  }\n\n  return ajaxLib.post(preflightUrl, preflightData).catch(preflightFailed).then(response => completeUpload(response.data, file, {\n    ajaxLib,\n    onProgress\n  }));\n}\n/*\n * preflightResponse: the response from a preflight request. expected to\n *   contain an `upload_url` and `upload_params` at minimum. `file_param` and\n *   `success_url` are also recognized.\n * file: the file object to upload. see previous function\n * options: to tune or hook into the upload\n *   `filename`: a forced filename for the uploaded file\n *   `onProgress`: a callback to be triggered by upload progress events\n *   `ignoreResult`: after an upload, additional requests may be necessary to\n *     get the metadata about the file; this allows those to be skipped. any\n *     success_url will still be pinged.\n *   `includeAvatar`: if true, request avatar information when fetching file\n *     metadata after upload.\n */\n\nfunction completeUpload(preflightResponse, file, options = {}) {\n  const ajaxLib = options.ajaxLib || _canvas_axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n  const ajaxLibOptions = options.ajaxLibOptions || {}; // account for attachments wrapped in array per JSON API format\n\n  if (preflightResponse && preflightResponse.attachments && preflightResponse.attachments[0]) {\n    preflightResponse = preflightResponse.attachments[0];\n  }\n\n  if (!preflightResponse) {\n    throw new Error('expected a preflightResponse');\n  } else if (file && !preflightResponse.upload_url) {\n    throw new Error('expected a preflightResponse with an upload_url', {\n      preflightResponse\n    });\n  } else if (!file && !preflightResponse.progress) {\n    throw new Error('expected a preflightResponse with a progress', {\n      preflightResponse\n    });\n  }\n\n  const _preflightResponse = preflightResponse,\n        upload_url = _preflightResponse.upload_url,\n        progress = _preflightResponse.progress;\n\n  if (!upload_url) {\n    // cloning a url and don't need to repost elsewhere, just wait on progress\n    return Object(_canvas_progress_resolve_progress__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(progress, {\n      ajaxLib\n    }).catch(postUploadFailed);\n  }\n\n  let _preflightResponse2 = preflightResponse,\n      file_param = _preflightResponse2.file_param,\n      upload_params = _preflightResponse2.upload_params,\n      success_url = _preflightResponse2.success_url;\n  file_param = file_param || 'file';\n  upload_params = upload_params || {};\n  success_url = success_url || upload_params.success_url;\n  const isToS3 = !!success_url; // post upload\n  // xsslint xssable.receiver.whitelist formData\n\n  const formData = new FormData();\n  Object.entries(upload_params).forEach(([key, value]) => formData.append(key, value));\n\n  if (file) {\n    formData.append(file_param, file, options.filename);\n  }\n\n  const upload = ajaxLib.post(upload_url, formData, Object(_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    responseType: isToS3 ? 'document' : 'json',\n    onUploadProgress: options.onProgress,\n    withCredentials: !isToS3\n  }, ajaxLibOptions)); // finalize upload\n\n  return upload.catch(fileUploadFailed).then(response => {\n    if (progress) {\n      // cloning a url, wait on the progress object to complete, the return its\n      // results as the data\n      return Object(_canvas_progress_resolve_progress__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(progress, {\n        ajaxLib\n      }).catch(postUploadFailed);\n    }\n\n    let location,\n        query = {};\n\n    if (success_url) {\n      // s3 upload, follow-up at success_url with s3 data to finalize\n      const _response$data = response.data,\n            Bucket = _response$data.Bucket,\n            Key = _response$data.Key,\n            ETag = _response$data.ETag;\n      location = success_url;\n      query = {\n        bucket: Bucket,\n        key: Key,\n        etag: ETag\n      };\n    } else if (response.status === 201 && !options.ignoreResult) {\n      // inst-fs upload, follow-up at location from response\n      location = response.data.location;\n      query = {};\n    }\n\n    if (location) {\n      // include avatar in query if necessary\n      if (options.includeAvatar) {\n        query.include = 'avatar';\n      } // send request to follow-up url with query\n\n\n      query = qs__WEBPACK_IMPORTED_MODULE_2___default.a.stringify(query);\n\n      if (query) {\n        if (location.indexOf('?') !== -1) {\n          location = `${location}&${query}`;\n        } else {\n          location = `${location}?${query}`;\n        }\n      }\n\n      return ajaxLib.get(location).then(({\n        data\n      }) => data).catch(postUploadFailed);\n    } else {\n      // local-storage upload, this _is_ the attachment information\n      return response.data;\n    }\n  });\n}\n/*\n * This is a helper file for uploading a file to a submissions comment\n * for a logged in user before actually creating the submissions comment\n *\n * @returns an array of attachment objects. The attachment objects contain ids\n * that a submissions comment can link to\n */\n\nfunction submissionCommentAttachmentsUpload(files, courseId, assignmentId) {\n  const preflightFileUploadUrl = `/api/v1/courses/${courseId}/assignments/${assignmentId}/submissions/self/comments/files`;\n  const uploadPromises = files.map(currentFile => {\n    const preflightFileData = {\n      name: currentFile.name,\n      content_type: currentFile.type\n    };\n    return uploadFile(preflightFileUploadUrl, preflightFileData, currentFile);\n  });\n  return Promise.all(uploadPromises);\n}\n/*\n * This is a helper function for uploading multiple files to a given\n * upload url\n *\n * @returns an array of attachment objects.\n */\n\nfunction uploadFiles(files, uploadUrl) {\n  // We differentiate between a normal file and an lti content item\n  // based on the existence of a url attribute on the object. Then we invoke\n  // the uploadFile function with different parameters based on whether its a\n  // normal file or a content item backed by a file url. The parameters we are\n  // providing are determined by the file uploads api whose documentation can\n  // be found at /doc/api/file_uploads.md\n  const uploadPromises = files.map(file => {\n    if (file.url) {\n      return uploadFile(uploadUrl, {\n        url: file.url,\n        name: file.title,\n        content_type: file.mediaType,\n        submit_assignment: false\n      });\n    } else {\n      return uploadFile(uploadUrl, {\n        name: file.name,\n        content_type: file.type\n      }, file);\n    }\n  });\n  return Promise.all(uploadPromises);\n}\n\n//# sourceURL=webpack:///./ui/shared/upload-file/index.js?");

/***/ }),

/***/ "gBVS":
/*!************************************************!*\
  !*** ./ui/shared/progress/resolve_progress.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return resolveProgress; });\n/* harmony import */ var _canvas_axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @canvas/axios */ \"BrAc\");\n/*\n * Copyright (C) 2018 - present Instructure, Inc.\n *\n * This file is part of Canvas.\n *\n * Canvas is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, version 3 of the License.\n *\n * Canvas is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU Affero General Public License for more\n * details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n\nfunction delayAsPromise(interval) {\n  return new Promise(resolve => {\n    setTimeout(resolve, interval);\n  });\n} // takes a object description of a Canvas Progress object (per the API docs)\n// and polls every `interval` until the progress completes or fails. returns a\n// Promise that resolves when the progress completes and that rejects when it\n// fails.\n\n\nfunction resolveProgress(progress, options = {}) {\n  const ajaxLib = options.ajaxLib || _canvas_axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n  const url = progress.url,\n        workflow_state = progress.workflow_state,\n        results = progress.results,\n        message = progress.message;\n\n  if (workflow_state === 'queued' || workflow_state === 'running') {\n    // poll again after a delay. default to once a second if not specified, and\n    // wait at least 100ms between polls even if asked for less.\n    let interval = options.interval;\n\n    if (false) {} else {\n      if (!interval) interval = 1000;\n      if (interval < 100) interval = 100;\n    }\n\n    return delayAsPromise(interval).then(() => ajaxLib.get(url)).then(response => {\n      const newProgress = response.data;\n      return resolveProgress(newProgress, options);\n    });\n  } else if (workflow_state === 'completed') {\n    // done\n    return Promise.resolve(results);\n  } else {\n    // failed\n    return Promise.reject(message);\n  }\n}\n\n//# sourceURL=webpack:///./ui/shared/progress/resolve_progress.js?");

/***/ }),

/***/ "mNzZ":
/*!****************************************************************************!*\
  !*** ./frontend_build/i18n.js?upload_file!./ui/shims/dummyI18nResource.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _canvas_i18n_i18nObj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @canvas/i18n/i18nObj */ \"HGxv\");\n/* harmony import */ var translations_core_en__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! translations/_core_en */ \"0sPK\");\n\n    \n    \n    \n\n    /* harmony default export */ __webpack_exports__[\"default\"] = (_canvas_i18n_i18nObj__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scoped('upload_file'));\n  \n\n//# sourceURL=webpack:///./ui/shims/dummyI18nResource.js?./frontend_build/i18n.js?upload_file");

/***/ })

}]);
(window["canvasWebpackJsonp"] = window["canvasWebpackJsonp"] || []).push([[3695],{

/***/ "8V8Z":
/*!**********************************************************!*\
  !*** ./packages/canvas-rce/es/canvasFileBrowser/date.js ***!
  \**********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parser.js */ \"RfAR\");\n/*\n * Copyright (C) 2020 - present Instructure, Inc.\n *\n * This file is part of Canvas.\n *\n * Canvas is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, version 3 of the License.\n *\n * Canvas is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU Affero General Public License for more\n * details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n// just a stub to require the right date.js source file to behave the same as\n// the old minified version\n\n\n//# sourceURL=webpack:///./packages/canvas-rce/es/canvasFileBrowser/date.js?");

/***/ }),

/***/ "RfAR":
/*!************************************************************!*\
  !*** ./packages/canvas-rce/es/canvasFileBrowser/parser.js ***!
  \************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _sugarpak_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sugarpak.js */ \"YveN\");\n/**\n * @version: 1.0 Alpha-1\n * @author: Coolite Inc. http://www.coolite.com/\n * @date: 2008-04-13\n * @copyright: Copyright (c) 2006-2008, Coolite Inc. (http://www.coolite.com/). All rights reserved.\n * @license: Licensed under The MIT License. See license.txt and http://www.datejs.com/license/.\n * @website: http://www.datejs.com/\n */\n\n\n(function () {\n  Date.Parsing = {\n    Exception(s) {\n      this.message = \"Parse error at '\" + s.substring(0, 10) + \" ...'\";\n    }\n\n  };\n  const $P = Date.Parsing;\n\n  var _ = $P.Operators = {\n    //\n    // Tokenizers\n    //\n    rtoken(r) {\n      // regex token\n      return function (s) {\n        const mx = s.match(r);\n\n        if (mx) {\n          return [mx[0], s.substring(mx[0].length)];\n        } else {\n          throw new $P.Exception(s);\n        }\n      };\n    },\n\n    token() {\n      // whitespace-eating token\n      return function (s) {\n        return _.rtoken(new RegExp('^s*' + s + 's*'))(s); // Removed .strip()\n        // return _.rtoken(new RegExp(\"^\\s*\" + s + \"\\s*\"))(s).strip();\n      };\n    },\n\n    stoken(s) {\n      // string token\n      return _.rtoken(new RegExp('^' + s));\n    },\n\n    //\n    // Atomic Operators\n    //\n    until(p) {\n      return function (s) {\n        let qx = [],\n            rx = null;\n\n        while (s.length) {\n          try {\n            rx = p.call(this, s);\n          } catch (e) {\n            qx.push(rx[0]);\n            s = rx[1];\n            continue;\n          }\n\n          break;\n        }\n\n        return [qx, s];\n      };\n    },\n\n    many(p) {\n      return function (s) {\n        let rx = [],\n            r = null;\n\n        while (s.length) {\n          try {\n            r = p.call(this, s);\n          } catch (e) {\n            return [rx, s];\n          }\n\n          rx.push(r[0]);\n          s = r[1];\n        }\n\n        return [rx, s];\n      };\n    },\n\n    // generator operators -- see below\n    optional(p) {\n      return function (s) {\n        let r = null;\n\n        try {\n          r = p.call(this, s);\n        } catch (e) {\n          return [null, s];\n        }\n\n        return [r[0], r[1]];\n      };\n    },\n\n    not(p) {\n      return function (s) {\n        try {\n          p.call(this, s);\n        } catch (e) {\n          return [null, s];\n        }\n\n        throw new $P.Exception(s);\n      };\n    },\n\n    ignore(p) {\n      return p ? function (s) {\n        let r = null;\n        r = p.call(this, s);\n        return [null, r[1]];\n      } : null;\n    },\n\n    product() {\n      const px = arguments[0],\n            qx = Array.prototype.slice.call(arguments, 1),\n            rx = [];\n\n      for (let i = 0; i < px.length; i++) {\n        rx.push(_.each(px[i], qx));\n      }\n\n      return rx;\n    },\n\n    cache(rule) {\n      let cache = {},\n          r = null;\n      return function (s) {\n        try {\n          r = cache[s] = cache[s] || rule.call(this, s);\n        } catch (e) {\n          r = cache[s] = e;\n        }\n\n        if (r instanceof $P.Exception) {\n          throw r;\n        } else {\n          return r;\n        }\n      };\n    },\n\n    // vector operators -- see below\n    any() {\n      const px = arguments;\n      return function (s) {\n        let r = null;\n\n        for (let i = 0; i < px.length; i++) {\n          if (px[i] == null) {\n            continue;\n          }\n\n          try {\n            r = px[i].call(this, s);\n          } catch (e) {\n            r = null;\n          }\n\n          if (r) {\n            return r;\n          }\n        }\n\n        throw new $P.Exception(s);\n      };\n    },\n\n    each() {\n      const px = arguments;\n      return function (s) {\n        let rx = [],\n            r = null;\n\n        for (let i = 0; i < px.length; i++) {\n          if (px[i] == null) {\n            continue;\n          }\n\n          try {\n            r = px[i].call(this, s);\n          } catch (e) {\n            throw new $P.Exception(s);\n          }\n\n          rx.push(r[0]);\n          s = r[1];\n        }\n\n        return [rx, s];\n      };\n    },\n\n    all() {\n      var px = arguments,\n          _ = _;\n      return _.each(_.optional(px));\n    },\n\n    // delimited operators\n    sequence(px, d, c) {\n      d = d || _.rtoken(/^\\s*/);\n      c = c || null;\n\n      if (px.length == 1) {\n        return px[0];\n      }\n\n      return function (s) {\n        let r = null,\n            q = null;\n        const rx = [];\n\n        for (let i = 0; i < px.length; i++) {\n          try {\n            r = px[i].call(this, s);\n          } catch (e) {\n            break;\n          }\n\n          rx.push(r[0]);\n\n          try {\n            q = d.call(this, r[1]);\n          } catch (ex) {\n            q = null;\n            break;\n          }\n\n          s = q[1];\n        }\n\n        if (!r) {\n          throw new $P.Exception(s);\n        }\n\n        if (q) {\n          throw new $P.Exception(q[1]);\n        }\n\n        if (c) {\n          try {\n            r = c.call(this, r[1]);\n          } catch (ey) {\n            throw new $P.Exception(r[1]);\n          }\n        }\n\n        return [rx, r ? r[1] : s];\n      };\n    },\n\n    //\n    // Composite Operators\n    //\n    between(d1, p, d2) {\n      d2 = d2 || d1;\n\n      const _fn = _.each(_.ignore(d1), p, _.ignore(d2));\n\n      return function (s) {\n        const rx = _fn.call(this, s);\n\n        return [[rx[0][0], r[0][2]], rx[1]];\n      };\n    },\n\n    list(p, d, c) {\n      d = d || _.rtoken(/^\\s*/);\n      c = c || null;\n      return p instanceof Array ? _.each(_.product(p.slice(0, -1), _.ignore(d)), p.slice(-1), _.ignore(c)) : _.each(_.many(_.each(p, _.ignore(d))), px, _.ignore(c));\n    },\n\n    set(px, d, c) {\n      d = d || _.rtoken(/^\\s*/);\n      c = c || null;\n      return function (s) {\n        // r is the current match, best the current 'best' match\n        // which means it parsed the most amount of input\n        let r = null,\n            p = null,\n            q = null,\n            rx = null,\n            best = [[], s],\n            last = false; // go through the rules in the given set\n\n        for (let i = 0; i < px.length; i++) {\n          // last is a flag indicating whether this must be the last element\n          // if there is only 1 element, then it MUST be the last one\n          q = null;\n          p = null;\n          r = null;\n          last = px.length == 1; // first, we try simply to match the current pattern\n          // if not, try the next pattern\n\n          try {\n            r = px[i].call(this, s);\n          } catch (e) {\n            continue;\n          } // since we are matching against a set of elements, the first\n          // thing to do is to add r[0] to matched elements\n\n\n          rx = [[r[0]], r[1]]; // if we matched and there is still input to parse and\n          // we don't already know this is the last element,\n          // we're going to next check for the delimiter ...\n          // if there's none, or if there's no input left to parse\n          // than this must be the last element after all ...\n\n          if (r[1].length > 0 && !last) {\n            try {\n              q = d.call(this, r[1]);\n            } catch (ex) {\n              last = true;\n            }\n          } else {\n            last = true;\n          } // if we parsed the delimiter and now there's no more input,\n          // that means we shouldn't have parsed the delimiter at all\n          // so don't update r and mark this as the last element ...\n\n\n          if (!last && q[1].length === 0) {\n            last = true;\n          } // so, if this isn't the last element, we're going to see if\n          // we can get any more matches from the remaining (unmatched)\n          // elements ...\n\n\n          if (!last) {\n            // build a list of the remaining rules we can match against,\n            // i.e., all but the one we just matched against\n            const qx = [];\n\n            for (let j = 0; j < px.length; j++) {\n              if (i != j) {\n                qx.push(px[j]);\n              }\n            } // now invoke recursively set with the remaining input\n            // note that we don't include the closing delimiter ...\n            // we'll check for that ourselves at the end\n\n\n            p = _.set(qx, d).call(this, q[1]); // if we got a non-empty set as a result ...\n            // (otw rx already contains everything we want to match)\n\n            if (p[0].length > 0) {\n              // update current result, which is stored in rx ...\n              // basically, pick up the remaining text from p[1]\n              // and concat the result from p[0] so that we don't\n              // get endless nesting ...\n              rx[0] = rx[0].concat(p[0]);\n              rx[1] = p[1];\n            }\n          } // at this point, rx either contains the last matched element\n          // or the entire matched set that starts with this element.\n          // now we just check to see if this variation is better than\n          // our best so far, in terms of how much of the input is parsed\n\n\n          if (rx[1].length < best[1].length) {\n            best = rx;\n          } // if we've parsed all the input, then we're finished\n\n\n          if (best[1].length === 0) {\n            break;\n          }\n        } // so now we've either gone through all the patterns trying them\n        // as the initial match; or we found one that parsed the entire\n        // input string ...\n        // if best has no matches, just return empty set ...\n\n\n        if (best[0].length === 0) {\n          return best;\n        } // if a closing delimiter is provided, then we have to check it also\n\n\n        if (c) {\n          // we try this even if there is no remaining input because the pattern\n          // may well be optional or match empty input ...\n          try {\n            q = c.call(this, best[1]);\n          } catch (ey) {\n            throw new $P.Exception(best[1]);\n          } // it parsed ... be sure to update the best match remaining input\n\n\n          best[1] = q[1];\n        } // if we're here, either there was no closing delimiter or we parsed it\n        // so now we have the best match; just return it!\n\n\n        return best;\n      };\n    },\n\n    forward(gr, fname) {\n      return function (s) {\n        return gr[fname].call(this, s);\n      };\n    },\n\n    //\n    // Translation Operators\n    //\n    replace(rule, repl) {\n      return function (s) {\n        const r = rule.call(this, s);\n        return [repl, r[1]];\n      };\n    },\n\n    process(rule, fn) {\n      return function (s) {\n        const r = rule.call(this, s);\n        return [fn.call(this, r[0]), r[1]];\n      };\n    },\n\n    min(min, rule) {\n      return function (s) {\n        const rx = rule.call(this, s);\n\n        if (rx[0].length < min) {\n          throw new $P.Exception(s);\n        }\n\n        return rx;\n      };\n    }\n\n  }; // Generator Operators And Vector Operators\n  // Generators are operators that have a signature of F(R) => R,\n  // taking a given rule and returning another rule, such as\n  // ignore, which parses a given rule and throws away the result.\n  // Vector operators are those that have a signature of F(R1,R2,...) => R,\n  // take a list of rules and returning a new rule, such as each.\n  // Generator operators are converted (via the following _generator\n  // function) into functions that can also take a list or array of rules\n  // and return an array of new rules as though the function had been\n  // called on each rule in turn (which is what actually happens).\n  // This allows generators to be used with vector operators more easily.\n  // Example:\n  // each(ignore(foo, bar)) instead of each(ignore(foo), ignore(bar))\n  // This also turns generators into vector operators, which allows\n  // constructs like:\n  // not(cache(foo, bar))\n\n\n  const _generator = function (op) {\n    return function () {\n      let args = null,\n          rx = [];\n\n      if (arguments.length > 1) {\n        args = Array.prototype.slice.call(arguments);\n      } else if (arguments[0] instanceof Array) {\n        args = arguments[0];\n      }\n\n      if (args) {\n        for (let i = 0, px = args.shift(); i < px.length; i++) {\n          args.unshift(px[i]);\n          rx.push(op.apply(null, args));\n          args.shift();\n          return rx;\n        }\n      } else {\n        return op.apply(null, arguments);\n      }\n    };\n  };\n\n  const gx = 'optional not ignore cache'.split(/\\s/);\n\n  for (let i = 0; i < gx.length; i++) {\n    _[gx[i]] = _generator(_[gx[i]]);\n  }\n\n  const _vector = function (op) {\n    return function () {\n      if (arguments[0] instanceof Array) {\n        return op.apply(null, arguments[0]);\n      } else {\n        return op.apply(null, arguments);\n      }\n    };\n  };\n\n  const vx = 'each any all'.split(/\\s/);\n\n  for (let j = 0; j < vx.length; j++) {\n    _[vx[j]] = _vector(_[vx[j]]);\n  }\n})();\n\n(function () {\n  const $D = Date,\n        $P = $D.prototype,\n        $C = $D.CultureInfo;\n\n  var flattenAndCompact = function (ax) {\n    let rx = [];\n\n    for (let i = 0; i < ax.length; i++) {\n      if (ax[i] instanceof Array) {\n        rx = rx.concat(flattenAndCompact(ax[i]));\n      } else if (ax[i]) {\n        rx.push(ax[i]);\n      }\n    }\n\n    return rx;\n  };\n\n  $D.Grammar = {};\n  $D.Translator = {\n    hour(s) {\n      return function () {\n        this.hour = Number(s);\n      };\n    },\n\n    minute(s) {\n      return function () {\n        this.minute = Number(s);\n      };\n    },\n\n    second(s) {\n      return function () {\n        this.second = Number(s);\n      };\n    },\n\n    meridian(s) {\n      return function () {\n        this.meridian = s.slice(0, 1).toLowerCase();\n      };\n    },\n\n    timezone(s) {\n      return function () {\n        const n = s.replace(/[^\\d\\+\\-]/g, '');\n\n        if (n.length) {\n          this.timezoneOffset = Number(n);\n        } else if (s == 'Z') {\n          this.timezoneOffset = 0;\n        } else {\n          this.timezone = s.toLowerCase();\n        }\n      };\n    },\n\n    day(x) {\n      const s = x[0];\n      return function () {\n        this.day = Number(s.match(/\\d+/)[0]);\n      };\n    },\n\n    month(s) {\n      return function () {\n        this.month = s.length == 3 ? 'jan feb mar apr may jun jul aug sep oct nov dec'.indexOf(s) / 4 : Number(s) - 1;\n      };\n    },\n\n    year(s) {\n      return function () {\n        const n = Number(s);\n        this.year = s.length > 2 ? n : n + (n + 2000 < $C.twoDigitYearMax ? 2000 : 1900);\n      };\n    },\n\n    rday(s) {\n      return function () {\n        switch (s) {\n          case 'yesterday':\n            this.days = -1;\n            break;\n\n          case 'tomorrow':\n            this.days = 1;\n            break;\n\n          case 'today':\n            this.days = 0;\n            break;\n\n          case 'now':\n            this.days = 0;\n            this.now = true;\n            break;\n        }\n      };\n    },\n\n    finishExact(x) {\n      x = x instanceof Array ? x : [x];\n\n      for (let i = 0; i < x.length; i++) {\n        if (x[i]) {\n          x[i].call(this);\n        }\n      }\n\n      const now = new Date();\n\n      if ((this.hour || this.minute) && !this.month && !this.year && !this.day) {\n        this.day = now.getDate();\n      }\n\n      if (!this.year) {\n        this.year = now.getFullYear();\n      }\n\n      if (!this.month && this.month !== 0) {\n        this.month = now.getMonth();\n      }\n\n      if (!this.day) {\n        this.day = 1;\n      }\n\n      if (!this.hour) {\n        this.hour = 0;\n      }\n\n      if (!this.minute) {\n        this.minute = 0;\n      }\n\n      if (!this.second) {\n        this.second = 0;\n      }\n\n      if (this.meridian && this.hour) {\n        if (this.meridian == 'p' && this.hour < 12) {\n          this.hour += 12;\n        } else if (this.meridian == 'a' && this.hour == 12) {\n          this.hour = 0;\n        }\n      }\n\n      if (this.day > $D.getDaysInMonth(this.year, this.month)) {\n        throw new RangeError(this.day + ' is not a valid value for days.');\n      }\n\n      const r = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second);\n\n      if (this.timezone) {\n        r.set({\n          timezone: this.timezone\n        });\n      } else if (this.timezoneOffset != null) {\n        r.set({\n          timezoneOffset: this.timezoneOffset\n        });\n      }\n\n      return r;\n    },\n\n    finish(x) {\n      x = x instanceof Array ? flattenAndCompact(x) : [x];\n\n      if (x.length === 0) {\n        return null;\n      }\n\n      for (let i = 0; i < x.length; i++) {\n        if (typeof x[i] === 'function') {\n          x[i].call(this);\n        }\n      }\n\n      let today = $D.today();\n\n      if (this.now && !this.unit && !this.operator) {\n        return new Date();\n      } else if (this.now) {\n        today = new Date();\n      }\n\n      let expression = !!(this.days && this.days !== null || this.orient || this.operator);\n      let gap, mod, orient;\n      orient = this.orient == 'past' || this.operator == 'subtract' ? -1 : 1;\n\n      if (!this.now && 'hour minute second'.indexOf(this.unit) != -1) {\n        today.setTimeToNow();\n      }\n\n      if (this.month || this.month === 0) {\n        if ('year day hour minute second'.indexOf(this.unit) != -1) {\n          this.value = this.month + 1;\n          this.month = null;\n          expression = true;\n        }\n      }\n\n      if (!expression && this.weekday && !this.day && !this.days) {\n        var temp = Date[this.weekday]();\n        this.day = temp.getDate();\n\n        if (!this.month) {\n          this.month = temp.getMonth();\n        }\n\n        this.year = temp.getFullYear();\n      }\n\n      if (expression && this.weekday && this.unit != 'month') {\n        this.unit = 'day';\n        gap = $D.getDayNumberFromName(this.weekday) - today.getDay();\n        mod = 7;\n        this.days = gap ? (gap + orient * mod) % mod : orient * mod;\n      }\n\n      if (this.month && this.unit == 'day' && this.operator) {\n        this.value = this.month + 1;\n        this.month = null;\n      }\n\n      if (this.value != null && this.month != null && this.year != null) {\n        this.day = this.value * 1;\n      }\n\n      if (this.month && !this.day && this.value) {\n        today.set({\n          day: this.value * 1\n        });\n\n        if (!expression) {\n          this.day = this.value * 1;\n        }\n      }\n\n      if (!this.month && this.value && this.unit == 'month' && !this.now) {\n        this.month = this.value;\n        expression = true;\n      }\n\n      if (expression && (this.month || this.month === 0) && this.unit != 'year') {\n        this.unit = 'month';\n        gap = this.month - today.getMonth();\n        mod = 12;\n        this.months = gap ? (gap + orient * mod) % mod : orient * mod;\n        this.month = null;\n      }\n\n      if (!this.unit) {\n        this.unit = 'day';\n      }\n\n      if (!this.value && this.operator && this.operator !== null && this[this.unit + 's'] && this[this.unit + 's'] !== null) {\n        this[this.unit + 's'] = this[this.unit + 's'] + (this.operator == 'add' ? 1 : -1) + (this.value || 0) * orient;\n      } else if (this[this.unit + 's'] == null || this.operator != null) {\n        if (!this.value) {\n          this.value = 1;\n        }\n\n        this[this.unit + 's'] = this.value * orient;\n      }\n\n      if (this.meridian && this.hour) {\n        if (this.meridian == 'p' && this.hour < 12) {\n          this.hour += 12;\n        } else if (this.meridian == 'a' && this.hour == 12) {\n          this.hour = 0;\n        }\n      }\n\n      if (this.weekday && !this.day && !this.days) {\n        var temp = Date[this.weekday]();\n        this.day = temp.getDate();\n\n        if (temp.getMonth() !== today.getMonth()) {\n          this.month = temp.getMonth();\n        }\n      }\n\n      if ((this.month || this.month === 0) && !this.day) {\n        this.day = 1;\n      }\n\n      if (!this.orient && !this.operator && this.unit == 'week' && this.value && !this.day && !this.month) {\n        return Date.today().setWeek(this.value);\n      }\n\n      if (expression && this.timezone && this.day && this.days) {\n        this.day = this.days;\n      }\n\n      return expression ? today.add(this) : today.set(this);\n    }\n\n  };\n\n  let _ = $D.Parsing.Operators,\n      g = $D.Grammar,\n      t = $D.Translator,\n      _fn;\n\n  g.datePartDelimiter = _.rtoken(/^([\\s\\-\\.\\,\\/\\x27]+)/);\n  g.timePartDelimiter = _.stoken(':');\n  g.whiteSpace = _.rtoken(/^\\s*/);\n  g.generalDelimiter = _.rtoken(/^(([\\s\\,]|at|@|on)+)/);\n  const _C = {};\n\n  g.ctoken = function (keys) {\n    let fn = _C[keys];\n\n    if (!fn) {\n      const c = $C.regexPatterns;\n      const kx = keys.split(/\\s+/),\n            px = [];\n\n      for (let i = 0; i < kx.length; i++) {\n        px.push(_.replace(_.rtoken(c[kx[i]]), kx[i]));\n      }\n\n      fn = _C[keys] = _.any.apply(null, px);\n    }\n\n    return fn;\n  };\n\n  g.ctoken2 = function (key) {\n    return _.rtoken($C.regexPatterns[key]);\n  }; // hour, minute, second, meridian, timezone\n\n\n  g.h = _.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2]|[1-9])/), t.hour));\n  g.hh = _.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2])/), t.hour));\n  g.H = _.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3]|[0-9])/), t.hour));\n  g.HH = _.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3])/), t.hour));\n  g.m = _.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/), t.minute));\n  g.mm = _.cache(_.process(_.rtoken(/^[0-5][0-9]/), t.minute));\n  g.s = _.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/), t.second));\n  g.ss = _.cache(_.process(_.rtoken(/^[0-5][0-9]/), t.second));\n  g.hms = _.cache(_.sequence([g.H, g.m, g.s], g.timePartDelimiter)); // _.min(1, _.set([ g.H, g.m, g.s ], g._t));\n\n  g.t = _.cache(_.process(g.ctoken2('shortMeridian'), t.meridian));\n  g.tt = _.cache(_.process(g.ctoken2('longMeridian'), t.meridian));\n  g.z = _.cache(_.process(_.rtoken(/^((\\+|\\-)\\s*\\d\\d\\d\\d)|((\\+|\\-)\\d\\d\\:?\\d\\d)/), t.timezone));\n  g.zz = _.cache(_.process(_.rtoken(/^((\\+|\\-)\\s*\\d\\d\\d\\d)|((\\+|\\-)\\d\\d\\:?\\d\\d)/), t.timezone));\n  g.zzz = _.cache(_.process(g.ctoken2('timezone'), t.timezone));\n  g.Z = _.cache(_.process(_.stoken('Z'), t.timezone));\n  g.timeSuffix = _.each(_.ignore(g.whiteSpace), _.set([g.tt, g.zzz]));\n  g.time = _.each(_.optional(_.ignore(_.stoken('T'))), g.hms, g.timeSuffix); // days, months, years\n\n  g.d = _.cache(_.process(_.each(_.rtoken(/^([0-2]\\d|3[0-1]|\\d)/), _.optional(g.ctoken2('ordinalSuffix'))), t.day));\n  g.dd = _.cache(_.process(_.each(_.rtoken(/^([0-2]\\d|3[0-1])/), _.optional(g.ctoken2('ordinalSuffix'))), t.day));\n  g.ddd = g.dddd = _.cache(_.process(g.ctoken('sun mon tue wed thu fri sat'), function (s) {\n    return function () {\n      this.weekday = s;\n    };\n  }));\n  g.M = _.cache(_.process(_.rtoken(/^(1[0-2]|0\\d|\\d)/), t.month));\n  g.MM = _.cache(_.process(_.rtoken(/^(1[0-2]|0\\d)/), t.month));\n  g.MMM = g.MMMM = _.cache(_.process(g.ctoken('jan feb mar apr may jun jul aug sep oct nov dec'), t.month));\n  g.y = _.cache(_.process(_.rtoken(/^(\\d\\d?)/), t.year));\n  g.yy = _.cache(_.process(_.rtoken(/^(\\d\\d)/), t.year));\n  g.yyy = _.cache(_.process(_.rtoken(/^(\\d\\d?\\d?\\d?)/), t.year));\n  g.yyyy = _.cache(_.process(_.rtoken(/^(\\d\\d\\d\\d)/), t.year)); // rolling these up into general purpose rules\n\n  _fn = function () {\n    return _.each(_.any.apply(null, arguments), _.not(g.ctoken2('timeContext')));\n  };\n\n  g.day = _fn(g.d, g.dd);\n  g.month = _fn(g.M, g.MMM);\n  g.year = _fn(g.yyyy, g.yy); // relative date / time expressions\n\n  g.orientation = _.process(g.ctoken('past future'), function (s) {\n    return function () {\n      this.orient = s;\n    };\n  });\n  g.operator = _.process(g.ctoken('add subtract'), function (s) {\n    return function () {\n      this.operator = s;\n    };\n  });\n  g.rday = _.process(g.ctoken('yesterday tomorrow today now'), t.rday);\n  g.unit = _.process(g.ctoken('second minute hour day week month year'), function (s) {\n    return function () {\n      this.unit = s;\n    };\n  });\n  g.value = _.process(_.rtoken(/^\\d\\d?(st|nd|rd|th)?/), function (s) {\n    return function () {\n      this.value = s.replace(/\\D/g, '');\n    };\n  });\n  g.expression = _.set([g.rday, g.operator, g.value, g.unit, g.orientation, g.ddd, g.MMM]); // pre-loaded rules for different date part order preferences\n\n  _fn = function () {\n    return _.set(arguments, g.datePartDelimiter);\n  };\n\n  g.mdy = _fn(g.ddd, g.month, g.day, g.year);\n  g.ymd = _fn(g.ddd, g.year, g.month, g.day);\n  g.dmy = _fn(g.ddd, g.day, g.month, g.year);\n\n  g.date = function (s) {\n    return (g[$C.dateElementOrder] || g.mdy).call(this, s);\n  }; // parsing date format specifiers - ex: \"h:m:s tt\"\n  // this little guy will generate a custom parser based\n  // on the format string, ex: g.format(\"h:m:s tt\")\n\n\n  g.format = _.process(_.many(_.any( // translate format specifiers into grammar rules\n  _.process(_.rtoken(/^(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?|Z)/), function (fmt) {\n    if (g[fmt]) {\n      return g[fmt];\n    } else {\n      throw $D.Parsing.Exception(fmt);\n    }\n  }), // translate separator tokens into token rules\n  _.process(_.rtoken(/^[^dMyhHmstzZ]+/), // all legal separators\n  function (s) {\n    return _.ignore(_.stoken(s));\n  }))), // construct the parser ...\n  function (rules) {\n    return _.process(_.each.apply(null, rules), t.finishExact);\n  });\n  const _F = {// \"M/d/yyyy\": function (s) {\n    //\tvar m = s.match(/^([0-2]\\d|3[0-1]|\\d)\\/(1[0-2]|0\\d|\\d)\\/(\\d\\d\\d\\d)/);\n    //\tif (m!=null) {\n    //\t\tvar r =  [ t.month.call(this,m[1]), t.day.call(this,m[2]), t.year.call(this,m[3]) ];\n    //\t\tr = t.finishExact.call(this,r);\n    //\t\treturn [ r, \"\" ];\n    //\t} else {\n    //\t\tthrow new Date.Parsing.Exception(s);\n    //\t}\n    // }\n    // \"M/d/yyyy\": function (s) { return [ new Date(Date._parse(s)), \"\"]; }\n  };\n\n  const _get = function (f) {\n    return _F[f] = _F[f] || g.format(f)[0];\n  };\n\n  g.formats = function (fx) {\n    if (fx instanceof Array) {\n      const rx = [];\n\n      for (let i = 0; i < fx.length; i++) {\n        rx.push(_get(fx[i]));\n      }\n\n      return _.any.apply(null, rx);\n    } else {\n      return _get(fx);\n    }\n  }; // check for these formats first\n\n\n  g._formats = g.formats(['\"yyyy-MM-ddTHH:mm:ssZ\"', 'yyyy-MM-ddTHH:mm:ssZ', 'yyyy-MM-ddTHH:mm:ssz', 'yyyy-MM-ddTHH:mm:ss', 'yyyy-MM-ddTHH:mmZ', 'yyyy-MM-ddTHH:mmz', 'yyyy-MM-ddTHH:mm', 'ddd, MMM dd, yyyy H:mm:ss tt', 'ddd MMM d yyyy HH:mm:ss zzz', 'MMddyyyy', 'ddMMyyyy', 'Mddyyyy', 'ddMyyyy', 'Mdyyyy', 'dMyyyy', 'yyyy', 'Mdyy', 'dMyy', 'd']); // starting rule for general purpose grammar\n\n  g._start = _.process(_.set([g.date, g.time, g.expression], g.generalDelimiter, g.whiteSpace), t.finish); // real starting rule: tries selected formats first,\n  // then general purpose rule\n\n  g.start = function (s) {\n    try {\n      const r = g._formats.call({}, s);\n\n      if (r[1].length === 0) {\n        return r;\n      }\n    } catch (e) {}\n\n    return g._start.call({}, s);\n  };\n\n  $D._parse = $D.parse;\n  /**\n     * Converts the specified string value into its JavaScript Date equivalent using CultureInfo specific format information.\n     *\n     * Example\n    <pre><code>\n    ///////////\n    // Dates //\n    ///////////\n     // 15-Oct-2004\n    var d1 = Date.parse(\"10/15/2004\");\n     // 15-Oct-2004\n    var d1 = Date.parse(\"15-Oct-2004\");\n     // 15-Oct-2004\n    var d1 = Date.parse(\"2004.10.15\");\n     //Fri Oct 15, 2004\n    var d1 = Date.parse(\"Fri Oct 15, 2004\");\n     ///////////\n    // Times //\n    ///////////\n     // Today at 10 PM.\n    var d1 = Date.parse(\"10 PM\");\n     // Today at 10:30 PM.\n    var d1 = Date.parse(\"10:30 P.M.\");\n     // Today at 6 AM.\n    var d1 = Date.parse(\"06am\");\n     /////////////////////\n    // Dates and Times //\n    /////////////////////\n     // 8-July-2004 @ 10:30 PM\n    var d1 = Date.parse(\"July 8th, 2004, 10:30 PM\");\n     // 1-July-2004 @ 10:30 PM\n    var d1 = Date.parse(\"2004-07-01T22:30:00\");\n     ////////////////////\n    // Relative Dates //\n    ////////////////////\n     // Returns today's date. The string \"today\" is culture specific.\n    var d1 = Date.parse(\"today\");\n     // Returns yesterday's date. The string \"yesterday\" is culture specific.\n    var d1 = Date.parse(\"yesterday\");\n     // Returns the date of the next thursday.\n    var d1 = Date.parse(\"Next thursday\");\n     // Returns the date of the most previous monday.\n    var d1 = Date.parse(\"last monday\");\n     // Returns today's day + one year.\n    var d1 = Date.parse(\"next year\");\n     ///////////////\n    // Date Math //\n    ///////////////\n     // Today + 2 days\n    var d1 = Date.parse(\"t+2\");\n     // Today + 2 days\n    var d1 = Date.parse(\"today + 2 days\");\n     // Today + 3 months\n    var d1 = Date.parse(\"t+3m\");\n     // Today - 1 year\n    var d1 = Date.parse(\"today - 1 year\");\n     // Today - 1 year\n    var d1 = Date.parse(\"t-1y\");\n      /////////////////////////////\n    // Partial Dates and Times //\n    /////////////////////////////\n     // July 15th of this year.\n    var d1 = Date.parse(\"July 15\");\n     // 15th day of current day and year.\n    var d1 = Date.parse(\"15\");\n     // July 1st of current year at 10pm.\n    var d1 = Date.parse(\"7/1 10pm\");\n    </code></pre>\n     *\n     * @param {String}   The string value to convert into a Date object [Required]\n     * @return {Date}    A Date object or null if the string cannot be converted into a Date.\n     */\n\n  $D.parse = function (s) {\n    let r = null;\n\n    if (!s) {\n      return null;\n    }\n\n    if (s instanceof Date) {\n      return s;\n    }\n\n    try {\n      r = $D.Grammar.start.call({}, s.replace(/^\\s*(\\S*(\\s+\\S+)*)\\s*$/, '$1'));\n    } catch (e) {\n      return null;\n    }\n\n    return r[1].length === 0 ? r[0] : null;\n  };\n\n  $D.getParseFunction = function (fx) {\n    const fn = $D.Grammar.formats(fx);\n    return function (s) {\n      let r = null;\n\n      try {\n        r = fn.call({}, s);\n      } catch (e) {\n        return null;\n      }\n\n      return r[1].length === 0 ? r[0] : null;\n    };\n  };\n  /**\n     * Converts the specified string value into its JavaScript Date equivalent using the specified format {String} or formats {Array} and the CultureInfo specific format information.\n     * The format of the string value must match one of the supplied formats exactly.\n     *\n     * Example\n    <pre><code>\n    // 15-Oct-2004\n    var d1 = Date.parseExact(\"10/15/2004\", \"M/d/yyyy\");\n     // 15-Oct-2004\n    var d1 = Date.parse(\"15-Oct-2004\", \"M-ddd-yyyy\");\n     // 15-Oct-2004\n    var d1 = Date.parse(\"2004.10.15\", \"yyyy.MM.dd\");\n     // Multiple formats\n    var d1 = Date.parseExact(\"10/15/2004\", [\"M/d/yyyy\", \"MMMM d, yyyy\"]);\n    </code></pre>\n     *\n     * @param {String}   The string value to convert into a Date object [Required].\n     * @param {Object}   The expected format {String} or an array of expected formats {Array} of the date string [Required].\n     * @return {Date}    A Date object or null if the string cannot be converted into a Date.\n     */\n\n\n  $D.parseExact = function (s, fx) {\n    return $D.getParseFunction(fx)(s);\n  };\n})();\n\n//# sourceURL=webpack:///./packages/canvas-rce/es/canvasFileBrowser/parser.js?");

/***/ }),

/***/ "YveN":
/*!**************************************************************!*\
  !*** ./packages/canvas-rce/es/canvasFileBrowser/sugarpak.js ***!
  \**************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"k6nP\");\n/**\n * @version: 1.0 Alpha-1\n * @author: Coolite Inc. http://www.coolite.com/\n * @date: 2008-04-13\n * @copyright: Copyright (c) 2006-2008, Coolite Inc. (http://www.coolite.com/). All rights reserved.\n * @license: Licensed under The MIT License. See license.txt and http://www.datejs.com/license/.\n * @website: http://www.datejs.com/\n */\n\n/**\n **************************************************************\n ** SugarPak - Domain Specific Language -  Syntactical Sugar **\n **************************************************************\n */\n\n\n(function () {\n  const $D = Date,\n        $P = $D.prototype,\n        $C = $D.CultureInfo,\n        $N = Number.prototype; // private\n\n  $P._orient = 1; // private\n\n  $P._nth = null; // private\n\n  $P._is = false; // private\n\n  $P._same = false; // private\n\n  $P._isSecond = false; // private\n\n  $N._dateElement = 'day';\n  /**\n     * Moves the date to the next instance of a date as specified by the subsequent date element function (eg. .day(), .month()), month name function (eg. .january(), .jan()) or day name function (eg. .friday(), fri()).\n     * Example\n    <pre><code>\n    Date.today().next().friday();\n    Date.today().next().fri();\n    Date.today().next().march();\n    Date.today().next().mar();\n    Date.today().next().week();\n    </code></pre>\n     *\n     * @return {Date}    date\n     */\n\n  $P.next = function () {\n    this._orient = 1;\n    return this;\n  };\n  /**\n     * Creates a new Date (Date.today()) and moves the date to the next instance of the date as specified by the subsequent date element function (eg. .day(), .month()), month name function (eg. .january(), .jan()) or day name function (eg. .friday(), fri()).\n     * Example\n    <pre><code>\n    Date.next().friday();\n    Date.next().fri();\n    Date.next().march();\n    Date.next().mar();\n    Date.next().week();\n    </code></pre>\n     *\n     * @return {Date}    date\n     */\n\n\n  $D.next = function () {\n    return $D.today().next();\n  };\n  /**\n     * Moves the date to the previous instance of a date as specified by the subsequent date element function (eg. .day(), .month()), month name function (eg. .january(), .jan()) or day name function (eg. .friday(), fri()).\n     * Example\n    <pre><code>\n    Date.today().last().friday();\n    Date.today().last().fri();\n    Date.today().last().march();\n    Date.today().last().mar();\n    Date.today().last().week();\n    </code></pre>\n     *\n     * @return {Date}    date\n     */\n\n\n  $P.last = $P.prev = $P.previous = function () {\n    this._orient = -1;\n    return this;\n  };\n  /**\n     * Creates a new Date (Date.today()) and moves the date to the previous instance of the date as specified by the subsequent date element function (eg. .day(), .month()), month name function (eg. .january(), .jan()) or day name function (eg. .friday(), fri()).\n     * Example\n    <pre><code>\n    Date.last().friday();\n    Date.last().fri();\n    Date.previous().march();\n    Date.prev().mar();\n    Date.last().week();\n    </code></pre>\n     *\n     * @return {Date}    date\n     */\n\n\n  $D.last = $D.prev = $D.previous = function () {\n    return $D.today().last();\n  };\n  /**\n     * Performs a equality check when followed by either a month name, day name or .weekday() function.\n     * Example\n    <pre><code>\n    Date.today().is().friday(); // true|false\n    Date.today().is().fri();\n    Date.today().is().march();\n    Date.today().is().mar();\n    </code></pre>\n     *\n     * @return {Boolean}    true|false\n     */\n\n\n  $P.is = function () {\n    this._is = true;\n    return this;\n  };\n  /**\n     * Determines if two date objects occur on/in exactly the same instance of the subsequent date part function.\n     * The function .same() must be followed by a date part function (example: .day(), .month(), .year(), etc).\n     *\n     * An optional Date can be passed in the date part function. If now date is passed as a parameter, 'Now' is used.\n     *\n     * The following example demonstrates how to determine if two dates fall on the exact same day.\n     *\n     * Example\n    <pre><code>\n    var d1 = Date.today(); // today at 00:00\n    var d2 = new Date();   // exactly now.\n     // Do they occur on the same day?\n    d1.same().day(d2); // true\n      // Do they occur on the same hour?\n    d1.same().hour(d2); // false, unless d2 hour is '00' (midnight).\n     // What if it's the same day, but one year apart?\n    var nextYear = Date.today().add(1).year();\n     d1.same().day(nextYear); // false, because the dates must occur on the exact same day.\n    </code></pre>\n     *\n     * Scenario: Determine if a given date occurs during some week period 2 months from now.\n     *\n     * Example\n    <pre><code>\n    var future = Date.today().add(2).months();\n    return someDate.same().week(future); // true|false;\n    </code></pre>\n     *\n     * @return {Boolean}    true|false\n     */\n\n\n  $P.same = function () {\n    this._same = true;\n    this._isSecond = false;\n    return this;\n  };\n  /**\n     * Determines if the current date/time occurs during Today. Must be preceded by the .is() function.\n     * Example\n    <pre><code>\n    someDate.is().today();    // true|false\n    new Date().is().today();  // true\n    Date.today().is().today();// true\n    Date.today().add(-1).day().is().today(); // false\n    </code></pre>\n     *\n     * @return {Boolean}    true|false\n     */\n\n\n  $P.today = function () {\n    return this.same().day();\n  };\n  /**\n     * Determines if the current date is a weekday. This function must be preceded by the .is() function.\n     * Example\n    <pre><code>\n    Date.today().is().weekday(); // true|false\n    </code></pre>\n     *\n     * @return {Boolean}    true|false\n     */\n\n\n  $P.weekday = function () {\n    if (this._is) {\n      this._is = false;\n      return !this.is().sat() && !this.is().sun();\n    }\n\n    return false;\n  };\n  /**\n     * Sets the Time of the current Date instance. A string \"6:15 pm\" or config object {hour:18, minute:15} are accepted.\n     * Example\n    <pre><code>\n    // Set time to 6:15pm with a String\n    Date.today().at(\"6:15pm\");\n     // Set time to 6:15pm with a config object\n    Date.today().at({hour:18, minute:15});\n    </code></pre>\n     *\n     * @return {Date}    date\n     */\n\n\n  $P.at = function (time) {\n    return typeof time === 'string' ? $D.parse(this.toString('d') + ' ' + time) : this.set(time);\n  };\n  /**\n     * Creates a new Date() and adds this (Number) to the date based on the preceding date element function (eg. second|minute|hour|day|month|year).\n     * Example\n    <pre><code>\n    // Undeclared Numbers must be wrapped with parentheses. Requirment of JavaScript.\n    (3).days().fromNow();\n    (6).months().fromNow();\n     // Declared Number variables do not require parentheses.\n    var n = 6;\n    n.months().fromNow();\n    </code></pre>\n     *\n     * @return {Date}    A new Date instance\n     */\n\n\n  $N.fromNow = $N.after = function (date) {\n    const c = {};\n    c[this._dateElement] = this;\n    return (!date ? new Date() : date.clone()).add(c);\n  };\n  /**\n     * Creates a new Date() and subtract this (Number) from the date based on the preceding date element function (eg. second|minute|hour|day|month|year).\n     * Example\n    <pre><code>\n    // Undeclared Numbers must be wrapped with parentheses. Requirment of JavaScript.\n    (3).days().ago();\n    (6).months().ago();\n     // Declared Number variables do not require parentheses.\n    var n = 6;\n    n.months().ago();\n    </code></pre>\n     *\n     * @return {Date}    A new Date instance\n     */\n\n\n  $N.ago = $N.before = function (date) {\n    const c = {};\n    c[this._dateElement] = this * -1;\n    return (!date ? new Date() : date.clone()).add(c);\n  }; // Do NOT modify the following string tokens. These tokens are used to build dynamic functions.\n  // All culture-specific strings can be found in the CultureInfo files. See /trunk/src/globalization/.\n\n\n  let dx = 'sunday monday tuesday wednesday thursday friday saturday'.split(/\\s/),\n      mx = 'january february march april may june july august september october november december'.split(/\\s/),\n      px = 'Millisecond Second Minute Hour Day Week Month Year'.split(/\\s/),\n      pxf = 'Milliseconds Seconds Minutes Hours Date Week Month FullYear'.split(/\\s/),\n      nth = 'final first second third fourth fifth'.split(/\\s/),\n      de;\n  /**\n     * Returns an object literal of all the date parts.\n     * Example\n    <pre><code>\n  var o = new Date().toObject();\n  // { year: 2008, month: 4, week: 20, day: 13, hour: 18, minute: 9, second: 32, millisecond: 812 }\n  // The object properties can be referenced directly from the object.\n  alert(o.day);  // alerts \"13\"\n  alert(o.year); // alerts \"2008\"\n    </code></pre>\n     *\n     * @return {Date}    An object literal representing the original date object.\n     */\n\n  $P.toObject = function () {\n    const o = {};\n\n    for (let i = 0; i < px.length; i++) {\n      o[px[i].toLowerCase()] = this['get' + pxf[i]]();\n    }\n\n    return o;\n  };\n  /**\n     * Returns a date created from an object literal. Ignores the .week property if set in the config.\n     * Example\n    <pre><code>\n  var o = new Date().toObject();\n  return Date.fromObject(o); // will return the same date.\n     var o2 = {month: 1, day: 20, hour: 18}; // birthday party!\n    Date.fromObject(o2);\n    </code></pre>\n     *\n     * @return {Date}    An object literal representing the original date object.\n     */\n\n\n  $D.fromObject = function (config) {\n    config.week = null;\n    return Date.today().set(config);\n  }; // Create day name functions and abbreviated day name functions (eg. monday(), friday(), fri()).\n\n\n  const df = function (n) {\n    return function () {\n      if (this._is) {\n        this._is = false;\n        return this.getDay() == n;\n      }\n\n      if (this._nth !== null) {\n        // If the .second() function was called earlier, remove the _orient\n        // from the date, and then continue.\n        // This is required because 'second' can be used in two different context.\n        //\n        // Example\n        //\n        //   Date.today().add(1).second();\n        //   Date.march().second().monday();\n        //\n        // Things get crazy with the following...\n        //   Date.march().add(1).second().second().monday(); // but it works!!\n        //\n        if (this._isSecond) {\n          this.addSeconds(this._orient * -1);\n        } // make sure we reset _isSecond\n\n\n        this._isSecond = false;\n        const ntemp = this._nth;\n        this._nth = null;\n        const temp = this.clone().moveToLastDayOfMonth();\n        this.moveToNthOccurrence(n, ntemp);\n\n        if (this > temp) {\n          throw new RangeError($D.getDayName(n) + ' does not occur ' + ntemp + ' times in the month of ' + $D.getMonthName(temp.getMonth()) + ' ' + temp.getFullYear() + '.');\n        }\n\n        return this;\n      }\n\n      return this.moveToDayOfWeek(n, this._orient);\n    };\n  };\n\n  const sdf = function (n) {\n    return function () {\n      let t = $D.today(),\n          shift = n - t.getDay();\n\n      if (n === 0 && $C.firstDayOfWeek === 1 && t.getDay() !== 0) {\n        shift += 7;\n      }\n\n      return t.addDays(shift);\n    };\n  };\n\n  for (let i = 0; i < dx.length; i++) {\n    // Create constant static Day Name variables. Example: Date.MONDAY or Date.MON\n    $D[dx[i].toUpperCase()] = $D[dx[i].toUpperCase().substring(0, 3)] = i; // Create Day Name functions. Example: Date.monday() or Date.mon()\n\n    $D[dx[i]] = $D[dx[i].substring(0, 3)] = sdf(i); // Create Day Name instance functions. Example: Date.today().next().monday()\n\n    $P[dx[i]] = $P[dx[i].substring(0, 3)] = df(i);\n  } // Create month name functions and abbreviated month name functions (eg. january(), march(), mar()).\n\n\n  const mf = function (n) {\n    return function () {\n      if (this._is) {\n        this._is = false;\n        return this.getMonth() === n;\n      }\n\n      return this.moveToMonth(n, this._orient);\n    };\n  };\n\n  const smf = function (n) {\n    return function () {\n      return $D.today().set({\n        month: n,\n        day: 1\n      });\n    };\n  };\n\n  for (let j = 0; j < mx.length; j++) {\n    // Create constant static Month Name variables. Example: Date.MARCH or Date.MAR\n    $D[mx[j].toUpperCase()] = $D[mx[j].toUpperCase().substring(0, 3)] = j; // Create Month Name functions. Example: Date.march() or Date.mar()\n\n    $D[mx[j]] = $D[mx[j].substring(0, 3)] = smf(j); // Create Month Name instance functions. Example: Date.today().next().march()\n\n    $P[mx[j]] = $P[mx[j].substring(0, 3)] = mf(j);\n  } // Create date element functions and plural date element functions used with Date (eg. day(), days(), months()).\n\n\n  const ef = function (j) {\n    return function () {\n      // if the .second() function was called earlier, the _orient\n      // has alread been added. Just return this and reset _isSecond.\n      if (this._isSecond) {\n        this._isSecond = false;\n        return this;\n      }\n\n      if (this._same) {\n        this._same = this._is = false;\n        let o1 = this.toObject(),\n            o2 = (arguments[0] || new Date()).toObject(),\n            v = '',\n            k = j.toLowerCase();\n\n        for (let m = px.length - 1; m > -1; m--) {\n          v = px[m].toLowerCase();\n\n          if (o1[v] != o2[v]) {\n            return false;\n          }\n\n          if (k == v) {\n            break;\n          }\n        }\n\n        return true;\n      }\n\n      if (j.substring(j.length - 1) != 's') {\n        j += 's';\n      }\n\n      return this['add' + j](this._orient);\n    };\n  };\n\n  const nf = function (n) {\n    return function () {\n      this._dateElement = n;\n      return this;\n    };\n  };\n\n  for (let k = 0; k < px.length; k++) {\n    de = px[k].toLowerCase(); // Create date element functions and plural date element functions used with Date (eg. day(), days(), months()).\n\n    $P[de] = $P[de + 's'] = ef(px[k]); // Create date element functions and plural date element functions used with Number (eg. day(), days(), months()).\n\n    $N[de] = $N[de + 's'] = nf(de);\n  }\n\n  $P._ss = ef('Second');\n\n  const nthfn = function (n) {\n    return function (dayOfWeek) {\n      if (this._same) {\n        return this._ss(arguments[0]);\n      }\n\n      if (dayOfWeek || dayOfWeek === 0) {\n        return this.moveToNthOccurrence(dayOfWeek, n);\n      }\n\n      this._nth = n; // if the operator is 'second' add the _orient, then deal with it later...\n\n      if (n === 2 && (dayOfWeek === void 0 || dayOfWeek === null)) {\n        this._isSecond = true;\n        return this.addSeconds(this._orient);\n      }\n\n      return this;\n    };\n  };\n\n  for (let l = 0; l < nth.length; l++) {\n    $P[nth[l]] = l === 0 ? nthfn(-1) : nthfn(l);\n  }\n})();\n\n//# sourceURL=webpack:///./packages/canvas-rce/es/canvasFileBrowser/sugarpak.js?");

/***/ }),

/***/ "ew6L":
/*!***********************************************************!*\
  !*** ./packages/canvas-rce/es/canvasFileBrowser/en-US.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n * Copyright (C) 2020 - present Instructure, Inc.\n *\n * This file is part of Canvas.\n *\n * Canvas is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, version 3 of the License.\n *\n * Canvas is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU Affero General Public License for more\n * details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see <http://www.gnu.org/licenses/>.\n */\nDate.CultureInfo = {\n  /* Culture Name */\n  name: 'en-US',\n  englishName: 'English (United States)',\n  nativeName: 'English (United States)',\n\n  /* Day Name Strings */\n  dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n  abbreviatedDayNames: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n  shortestDayNames: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],\n  firstLetterDayNames: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],\n\n  /* Month Name Strings */\n  monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n  abbreviatedMonthNames: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n\n  /* AM/PM Designators */\n  amDesignator: 'AM',\n  pmDesignator: 'PM',\n  firstDayOfWeek: 0,\n  twoDigitYearMax: 2029,\n\n  /**\n     * The dateElementOrder is based on the order of the \n     * format specifiers in the formatPatterns.DatePattern. \n     *\n     * Example:\n     <pre>\n     shortDatePattern    dateElementOrder\n     ------------------  ---------------- \n     \"M/d/yyyy\"          \"mdy\"\n     \"dd/MM/yyyy\"        \"dmy\"\n     \"yyyy-MM-dd\"        \"ymd\"\n     </pre>\n     *\n     * The correct dateElementOrder is required by the parser to\n     * determine the expected order of the date elements in the\n     * string being parsed.\n     */\n  dateElementOrder: 'mdy',\n\n  /* Standard date and time format patterns */\n  formatPatterns: {\n    shortDate: 'M/d/yyyy',\n    longDate: 'dddd, MMMM dd, yyyy',\n    shortTime: 'h:mm tt',\n    longTime: 'h:mm:ss tt',\n    fullDateTime: 'dddd, MMMM dd, yyyy h:mm:ss tt',\n    sortableDateTime: 'yyyy-MM-ddTHH:mm:ss',\n    universalSortableDateTime: 'yyyy-MM-dd HH:mm:ssZ',\n    rfc1123: 'ddd, dd MMM yyyy HH:mm:ss GMT',\n    monthDay: 'MMMM dd',\n    yearMonth: 'MMMM, yyyy'\n  },\n\n  /**\n   * NOTE: If a string format is not parsing correctly, but\n   * you would expect it parse, the problem likely lies below.\n   *\n   * The following regex patterns control most of the string matching\n   * within the parser.\n   *\n   * The Month name and Day name patterns were automatically generated\n   * and in general should be (mostly) correct.\n   *\n   * Beyond the month and day name patterns are natural language strings.\n   * Example: \"next\", \"today\", \"months\"\n   *\n   * These natural language string may NOT be correct for this culture.\n   * If they are not correct, please translate and edit this file\n   * providing the correct regular expression pattern.\n   *\n   * If you modify this file, please post your revised CultureInfo file\n   * to the Datejs Forum located at http://www.datejs.com/forums/.\n   *\n   * Please mark the subject of the post with [CultureInfo]. Example:\n   *    Subject: [CultureInfo] Translated \"da-DK\" Danish(Denmark)\n   *\n   * We will add the modified patterns to the master source files.\n   *\n   * As well, please review the list of \"Future Strings\" section below.\n   */\n  regexPatterns: {\n    jan: /^jan(uary)?/i,\n    feb: /^feb(ruary)?/i,\n    mar: /^mar(ch)?/i,\n    apr: /^apr(il)?/i,\n    may: /^may/i,\n    jun: /^jun(e)?/i,\n    jul: /^jul(y)?/i,\n    aug: /^aug(ust)?/i,\n    sep: /^sep(t(ember)?)?/i,\n    oct: /^oct(ober)?/i,\n    nov: /^nov(ember)?/i,\n    dec: /^dec(ember)?/i,\n    sun: /^su(n(day)?)?/i,\n    mon: /^mo(n(day)?)?/i,\n    tue: /^tu(e(s(day)?)?)?/i,\n    wed: /^we(d(nesday)?)?/i,\n    thu: /^th(u(r(s(day)?)?)?)?/i,\n    fri: /^fr(i(day)?)?/i,\n    sat: /^sa(t(urday)?)?/i,\n    future: /^next/i,\n    past: /^last|past|prev(ious)?/i,\n    add: /^(\\+|aft(er)?|from|hence)/i,\n    subtract: /^(\\-|bef(ore)?|ago)/i,\n    yesterday: /^yes(terday)?/i,\n    today: /^t(od(ay)?)?/i,\n    tomorrow: /^tom(orrow)?/i,\n    now: /^n(ow)?/i,\n    millisecond: /^ms|milli(second)?s?/i,\n    second: /^sec(ond)?s?/i,\n    minute: /^mn|min(ute)?s?/i,\n    hour: /^h(our)?s?/i,\n    week: /^w(eek)?s?/i,\n    month: /^m(onth)?s?/i,\n    day: /^d(ay)?s?/i,\n    year: /^y(ear)?s?/i,\n    shortMeridian: /^(a|p)/i,\n    longMeridian: /^(a\\.?m?\\.?|p\\.?m?\\.?)/i,\n    timezone: /^((e(s|d)t|c(s|d)t|m(s|d)t|p(s|d)t)|((gmt)?\\s*(\\+|\\-)\\s*\\d\\d\\d\\d?)|gmt|utc)/i,\n    ordinalSuffix: /^\\s*(st|nd|rd|th)/i,\n    timeContext: /^\\s*(\\:|a(?!u|p)|p)/i\n  },\n  timezones: [{\n    name: 'UTC',\n    offset: '-000'\n  }, {\n    name: 'GMT',\n    offset: '-000'\n  }, {\n    name: 'EST',\n    offset: '-0500'\n  }, {\n    name: 'EDT',\n    offset: '-0400'\n  }, {\n    name: 'CST',\n    offset: '-0600'\n  }, {\n    name: 'CDT',\n    offset: '-0500'\n  }, {\n    name: 'MST',\n    offset: '-0700'\n  }, {\n    name: 'MDT',\n    offset: '-0600'\n  }, {\n    name: 'PST',\n    offset: '-0800'\n  }, {\n    name: 'PDT',\n    offset: '-0700'\n  }]\n};\n/** ******************\n ** Future Strings **\n ********************\n *\n * The following list of strings may not be currently being used, but\n * may be incorporated into the Datejs library later.\n *\n * We would appreciate any help translating the strings below.\n *\n * If you modify this file, please post your revised CultureInfo file\n * to the Datejs Forum located at http://www.datejs.com/forums/.\n *\n * Please mark the subject of the post with [CultureInfo]. Example:\n *    Subject: [CultureInfo] Translated \"da-DK\" Danish(Denmark)b\n *\n * English Name        Translated\n * ------------------  -----------------\n * about               about\n * ago                 ago\n * date                date\n * time                time\n * calendar            calendar\n * show                show\n * hourly              hourly\n * daily               daily\n * weekly              weekly\n * bi-weekly           bi-weekly\n * fortnight           fortnight\n * monthly             monthly\n * bi-monthly          bi-monthly\n * quarter             quarter\n * quarterly           quarterly\n * yearly              yearly\n * annual              annual\n * annually            annually\n * annum               annum\n * again               again\n * between             between\n * after               after\n * from now            from now\n * repeat              repeat\n * times               times\n * per                 per\n * min (abbrev minute) min\n * morning             morning\n * noon                noon\n * night               night\n * midnight            midnight\n * mid-night           mid-night\n * evening             evening\n * final               final\n * future              future\n * spring              spring\n * summer              summer\n * fall                fall\n * winter              winter\n * end of              end of\n * end                 end\n * long                long\n * short               short\n */\n\n//# sourceURL=webpack:///./packages/canvas-rce/es/canvasFileBrowser/en-US.js?");

/***/ }),

/***/ "k6nP":
/*!**********************************************************!*\
  !*** ./packages/canvas-rce/es/canvasFileBrowser/core.js ***!
  \**********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _en_US_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./en-US.js */ \"ew6L\");\n/* harmony import */ var _en_US_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_en_US_js__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * @version: 1.0 Alpha-1\n * @author: Coolite Inc. http://www.coolite.com/\n * @date: 2008-04-13\n * @copyright: Copyright (c) 2006-2008, Coolite Inc. (http://www.coolite.com/). All rights reserved.\n * @license: Licensed under The MIT License. See license.txt and http://www.datejs.com/license/.\n * @website: http://www.datejs.com/\n */\n\n\n(function () {\n  const _originalDateDotPrototypeDotToString = Date.prototype.toString;\n\n  const $D = Date,\n        $P = $D.prototype,\n        $C = $D.CultureInfo,\n        p = function (s, l) {\n    if (!l) {\n      l = 2;\n    }\n\n    return ('000' + s).slice(l * -1);\n  };\n  /**\n   * Resets the time of this Date object to 12:00 AM (00:00), which is the start of the day.\n   * @param {Boolean}  .clone() this date instance before clearing Time\n   * @return {Date}    this\n   */\n\n\n  $P.clearTime = function () {\n    this.setHours(0);\n    this.setMinutes(0);\n    this.setSeconds(0);\n    this.setMilliseconds(0);\n    return this;\n  };\n  /**\n   * Resets the time of this Date object to the current time ('now').\n   * @return {Date}    this\n   */\n\n\n  $P.setTimeToNow = function () {\n    const n = new Date();\n    this.setHours(n.getHours());\n    this.setMinutes(n.getMinutes());\n    this.setSeconds(n.getSeconds());\n    this.setMilliseconds(n.getMilliseconds());\n    return this;\n  };\n  /**\n   * Gets a date that is set to the current date. The time is set to the start of the day (00:00 or 12:00 AM).\n   * @return {Date}    The current date.\n   */\n\n\n  $D.today = function () {\n    return new Date().clearTime();\n  };\n  /**\n   * Compares the first date to the second date and returns an number indication of their relative values.\n   * @param {Date}     First Date object to compare [Required].\n   * @param {Date}     Second Date object to compare to [Required].\n   * @return {Number}  -1 = date1 is lessthan date2. 0 = values are equal. 1 = date1 is greaterthan date2.\n   */\n\n\n  $D.compare = function (date1, date2) {\n    if (isNaN(date1) || isNaN(date2)) {\n      throw new Error(date1 + ' - ' + date2);\n    } else if (date1 instanceof Date && date2 instanceof Date) {\n      return date1 < date2 ? -1 : date1 > date2 ? 1 : 0;\n    } else {\n      throw new TypeError(date1 + ' - ' + date2);\n    }\n  };\n  /**\n   * Compares the first Date object to the second Date object and returns true if they are equal.\n   * @param {Date}     First Date object to compare [Required]\n   * @param {Date}     Second Date object to compare to [Required]\n   * @return {Boolean} true if dates are equal. false if they are not equal.\n   */\n\n\n  $D.equals = function (date1, date2) {\n    return date1.compareTo(date2) === 0;\n  };\n  /**\n   * Gets the day number (0-6) if given a CultureInfo specific string which is a valid dayName, abbreviatedDayName or shortestDayName (two char).\n   * @param {String}   The name of the day (eg. \"Monday, \"Mon\", \"tuesday\", \"tue\", \"We\", \"we\").\n   * @return {Number}  The day number\n   */\n\n\n  $D.getDayNumberFromName = function (name) {\n    const n = $C.dayNames,\n          m = $C.abbreviatedDayNames,\n          o = $C.shortestDayNames,\n          s = name.toLowerCase();\n\n    for (let i = 0; i < n.length; i++) {\n      if (n[i].toLowerCase() == s || m[i].toLowerCase() == s || o[i].toLowerCase() == s) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Gets the month number (0-11) if given a Culture Info specific string which is a valid monthName or abbreviatedMonthName.\n   * @param {String}   The name of the month (eg. \"February, \"Feb\", \"october\", \"oct\").\n   * @return {Number}  The day number\n   */\n\n\n  $D.getMonthNumberFromName = function (name) {\n    const n = $C.monthNames,\n          m = $C.abbreviatedMonthNames,\n          s = name.toLowerCase();\n\n    for (let i = 0; i < n.length; i++) {\n      if (n[i].toLowerCase() == s || m[i].toLowerCase() == s) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Determines if the current date instance is within a LeapYear.\n   * @param {Number}   The year.\n   * @return {Boolean} true if date is within a LeapYear, otherwise false.\n   */\n\n\n  $D.isLeapYear = function (year) {\n    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n  };\n  /**\n   * Gets the number of days in the month, given a year and month value. Automatically corrects for LeapYear.\n   * @param {Number}   The year.\n   * @param {Number}   The month (0-11).\n   * @return {Number}  The number of days in the month.\n   */\n\n\n  $D.getDaysInMonth = function (year, month) {\n    return [31, $D.isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];\n  };\n\n  $D.getTimezoneAbbreviation = function (offset) {\n    let z = $C.timezones;\n\n    for (let i = 0; i < z.length; i++) {\n      if (z[i].offset === offset) {\n        return z[i].name;\n      }\n    }\n\n    return null;\n  };\n\n  $D.getTimezoneOffset = function (name) {\n    let z = $C.timezones;\n\n    for (let i = 0; i < z.length; i++) {\n      if (z[i].name === name.toUpperCase()) {\n        return z[i].offset;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Returns a new Date object that is an exact date and time copy of the original instance.\n   * @return {Date}    A new Date instance\n   */\n\n\n  $P.clone = function () {\n    return new Date(this.getTime());\n  };\n  /**\n   * Compares this instance to a Date object and returns an number indication of their relative values.\n   * @param {Date}     Date object to compare [Required]\n   * @return {Number}  -1 = this is lessthan date. 0 = values are equal. 1 = this is greaterthan date.\n   */\n\n\n  $P.compareTo = function (date) {\n    return Date.compare(this, date);\n  };\n  /**\n   * Compares this instance to another Date object and returns true if they are equal.\n   * @param {Date}     Date object to compare. If no date to compare, new Date() [now] is used.\n   * @return {Boolean} true if dates are equal. false if they are not equal.\n   */\n\n\n  $P.equals = function (date) {\n    return Date.equals(this, date || new Date());\n  };\n  /**\n   * Determines if this instance is between a range of two dates or equal to either the start or end dates.\n   * @param {Date}     Start of range [Required]\n   * @param {Date}     End of range [Required]\n   * @return {Boolean} true is this is between or equal to the start and end dates, else false\n   */\n\n\n  $P.between = function (start, end) {\n    return this.getTime() >= start.getTime() && this.getTime() <= end.getTime();\n  };\n  /**\n   * Determines if this date occurs after the date to compare to.\n   * @param {Date}     Date object to compare. If no date to compare, new Date() (\"now\") is used.\n   * @return {Boolean} true if this date instance is greater than the date to compare to (or \"now\"), otherwise false.\n   */\n\n\n  $P.isAfter = function (date) {\n    return this.compareTo(date || new Date()) === 1;\n  };\n  /**\n   * Determines if this date occurs before the date to compare to.\n   * @param {Date}     Date object to compare. If no date to compare, new Date() (\"now\") is used.\n   * @return {Boolean} true if this date instance is less than the date to compare to (or \"now\").\n   */\n\n\n  $P.isBefore = function (date) {\n    return this.compareTo(date || new Date()) === -1;\n  };\n  /**\n   * Determines if the current Date instance occurs today.\n   * @return {Boolean} true if this date instance is 'today', otherwise false.\n   */\n\n  /**\n   * Determines if the current Date instance occurs on the same Date as the supplied 'date'.\n   * If no 'date' to compare to is provided, the current Date instance is compared to 'today'.\n   * @param {date}     Date object to compare. If no date to compare, the current Date (\"now\") is used.\n   * @return {Boolean} true if this Date instance occurs on the same Day as the supplied 'date'.\n   */\n\n\n  $P.isToday = $P.isSameDay = function (date) {\n    return this.clone().clearTime().equals((date || new Date()).clone().clearTime());\n  };\n  /**\n   * Adds the specified number of milliseconds to this instance.\n   * @param {Number}   The number of milliseconds to add. The number can be positive or negative [Required]\n   * @return {Date}    this\n   */\n\n\n  $P.addMilliseconds = function (value) {\n    this.setUTCMilliseconds(this.getUTCMilliseconds() + value * 1);\n    return this;\n  };\n  /**\n   * Adds the specified number of seconds to this instance.\n   * @param {Number}   The number of seconds to add. The number can be positive or negative [Required]\n   * @return {Date}    this\n   */\n\n\n  $P.addSeconds = function (value) {\n    return this.addMilliseconds(value * 1000);\n  };\n  /**\n   * Adds the specified number of seconds to this instance.\n   * @param {Number}   The number of seconds to add. The number can be positive or negative [Required]\n   * @return {Date}    this\n   */\n\n\n  $P.addMinutes = function (value) {\n    return this.addMilliseconds(value * 60000);\n    /* 60*1000 */\n  };\n  /**\n   * Adds the specified number of hours to this instance.\n   * @param {Number}   The number of hours to add. The number can be positive or negative [Required]\n   * @return {Date}    this\n   */\n\n\n  $P.addHours = function (value) {\n    return this.addMilliseconds(value * 3600000);\n    /* 60*60*1000 */\n  };\n  /**\n   * Adds the specified number of days to this instance.\n   * @param {Number}   The number of days to add. The number can be positive or negative [Required]\n   * @return {Date}    this\n   */\n\n\n  $P.addDays = function (value) {\n    this.setDate(this.getDate() + value * 1);\n    return this;\n  };\n  /**\n   * Adds the specified number of weeks to this instance.\n   * @param {Number}   The number of weeks to add. The number can be positive or negative [Required]\n   * @return {Date}    this\n   */\n\n\n  $P.addWeeks = function (value) {\n    return this.addDays(value * 7);\n  };\n  /**\n   * Adds the specified number of months to this instance.\n   * @param {Number}   The number of months to add. The number can be positive or negative [Required]\n   * @return {Date}    this\n   */\n\n\n  $P.addMonths = function (value) {\n    const n = this.getDate();\n    this.setDate(1);\n    this.setMonth(this.getMonth() + value * 1);\n    this.setDate(Math.min(n, $D.getDaysInMonth(this.getFullYear(), this.getMonth())));\n    return this;\n  };\n  /**\n   * Adds the specified number of years to this instance.\n   * @param {Number}   The number of years to add. The number can be positive or negative [Required]\n   * @return {Date}    this\n   */\n\n\n  $P.addYears = function (value) {\n    return this.addMonths(value * 12);\n  };\n  /**\n     * Adds (or subtracts) to the value of the years, months, weeks, days, hours, minutes, seconds, milliseconds of the date instance using given configuration object. Positive and Negative values allowed.\n     * Example\n    <pre><code>\n    Date.today().add( { days: 1, months: 1 } )\n     new Date().add( { years: -1 } )\n    </code></pre>\n     * @param {Object}   Configuration object containing attributes (months, days, etc.)\n     * @return {Date}    this\n     */\n\n\n  $P.add = function (config) {\n    if (typeof config === 'number') {\n      this._orient = config;\n      return this;\n    }\n\n    const x = config;\n\n    if (x.milliseconds) {\n      this.addMilliseconds(x.milliseconds);\n    }\n\n    if (x.seconds) {\n      this.addSeconds(x.seconds);\n    }\n\n    if (x.minutes) {\n      this.addMinutes(x.minutes);\n    }\n\n    if (x.hours) {\n      this.addHours(x.hours);\n    }\n\n    if (x.weeks) {\n      this.addWeeks(x.weeks);\n    }\n\n    if (x.months) {\n      this.addMonths(x.months);\n    }\n\n    if (x.years) {\n      this.addYears(x.years);\n    }\n\n    if (x.days) {\n      this.addDays(x.days);\n    }\n\n    return this;\n  };\n\n  let $y, $m, $d;\n  /**\n   * Get the week number. Week one (1) is the week which contains the first Thursday of the year. Monday is considered the first day of the week.\n   * This algorithm is a JavaScript port of the work presented by Claus Tøndering at http://www.tondering.dk/claus/cal/node8.html#SECTION00880000000000000000\n   * .getWeek() Algorithm Copyright (c) 2008 Claus Tondering.\n   * The .getWeek() function does NOT convert the date to UTC. The local datetime is used. Please use .getISOWeek() to get the week of the UTC converted date.\n   * @return {Number}  1 to 53\n   */\n\n  $P.getWeek = function () {\n    let a, b, c, d, e, f, g, n, s, w;\n    $y = !$y ? this.getFullYear() : $y;\n    $m = !$m ? this.getMonth() + 1 : $m;\n    $d = !$d ? this.getDate() : $d;\n\n    if ($m <= 2) {\n      a = $y - 1;\n      b = (a / 4 | 0) - (a / 100 | 0) + (a / 400 | 0);\n      c = ((a - 1) / 4 | 0) - ((a - 1) / 100 | 0) + ((a - 1) / 400 | 0);\n      s = b - c;\n      e = 0;\n      f = $d - 1 + 31 * ($m - 1);\n    } else {\n      a = $y;\n      b = (a / 4 | 0) - (a / 100 | 0) + (a / 400 | 0);\n      c = ((a - 1) / 4 | 0) - ((a - 1) / 100 | 0) + ((a - 1) / 400 | 0);\n      s = b - c;\n      e = s + 1;\n      f = $d + (153 * ($m - 3) + 2) / 5 + 58 + s;\n    }\n\n    g = (a + b) % 7;\n    d = (f + g - e) % 7;\n    n = f + 3 - d | 0;\n\n    if (n < 0) {\n      w = 53 - ((g - s) / 5 | 0);\n    } else if (n > 364 + s) {\n      w = 1;\n    } else {\n      w = (n / 7 | 0) + 1;\n    }\n\n    $y = $m = $d = null;\n    return w;\n  };\n  /**\n   * Get the ISO 8601 week number. Week one (\"01\") is the week which contains the first Thursday of the year. Monday is considered the first day of the week.\n   * The .getISOWeek() function does convert the date to it's UTC value. Please use .getWeek() to get the week of the local date.\n   * @return {String}  \"01\" to \"53\"\n   */\n\n\n  $P.getISOWeek = function () {\n    $y = this.getUTCFullYear();\n    $m = this.getUTCMonth() + 1;\n    $d = this.getUTCDate();\n    return p(this.getWeek());\n  };\n  /**\n   * Moves the date to Monday of the week set. Week one (1) is the week which contains the first Thursday of the year.\n   * @param {Number}   A Number (1 to 53) that represents the week of the year.\n   * @return {Date}    this\n   */\n\n\n  $P.setWeek = function (n) {\n    return this.moveToDayOfWeek(1).addWeeks(n - this.getWeek());\n  }; // private\n\n\n  const validate = function (n, min, max, name) {\n    if (typeof n === 'undefined') {\n      return false;\n    } else if (typeof n !== 'number') {\n      throw new TypeError(n + ' is not a Number.');\n    } else if (n < min || n > max) {\n      throw new RangeError(n + ' is not a valid value for ' + name + '.');\n    }\n\n    return true;\n  };\n  /**\n   * Validates the number is within an acceptable range for milliseconds [0-999].\n   * @param {Number}   The number to check if within range.\n   * @return {Boolean} true if within range, otherwise false.\n   */\n\n\n  $D.validateMillisecond = function (value) {\n    return validate(value, 0, 999, 'millisecond');\n  };\n  /**\n   * Validates the number is within an acceptable range for seconds [0-59].\n   * @param {Number}   The number to check if within range.\n   * @return {Boolean} true if within range, otherwise false.\n   */\n\n\n  $D.validateSecond = function (value) {\n    return validate(value, 0, 59, 'second');\n  };\n  /**\n   * Validates the number is within an acceptable range for minutes [0-59].\n   * @param {Number}   The number to check if within range.\n   * @return {Boolean} true if within range, otherwise false.\n   */\n\n\n  $D.validateMinute = function (value) {\n    return validate(value, 0, 59, 'minute');\n  };\n  /**\n   * Validates the number is within an acceptable range for hours [0-23].\n   * @param {Number}   The number to check if within range.\n   * @return {Boolean} true if within range, otherwise false.\n   */\n\n\n  $D.validateHour = function (value) {\n    return validate(value, 0, 23, 'hour');\n  };\n  /**\n   * Validates the number is within an acceptable range for the days in a month [0-MaxDaysInMonth].\n   * @param {Number}   The number to check if within range.\n   * @return {Boolean} true if within range, otherwise false.\n   */\n\n\n  $D.validateDay = function (value, year, month) {\n    return validate(value, 1, $D.getDaysInMonth(year, month), 'day');\n  };\n  /**\n   * Validates the number is within an acceptable range for months [0-11].\n   * @param {Number}   The number to check if within range.\n   * @return {Boolean} true if within range, otherwise false.\n   */\n\n\n  $D.validateMonth = function (value) {\n    return validate(value, 0, 11, 'month');\n  };\n  /**\n   * Validates the number is within an acceptable range for years.\n   * @param {Number}   The number to check if within range.\n   * @return {Boolean} true if within range, otherwise false.\n   */\n\n\n  $D.validateYear = function (value) {\n    return validate(value, 0, 9999, 'year');\n  };\n  /**\n     * Set the value of year, month, day, hour, minute, second, millisecond of date instance using given configuration object.\n     * Example\n    <pre><code>\n    Date.today().set( { day: 20, month: 1 } )\n     new Date().set( { millisecond: 0 } )\n    </code></pre>\n     *\n     * @param {Object}   Configuration object containing attributes (month, day, etc.)\n     * @return {Date}    this\n     */\n\n\n  $P.set = function (config) {\n    if ($D.validateMillisecond(config.millisecond)) {\n      this.setMilliseconds(config.millisecond);\n    }\n\n    if ($D.validateSecond(config.second)) {\n      this.setSeconds(config.second);\n    }\n\n    if ($D.validateMinute(config.minute)) {\n      this.setMinutes(config.minute);\n    }\n\n    if ($D.validateHour(config.hour)) {\n      this.setHours(config.hour);\n    }\n\n    if ($D.validateMonth(config.month)) {\n      this.addMonths(config.month - this.getMonth());\n    }\n\n    if ($D.validateYear(config.year)) {\n      this.addYears(config.year - this.getFullYear());\n    }\n    /* day has to go last because you can't validate the day without first knowing the month */\n\n\n    if ($D.validateDay(config.day, this.getFullYear(), this.getMonth())) {\n      this.addDays(config.day - this.getDate());\n    }\n\n    if (config.timezone) {\n      this.setTimezone(config.timezone);\n    }\n\n    if (config.timezoneOffset != null) {\n      this.setTimezoneOffset(config.timezoneOffset);\n    }\n\n    if (config.week && validate(config.week, 0, 53, 'week')) {\n      this.setWeek(config.week);\n    }\n\n    return this;\n  };\n  /**\n   * Moves the date to the first day of the month.\n   * @return {Date}    this\n   */\n\n\n  $P.moveToFirstDayOfMonth = function () {\n    return this.set({\n      day: 1\n    });\n  };\n  /**\n   * Moves the date to the last day of the month.\n   * @return {Date}    this\n   */\n\n\n  $P.moveToLastDayOfMonth = function () {\n    return this.set({\n      day: $D.getDaysInMonth(this.getFullYear(), this.getMonth())\n    });\n  };\n  /**\n   * Moves the date to the next n'th occurrence of the dayOfWeek starting from the beginning of the month. The number (-1) is a magic number and will return the last occurrence of the dayOfWeek in the month.\n   * @param {Number}   The dayOfWeek to move to\n   * @param {Number}   The n'th occurrence to move to. Use (-1) to return the last occurrence in the month\n   * @return {Date}    this\n   */\n\n\n  $P.moveToNthOccurrence = function (dayOfWeek, occurrence) {\n    let shift = 0;\n\n    if (occurrence > 0) {\n      shift = occurrence - 1;\n    } else if (occurrence === -1) {\n      this.moveToLastDayOfMonth();\n\n      if (this.getDay() !== dayOfWeek) {\n        this.moveToDayOfWeek(dayOfWeek, -1);\n      }\n\n      return this;\n    }\n\n    return this.moveToFirstDayOfMonth().addDays(-1).moveToDayOfWeek(dayOfWeek, 1).addWeeks(shift);\n  };\n  /**\n   * Move to the next or last dayOfWeek based on the orient value.\n   * @param {Number}   The dayOfWeek to move to\n   * @param {Number}   Forward (+1) or Back (-1). Defaults to +1. [Optional]\n   * @return {Date}    this\n   */\n\n\n  $P.moveToDayOfWeek = function (dayOfWeek, orient) {\n    let diff = (dayOfWeek - this.getDay() + 7 * (orient || 1)) % 7;\n    return this.addDays(diff === 0 ? diff += 7 * (orient || 1) : diff);\n  };\n  /**\n   * Move to the next or last month based on the orient value.\n   * @param {Number}   The month to move to. 0 = January, 11 = December\n   * @param {Number}   Forward (+1) or Back (-1). Defaults to +1. [Optional]\n   * @return {Date}    this\n   */\n\n\n  $P.moveToMonth = function (month, orient) {\n    let diff = (month - this.getMonth() + 12 * (orient || 1)) % 12;\n    return this.addMonths(diff === 0 ? diff += 12 * (orient || 1) : diff);\n  };\n  /**\n   * Get the Ordinal day (numeric day number) of the year, adjusted for leap year.\n   * @return {Number} 1 through 365 (366 in leap years)\n   */\n\n\n  $P.getOrdinalNumber = function () {\n    return Math.ceil((this.clone().clearTime() - new Date(this.getFullYear(), 0, 1)) / 86400000) + 1;\n  };\n  /**\n   * Get the time zone abbreviation of the current date.\n   * @return {String} The abbreviated time zone name (e.g. \"EST\")\n   */\n\n\n  $P.getTimezone = function () {\n    return $D.getTimezoneAbbreviation(this.getUTCOffset());\n  };\n\n  $P.setTimezoneOffset = function (offset) {\n    offset = Number(offset);\n    offset = -(Math.floor(offset / 100) * 60 + (offset % 100 + 60) % 60);\n    return this.addMinutes(offset - this.getTimezoneOffset());\n  };\n\n  $P.setTimezone = function (offset) {\n    return this.setTimezoneOffset($D.getTimezoneOffset(offset));\n  };\n  /**\n   * Indicates whether Daylight Saving Time is observed in the current time zone.\n   * @return {Boolean} true|false\n   */\n\n\n  $P.hasDaylightSavingTime = function () {\n    return Date.today().set({\n      month: 0,\n      day: 1\n    }).getTimezoneOffset() !== Date.today().set({\n      month: 6,\n      day: 1\n    }).getTimezoneOffset();\n  };\n  /**\n   * Indicates whether this Date instance is within the Daylight Saving Time range for the current time zone.\n   * @return {Boolean} true|false\n   */\n\n\n  $P.isDaylightSavingTime = function () {\n    return Date.today().set({\n      month: 0,\n      day: 1\n    }).getTimezoneOffset() != this.getTimezoneOffset();\n  };\n  /**\n   * Get the offset from UTC of the current date.\n   * @return {String} The 4-character offset string prefixed with + or - (e.g. \"-0500\")\n   */\n\n\n  $P.getUTCOffset = function () {\n    let offset = this.getTimezoneOffset(),\n        minutes = offset % 60,\n        n = -((offset - minutes) / 60 * 100 + minutes),\n        r;\n\n    if (n < 0) {\n      r = (n - 10000).toString();\n      return r.charAt(0) + r.substr(2);\n    } else {\n      r = (n + 10000).toString();\n      return '+' + r.substr(1);\n    }\n  };\n  /**\n   * Returns the number of milliseconds between this date and date.\n   * @param {Date} Defaults to now\n   * @return {Number} The diff in milliseconds\n   */\n\n\n  $P.getElapsed = function (date) {\n    return (date || new Date()) - this;\n  };\n\n  if (!$P.toISOString) {\n    /**\n     * Converts the current date instance into a string with an ISO 8601 format. The date is converted to it's UTC value.\n     * @return {String}  ISO 8601 string of date\n     */\n    $P.toISOString = function () {\n      // From http://www.json.org/json.js. Public Domain.\n      function f(n) {\n        return n < 10 ? '0' + n : n;\n      }\n\n      return '\"' + this.getUTCFullYear() + '-' + f(this.getUTCMonth() + 1) + '-' + f(this.getUTCDate()) + 'T' + f(this.getUTCHours()) + ':' + f(this.getUTCMinutes()) + ':' + f(this.getUTCSeconds()) + 'Z\"';\n    };\n  } // private\n\n\n  $P._toString = $P.toString;\n  /**\n     * Converts the value of the current Date object to its equivalent string representation.\n     * Format Specifiers\n    <pre>\n    CUSTOM DATE AND TIME FORMAT STRINGS\n    Format  Description                                                                  Example\n    ------  ---------------------------------------------------------------------------  -----------------------\n     s      The seconds of the minute between 0-59.                                      \"0\" to \"59\"\n     ss     The seconds of the minute with leading zero if required.                     \"00\" to \"59\"\n      m      The minute of the hour between 0-59.                                         \"0\"  or \"59\"\n     mm     The minute of the hour with leading zero if required.                        \"00\" or \"59\"\n      h      The hour of the day between 1-12.                                            \"1\"  to \"12\"\n     hh     The hour of the day with leading zero if required.                           \"01\" to \"12\"\n      H      The hour of the day between 0-23.                                            \"0\"  to \"23\"\n     HH     The hour of the day with leading zero if required.                           \"00\" to \"23\"\n      d      The day of the month between 1 and 31.                                       \"1\"  to \"31\"\n     dd     The day of the month with leading zero if required.                          \"01\" to \"31\"\n     ddd    Abbreviated day name. $C.abbreviatedDayNames.                                \"Mon\" to \"Sun\"\n     dddd   The full day name. $C.dayNames.                                              \"Monday\" to \"Sunday\"\n      M      The month of the year between 1-12.                                          \"1\" to \"12\"\n     MM     The month of the year with leading zero if required.                         \"01\" to \"12\"\n     MMM    Abbreviated month name. $C.abbreviatedMonthNames.                            \"Jan\" to \"Dec\"\n     MMMM   The full month name. $C.monthNames.                                          \"January\" to \"December\"\n      yy     The year as a two-digit number.                                              \"99\" or \"08\"\n     yyyy   The full four digit year.                                                    \"1999\" or \"2008\"\n      t      Displays the first character of the A.M./P.M. designator.                    \"A\" or \"P\"\n            $C.amDesignator or $C.pmDesignator\n     tt     Displays the A.M./P.M. designator.                                           \"AM\" or \"PM\"\n            $C.amDesignator or $C.pmDesignator\n      S      The ordinal suffix (\"st, \"nd\", \"rd\" or \"th\") of the current day.            \"st, \"nd\", \"rd\" or \"th\"\n  || *Format* || *Description* || *Example* ||\n  || d      || The CultureInfo shortDate Format Pattern                                     || \"M/d/yyyy\" ||\n  || D      || The CultureInfo longDate Format Pattern                                      || \"dddd, MMMM dd, yyyy\" ||\n  || F      || The CultureInfo fullDateTime Format Pattern                                  || \"dddd, MMMM dd, yyyy h:mm:ss tt\" ||\n  || m      || The CultureInfo monthDay Format Pattern                                      || \"MMMM dd\" ||\n  || r      || The CultureInfo rfc1123 Format Pattern                                       || \"ddd, dd MMM yyyy HH:mm:ss GMT\" ||\n  || s      || The CultureInfo sortableDateTime Format Pattern                              || \"yyyy-MM-ddTHH:mm:ss\" ||\n  || t      || The CultureInfo shortTime Format Pattern                                     || \"h:mm tt\" ||\n  || T      || The CultureInfo longTime Format Pattern                                      || \"h:mm:ss tt\" ||\n  || u      || The CultureInfo universalSortableDateTime Format Pattern                     || \"yyyy-MM-dd HH:mm:ssZ\" ||\n  || y      || The CultureInfo yearMonth Format Pattern                                     || \"MMMM, yyyy\" ||\n      STANDARD DATE AND TIME FORMAT STRINGS\n    Format  Description                                                                  Example (\"en-US\")\n    ------  ---------------------------------------------------------------------------  -----------------------\n     d      The CultureInfo shortDate Format Pattern                                     \"M/d/yyyy\"\n     D      The CultureInfo longDate Format Pattern                                      \"dddd, MMMM dd, yyyy\"\n     F      The CultureInfo fullDateTime Format Pattern                                  \"dddd, MMMM dd, yyyy h:mm:ss tt\"\n     m      The CultureInfo monthDay Format Pattern                                      \"MMMM dd\"\n     r      The CultureInfo rfc1123 Format Pattern                                       \"ddd, dd MMM yyyy HH:mm:ss GMT\"\n     s      The CultureInfo sortableDateTime Format Pattern                              \"yyyy-MM-ddTHH:mm:ss\"\n     t      The CultureInfo shortTime Format Pattern                                     \"h:mm tt\"\n     T      The CultureInfo longTime Format Pattern                                      \"h:mm:ss tt\"\n     u      The CultureInfo universalSortableDateTime Format Pattern                     \"yyyy-MM-dd HH:mm:ssZ\"\n     y      The CultureInfo yearMonth Format Pattern                                     \"MMMM, yyyy\"\n    </pre>\n     * @param {String}   A format string consisting of one or more format spcifiers [Optional].\n     * @return {String}  A string representation of the current Date object.\n     */\n\n  $P.toString = function (format) {\n    const x = this; // Standard Date and Time Format Strings. Formats pulled from CultureInfo file and\n    // may vary by culture.\n\n    if (format && format.length == 1) {\n      const c = $C.formatPatterns;\n      x.t = x.toString;\n\n      switch (format) {\n        case 'd':\n          return x.t(c.shortDate);\n\n        case 'D':\n          return x.t(c.longDate);\n\n        case 'F':\n          return x.t(c.fullDateTime);\n\n        case 'm':\n          return x.t(c.monthDay);\n\n        case 'r':\n          return x.t(c.rfc1123);\n\n        case 's':\n          return x.t(c.sortableDateTime);\n\n        case 't':\n          return x.t(c.shortTime);\n\n        case 'T':\n          return x.t(c.longTime);\n\n        case 'u':\n          return x.t(c.universalSortableDateTime);\n\n        case 'y':\n          return x.t(c.yearMonth);\n      }\n    }\n\n    const ord = function (n) {\n      switch (n * 1) {\n        case 1:\n        case 21:\n        case 31:\n          return 'st';\n\n        case 2:\n        case 22:\n          return 'nd';\n\n        case 3:\n        case 23:\n          return 'rd';\n\n        default:\n          return 'th';\n      }\n    };\n\n    return format ? format.replace(/(\\\\)?(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|S)/g, function (m) {\n      if (m.charAt(0) === '\\\\') {\n        return m.replace('\\\\', '');\n      }\n\n      x.h = x.getHours;\n\n      switch (m) {\n        case 'hh':\n          return p(x.h() < 13 ? x.h() === 0 ? 12 : x.h() : x.h() - 12);\n\n        case 'h':\n          return x.h() < 13 ? x.h() === 0 ? 12 : x.h() : x.h() - 12;\n\n        case 'HH':\n          return p(x.h());\n\n        case 'H':\n          return x.h();\n\n        case 'mm':\n          return p(x.getMinutes());\n\n        case 'm':\n          return x.getMinutes();\n\n        case 'ss':\n          return p(x.getSeconds());\n\n        case 's':\n          return x.getSeconds();\n\n        case 'yyyy':\n          return p(x.getFullYear(), 4);\n\n        case 'yy':\n          return p(x.getFullYear());\n\n        case 'dddd':\n          return $C.dayNames[x.getDay()];\n\n        case 'ddd':\n          return $C.abbreviatedDayNames[x.getDay()];\n\n        case 'dd':\n          return p(x.getDate());\n\n        case 'd':\n          return x.getDate();\n\n        case 'MMMM':\n          return $C.monthNames[x.getMonth()];\n\n        case 'MMM':\n          return $C.abbreviatedMonthNames[x.getMonth()];\n\n        case 'MM':\n          return p(x.getMonth() + 1);\n\n        case 'M':\n          return x.getMonth() + 1;\n\n        case 't':\n          return x.h() < 12 ? $C.amDesignator.substring(0, 1) : $C.pmDesignator.substring(0, 1);\n\n        case 'tt':\n          return x.h() < 12 ? $C.amDesignator : $C.pmDesignator;\n\n        case 'S':\n          return ord(x.getDate());\n\n        default:\n          return m;\n      }\n    }) : _originalDateDotPrototypeDotToString.apply(this, arguments);\n  };\n})();\n\n//# sourceURL=webpack:///./packages/canvas-rce/es/canvasFileBrowser/core.js?");

/***/ })

}]);
'use strict';

const _require = require('./constants'),
      REQUIRE = _require.REQUIRE,
      MODULE = _require.MODULE,
      EXPORTS = _require.EXPORTS,
      DEFINE = _require.DEFINE,
      AMD_DEFINE_RESULT = _require.AMD_DEFINE_RESULT,
      MAYBE_FUNCTION = _require.MAYBE_FUNCTION;

const createHelpers = require('./helpers');

module.exports = ({
  types: t
}) => {
  const _createHelpers = createHelpers({
    types: t
  }),
        decodeDefineArguments = _createHelpers.decodeDefineArguments,
        decodeRequireArguments = _createHelpers.decodeRequireArguments,
        isModuleOrExportsInjected = _createHelpers.isModuleOrExportsInjected,
        isSimplifiedCommonJSWrapper = _createHelpers.isSimplifiedCommonJSWrapper,
        createDependencyInjectionExpression = _createHelpers.createDependencyInjectionExpression,
        createRestDependencyInjectionExpression = _createHelpers.createRestDependencyInjectionExpression,
        createModuleExportsAssignmentExpression = _createHelpers.createModuleExportsAssignmentExpression,
        createModuleExportsResultCheck = _createHelpers.createModuleExportsResultCheck,
        getUniqueIdentifier = _createHelpers.getUniqueIdentifier,
        isFunctionExpression = _createHelpers.isFunctionExpression,
        createFactoryReplacementExpression = _createHelpers.createFactoryReplacementExpression,
        createFunctionCheck = _createHelpers.createFunctionCheck,
        isExplicitDependencyInjection = _createHelpers.isExplicitDependencyInjection;

  const argumentDecoders = {
    [DEFINE]: decodeDefineArguments,
    [REQUIRE]: decodeRequireArguments
  }; // Simple version of zip that only pairs elements until the end of the first array

  const zip = (array1, array2) => {
    return array1.map((element, index) => [element, array2[index]]);
  };

  const ExpressionStatement = (path, {
    opts
  }) => {
    const node = path.node,
          parent = path.parent;
    if (!t.isCallExpression(node.expression)) return;
    const options = Object.assign({
      restrictToTopLevelDefine: true
    }, opts);
    const name = node.expression.callee.name;
    const isDefineCall = name === DEFINE;
    if (isDefineCall && options.restrictToTopLevelDefine && !t.isProgram(parent)) return;
    const argumentDecoder = argumentDecoders[name];
    if (!argumentDecoder) return;

    const _argumentDecoder = argumentDecoder(node.expression.arguments),
          dependencyList = _argumentDecoder.dependencyList,
          factory = _argumentDecoder.factory;

    if (!t.isArrayExpression(dependencyList) && !factory) return;
    const isFunctionFactory = isFunctionExpression(factory);
    const dependencyInjections = [];

    if (dependencyList) {
      const dependencyParameterPairs = zip(dependencyList.elements, isFunctionFactory ? factory.params : []);

      if (isFunctionFactory) {
        const factoryArity = factory.params.length;
        const lastFactoryParam = factory.params[factoryArity - 1];

        if (t.isRestElement(lastFactoryParam)) {
          const restDependencyNodes = dependencyList.elements.slice(factoryArity - 1);
          const restDependencyInjections = createRestDependencyInjectionExpression(restDependencyNodes);
          dependencyParameterPairs.splice(factoryArity - 1, dependencyParameterPairs.length - factoryArity + 1, [restDependencyInjections, lastFactoryParam.argument]);
        }
      }

      const dependencyInjectionExpressions = dependencyParameterPairs.map(([dependency, paramName]) => {
        return createDependencyInjectionExpression(dependency, paramName);
      });
      dependencyInjections.push(...dependencyInjectionExpressions);
    }

    const explicitDependencyInjections = dependencyInjections.filter(isExplicitDependencyInjection);

    if (isFunctionFactory) {
      const factoryArity = factory.params.length;
      let replacementFuncExpr = createFactoryReplacementExpression(factory, explicitDependencyInjections);
      let replacementCallExprParams = [];

      if (isSimplifiedCommonJSWrapper(dependencyList, factoryArity)) {
        replacementFuncExpr = factory; // Order is important here for the simplified commonjs wrapper

        const amdKeywords = [REQUIRE, EXPORTS, MODULE];
        replacementCallExprParams = amdKeywords.slice(0, factoryArity).map(keyword => t.identifier(keyword));
      }

      const factoryReplacement = t.callExpression(replacementFuncExpr, replacementCallExprParams);

      if (isDefineCall) {
        if (!isModuleOrExportsInjected(dependencyList, factoryArity)) {
          path.replaceWith(createModuleExportsAssignmentExpression(factoryReplacement));
        } else {
          const resultCheckIdentifier = getUniqueIdentifier(path.scope, AMD_DEFINE_RESULT);
          path.replaceWithMultiple(createModuleExportsResultCheck(factoryReplacement, resultCheckIdentifier));
        }
      } else {
        path.replaceWith(factoryReplacement);
      }
    } else if (factory && isDefineCall) {
      const functionCheckNodes = createFunctionCheck(factory, getUniqueIdentifier(path.scope, MAYBE_FUNCTION), getUniqueIdentifier(path.scope, AMD_DEFINE_RESULT), dependencyInjections);
      path.replaceWithMultiple(functionCheckNodes);
    } else {
      path.replaceWithMultiple(explicitDependencyInjections);
    }
  };

  return {
    visitor: {
      ExpressionStatement
    }
  };
};
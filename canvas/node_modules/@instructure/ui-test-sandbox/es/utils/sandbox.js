import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import sinon from 'sinon';
import { ReactComponentWrapper } from "./reactComponentWrapper.js";
import initConsole from "./initConsole.js";
/* istanbul ignore next */

var Sandbox = /*#__PURE__*/function () {
  function Sandbox() {
    _classCallCheck(this, Sandbox);

    // eslint-disable-next-line no-console
    console.info('[ui-test-sandbox] Initializing test sandbox...');

    try {
      // global Mocha (or Jest?) hooks
      before(this.init.bind(this));
      beforeEach(this.setup.bind(this));
      afterEach(this.teardown.bind(this));
    } catch (e) {
      console.warn("[ui-test-sandbox] error initializing test sandbox: ".concat(e));
    }
  }

  _createClass(Sandbox, [{
    key: "init",
    value: function init() {
      var _this = this;

      initConsole();
      this._timeouts = [];
      var originalSetTimeout = global.setTimeout;

      if (typeof originalSetTimeout === 'function') {
        global.setTimeout = function () {
          var timeoutId = originalSetTimeout.apply(void 0, arguments);

          _this._timeouts.push(timeoutId);

          return timeoutId;
        };
      }

      this._raf = [];
      var originalWindowRequestAnimationFrame = window.requestAnimationFrame;

      if (typeof originalWindowRequestAnimationFrame === 'function') {
        window.requestAnimationFrame = function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var requestId = originalWindowRequestAnimationFrame.apply(window, args);

          _this._raf.push(requestId);

          return requestId;
        };
      } // override mocha's onerror handler


      if (typeof window.onerror === 'function') {
        window.onerror = overrideWindowOnError(window.onerror);
      } // for prop-type warnings:


      if (typeof console.error === 'function') {
        console.error = overrideConsoleError(console.error);
      }

      this._sandbox = sinon.createSandbox();
      this._attributes = {
        document: _toConsumableArray(document.documentElement.attributes),
        body: _toConsumableArray(document.body.attributes)
      };
      this._addedNodes = [];
      this._observer = new MutationObserver(function (mutations) {
        var addedNodes = Array.from(mutations).map(function (mutation) {
          return Array.from(mutation.addedNodes);
        });
        _this._addedNodes = _this._addedNodes.concat(addedNodes);
      });
      resetViewport();
      this.teardownComplete = true;
    }
  }, {
    key: "setup",
    value: function () {
      var _setup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.teardownComplete) {
                  _context.next = 3;
                  break;
                }

                _context.next = 3;
                return this.teardown();

              case 3:
                document.documentElement.setAttribute('dir', 'ltr');
                document.documentElement.setAttribute('lang', 'en-US');

                this._sandbox.restore();

                if (window.fetch) {
                  this._sandbox.stub(window, 'fetch').callsFake(function () {
                    return Promise.resolve(new window.Response(JSON.stringify({
                      key: 'value'
                    }), {
                      //the fetch API returns a resolved window Response object
                      status: 200,
                      headers: {
                        'Content-type': 'application/json'
                      }
                    }));
                  });
                }

                this._observer.observe(document.head, {
                  childList: true
                });

                this._observer.observe(document.body, {
                  childList: true
                });

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setup() {
        return _setup.apply(this, arguments);
      }

      return setup;
    }()
  }, {
    key: "teardown",
    value: function () {
      var _teardown = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var styleSheet;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return ReactComponentWrapper.unmount();

              case 2:
                // avoiding circular deps by not importing @instructure/ui-themeable here:
                if (global.GLOBAL_THEME_REGISTRY) {
                  styleSheet = global.GLOBAL_THEME_REGISTRY.styleSheet;
                  styleSheet && styleSheet.flush();
                }

                this._sandbox.restore();

                this._timeouts.forEach(function (timeoutId) {
                  clearTimeout(timeoutId);
                });

                this._timeouts = [];

                this._raf.forEach(function (requestId) {
                  window.cancelAnimationFrame(requestId);
                });

                this._raf = [];
                window.localStorage && window.localStorage.clear();
                window.sessionStorage && window.sessionStorage.clear();
                setAttributes(document.documentElement, this._attributes.document);
                setAttributes(document.body, this._attributes.body);

                this._observer.disconnect();

                this._observer.takeRecords();

                this._addedNodes.forEach(function (node) {
                  return node && typeof node.remove === 'function' && node.remove();
                });

                this._addedNodes = [];
                resetViewport();
                this.teardownComplete = true;

              case 18:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function teardown() {
        return _teardown.apply(this, arguments);
      }

      return teardown;
    }()
  }, {
    key: "stub",
    value: function stub(obj, method, fn) {
      if (!this._sandbox) {
        throw new Error('[ui-test-sandbox] a stub cannot be created outside an `it`, `before`, or `beforeEach` block.');
      }

      if (typeof fn === 'function') {
        return this._sandbox.stub(obj, method).callsFake(fn);
      } else {
        return this._sandbox.stub(obj, method);
      }
    }
  }, {
    key: "spy",
    value: function spy(obj, method) {
      if (!this._sandbox) {
        throw new Error('[ui-test-sandbox] a spy cannot be created outside an `it`, `before`, or `beforeEach` block.');
      }

      return this._sandbox.spy(obj, method);
    }
  }, {
    key: "mount",
    value: function mount(element, options) {
      return ReactComponentWrapper.mount(element, options);
    }
  }, {
    key: "unmount",
    value: function unmount() {
      return ReactComponentWrapper.unmount();
    }
  }, {
    key: "viewport",
    value: function viewport() {
      if (!global.viewport) {
        console.error('[ui-test-sandbox] the `viewport` global has not been configured. See https://github.com/squidfunk/karma-viewport.');
      }

      return global.viewport;
    }
  }]);

  return Sandbox;
}();

function resetViewport() {
  if (global.viewport && typeof global.viewport.reset === 'function') {
    global.viewport.reset();
  }
}
/* istanbul ignore next */


function overrideWindowOnError(windowOnError) {
  return function (err, url, line) {
    var error = typeof err === 'string' ? err : err.toString(); // Prevent default window errors for uncaught errors in React 16+ here.
    // The promise returned by the mount, setProps, and setContext utils will be rejected when they are thrown.
    // Ignore them here so that they don't fail the test when they have been handled.

    if (error.startsWith('Error: Warning:') || error.startsWith('Uncaught Error: Warning:') || error.startsWith('The above error occurred')) {
      return true;
    }

    return windowOnError(err, url, line);
  };
}
/* istanbul ignore next */


function overrideConsoleError(consoleError) {
  return function (first) {
    var error = typeof first === 'string' ? first : first.toString();

    if (error.startsWith('Warning:')) {
      // throw an error so that prop type validation errors are caught in our tests:
      throw new Error(first);
    } // ignore the noisy/extra uncaught error messages fired by React 16+


    if (error.startsWith('Uncaught Error: Warning:') || error.startsWith('The above error occurred')) {
      return;
    }

    if (process.env.DEBUG) {
      for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        rest[_key2 - 1] = arguments[_key2];
      }

      return consoleError.apply(void 0, [first].concat(rest));
    }
  };
}
/* istanbul ignore next */


function setAttributes(element) {
  var attributes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];

  if (element && element.attributes) {
    ;

    _toConsumableArray(element.attributes).forEach(function (attribute) {
      element.removeAttribute(attribute.name);
    });

    attributes.forEach(function (attribute) {
      element.setAttribute(attribute.name, attribute.value);
    });
  }
} // only allow one Sandbox instance


var sandbox = global.sandbox = global.sandbox || new Sandbox();
var viewport = sandbox.viewport;

var mount = function mount(element, context) {
  return sandbox.mount(element, context);
};

var unmount = sandbox.unmount;

var stub = function stub(obj, method, fn) {
  return sandbox.stub(obj, method, fn);
};

var spy = function spy(obj, method) {
  return sandbox.spy(obj, method);
};

export { viewport, mount, unmount, stub, spy };
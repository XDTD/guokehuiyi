"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.safeCloneElement = safeCloneElement;
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _console = require("@instructure/console");

var _react = _interopRequireDefault(require("react"));

var _createChainedFunction = require("@instructure/ui-utils/lib/createChainedFunction.js");

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
* ---
* category: utilities/react
* ---
* Clone a React element without overwriting refs.
* @module safeCloneElement
* @param {ReactElement} element
* @param {object} props
* @return {ReactElement}
*/
function safeCloneElement(element, props) {
  var cloneRef = props.ref;
  var originalRef = element.ref;
  var originalRefIsAFunction = typeof originalRef === 'function';
  var mergedProps = (0, _objectSpread2.default)({}, props);

  if (element.props.style && props.style) {
    // merge with existing styles
    mergedProps.style = (0, _objectSpread2.default)({}, element.props.style, {}, props.style);
  } // prevent overriding existing keys


  mergedProps.key = element.key || props.key; // Add chained function to preserve existing event handlers

  Object.keys(props).forEach(function (prop) {
    // If prop looks like an event handler "on*" and either
    // props[props] or element.props[prop] is a function create a chained function.
    // If only one is a function it will just use that function with no extra overhead.
    // This is necessary in cases where props[prop] is `null` or `undefined` which would
    // otherwise unwantedly override element.props[prop].
    if (prop.indexOf('on') === 0 && (typeof props[prop] === 'function' || typeof element.props[prop] === 'function')) {
      mergedProps[prop] = (0, _createChainedFunction.createChainedFunction)(element.props[prop], props[prop]);
    }
  });

  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments[_key];
  }

  if (originalRef == null || cloneRef == null) {
    return _react.default.cloneElement.apply(_react.default, [element, mergedProps].concat(children));
  }

  /*#__PURE__*/
  ( /*#__PURE__*/0, _console.warn)(originalRefIsAFunction, "Cloning an element with a ref that will be overwritten because the ref is not a function. Use a composable callback-style ref instead. Ignoring ref: ".concat(originalRef));
  return _react.default.cloneElement.apply(_react.default, [element, (0, _objectSpread2.default)({}, mergedProps, {
    ref: function ref(component) {
      cloneRef(component);
      originalRef(component);
    }
  })].concat(children));
}

var _default = safeCloneElement;
exports.default = _default;
import * as React from 'react';

export type ContextViewHeight = string | number;

export type ContextViewWidth = string | number;

export type ContextViewMaxHeight = string | number;

export type ContextViewMaxWidth = string | number;

export type ContextViewMinHeight = string | number;

export type ContextViewMinWidth = string | number;

export type ContextViewTextAlign = "start" | "center" | "end";

export type ContextViewBackground = "default" | "inverse";

export interface ContextViewProps {
    /**
     * The element to render as the component root
     */
    as?: any;
    /**
     * provides a reference to the underlying html root element
     */
    elementRef?: (...args: any[])=>any;
    /**
     * Set the margin using familiar CSS shorthand
     */
    margin?: any;
    /**
     * Set the padding using familiar CSS shorthand
     */
    padding?: any;
    height?: ContextViewHeight;
    width?: ContextViewWidth;
    maxHeight?: ContextViewMaxHeight;
    maxWidth?: ContextViewMaxWidth;
    minHeight?: ContextViewMinHeight;
    minWidth?: ContextViewMinWidth;
    /**
     * The children to render inside the `<ContextView />`
     */
    children?: React.ReactNode;
    /**
     * Designates the text alignment within the `<ContextView />`
     */
    textAlign?: ContextViewTextAlign;
    /**
     * Controls the shadow depth for the `<ContextView />`
     */
    shadow?: any;
    /**
     * Controls the z-index depth for the `<ContextView />`
     */
    stacking?: any;
    /**
     * Designates the background style of the `<ContextView />`
     */
    background?: ContextViewBackground;
    /**
     * Specifies how the arrow for `<ContextView />` will be rendered.
     * Ex. `placement="top"` will render with an arrow pointing down.
     */
    placement?: any;
    /**
     * Activate an outline around the component to make building your
     * layout easier
     */
    debug?: boolean;
}

export class ContextView extends React.Component<ContextViewProps, any> {
    render(): JSX.Element;

}




export interface DrawerLayoutProps {
    /**
     * Exactly one of each of the following child types: `DrawerLayout.Content`, `DrawerLayout.Tray`
     */
    children?: any;
    /**
     * Min width for the `<DrawerLayout.Content />`
     */
    minWidth?: string;
    /**
     * Function called when the `<DrawerLayout.Content />` is resized and hits the `minWidth` breakpoint
     * Called with a boolean value, `true` if the tray is now overlaying the content or `false` if
     * it is side by side
     */
    onOverlayTrayChange?: (...args: any[])=>any;
}

export class DrawerLayout extends React.Component<DrawerLayoutProps, any> {
    render(): JSX.Element;

}




export type FlexDirection = "row" | "column" | "row-reverse" | "column-reverse";

export type FlexHeight = string | number;

export type FlexWidth = string | number;

export type FlexTextAlign = "start" | "center" | "end";

export type FlexAlignItems = "center" | "start" | "end" | "stretch";

export type FlexJustifyItems = "center" | "start" | "end" | "space-around" | "space-between";

export interface FlexProps {
    /**
     * Flex only accepts Flex.Item as a child
     */
    children?: any;
    /**
     * the element type to render as
     */
    as?: any;
    /**
     * provides a reference to the underlying html root element
     */
    elementRef?: (...args: any[])=>any;
    /**
     * Sets the flex-direction to row (horizontal) or column (vertical)
     */
    direction?: FlexDirection;
    /**
     * Sets the height of the component's container (optional)
     */
    height?: FlexHeight;
    /**
     * Sets the width of the component's container (optional)
     */
    width?: FlexWidth;
    inline?: boolean;
    textAlign?: FlexTextAlign;
    /**
     * Valid values are `0`, `none`, `auto`, `xxx-small`, `xx-small`, `x-small`,
     * `small`, `medium`, `large`, `x-large`, `xx-large`. Apply these values via
     * familiar CSS-like shorthand. For example: `margin="small auto large"`.
     */
    margin?: any;
    /**
     * Valid values are `0`, `none`, `xxx-small`, `xx-small`, `x-small`,
     * `small`, `medium`, `large`, `x-large`, `xx-large`. Apply these values via
     * familiar CSS-like shorthand. For example: `padding="small x-large large"`.
     */
    padding?: any;
    alignItems?: FlexAlignItems;
    justifyItems?: FlexJustifyItems;
    /**
     * Places dashed lines around the component's borders to help debug your layout
     */
    visualDebug?: boolean;
    wrapItems?: boolean;
}

export class Flex extends React.Component<FlexProps, any> {
    render(): JSX.Element;

}




export type GridColSpacing = "none" | "small" | "medium" | "large";

export type GridRowSpacing = "none" | "small" | "medium" | "large";

export type GridHAlign = "start" | "center" | "end" | "space-around" | "space-between";

export type GridVAlign = "top" | "middle" | "bottom";

export type GridStartAt = "small" | "medium" | "large" | "x-large" | any;

export interface GridProps {
    children?: any;
    colSpacing?: GridColSpacing;
    rowSpacing?: GridRowSpacing;
    hAlign?: GridHAlign;
    vAlign?: GridVAlign;
    startAt?: GridStartAt;
    visualDebug?: boolean;
}

export class Grid extends React.Component<GridProps, any> {
    render(): JSX.Element;

}




export type MediaDescription = string | React.ReactNode;

export type MediaAlignContent = "top" | "center";

export type MediaSize = "small" | "medium" | "large";

export interface MediaProps {
    /**
     * the media object
     */
    children: React.ReactNode;
    /**
     * the media title
     */
    title?: React.ReactNode;
    /**
     * the media description
     */
    description?: MediaDescription;
    /**
     * how should the title and description align
     */
    alignContent?: MediaAlignContent;
    /**
     * Valid values are `0`, `none`, `auto`, `xxx-small`, `xx-small`, `x-small`,
     * `small`, `medium`, `large`, `x-large`, `xx-large`. Apply these values via
     * familiar CSS-like shorthand. For example: `margin="small auto large"`.
     */
    margin?: any;
    size?: MediaSize;
    elementRef?: (...args: any[])=>any;
}

export class Media extends React.Component<MediaProps, any> {
    render(): JSX.Element;

}




export interface PositionContentProps {
    children?: React.ReactNode;
    placement?: any;
}

export class PositionContent extends React.Component<PositionContentProps, any> {
    render(): JSX.Element;

}

export type PositionTarget = any | ((...args: any[])=>any);

export type PositionOffsetX = string | number;

export type PositionOffsetY = string | number;

export type PositionInsertAt = "bottom" | "top";

export interface PositionProps {
    /**
     * The children to be rendered within the `<Position />`
     */
    children?: React.ReactNode;
    /**
     * The target to be used when not using `<PositionTarget />`
     */
    target?: PositionTarget;
    /**
     * Whether or not you want the content to position over the `<PositionTarget />`
     */
    over?: boolean;
    /**
     * The placement of the content in relation to the trigger
     */
    placement?: any;
    /**
     * The horizontal offset for the positioned content
     */
    offsetX?: PositionOffsetX;
    /**
     * The vertical offset for the positioned content
     */
    offsetY?: PositionOffsetY;
    /**
     * Callback fired when the position changes
     */
    onPositionChanged?: (...args: any[])=>any;
    /**
     * Callback fired when `<Position />` content has been mounted and is initially positioned
     */
    onPositioned?: (...args: any[])=>any;
    /**
     * Whether or not position of the target should be tracked or just set statically on render
     */
    trackPosition?: boolean;
    /**
     * An element or a function returning an element to use as the mount node
     * for the `<Position />` (defaults to `document.body`)
     */
    mountNode?: any;
    /**
     * Insert the element at the 'top' of the mountNode or at the 'bottom'
     */
    insertAt?: PositionInsertAt;
    /**
     * The parent in which to constrain the placement.
     * One of: 'window', 'scroll-parent', 'parent', 'none', an element,
     * or a function returning an element
     */
    constrain?: any;
    id?: string;
}

export class Position extends React.Component<PositionProps, any> {
    render(): JSX.Element;

}




export type ResponsiveMatch = "element" | "media";

export interface ResponsiveProps {
    /**
     * Specifies if the `<Responsive />` component should use element or media queries
     */
    match?: ResponsiveMatch;
    /**
     * Consists of an object where the keys define the names of breakpoints. The values are query objects
     * with keys representing the breakpoint condition and values representing a breakpoint value as a
     * string or number. Ex. `{small: { maxWidth: 400 }, large: { minWidth: '600em'}}`
     */
    query?: any;
    /**
     * Consists of an object where the keys match the breakpoint names used in the query. The values
     * are objects with keys representing prop names and values representing prop values Ex.
     * `{small: { myProp: 'fillscreen' }, large: { myProp: 'fillcontainer' }}`
     */
    props?: any;
    /**
     * Function called on render with the following form `(props, matches) => {...}` where the props
     * are the current props to be applied and matches is an array of current matches from the query
     * prop. Either this or a `children` prop function must be supplied.
     */
    render?: (...args: any[])=>any;
    /**
     * Function that takes the same form and arguments as the render prop. Either this or a `render`
     * prop function must be supplied.
     */
    children?: (...args: any[])=>any;
}

export class Responsive extends React.Component<ResponsiveProps, any> {
    render(): JSX.Element;

}




export type ViewDisplay = "auto" | "block" | "inline-block" | "flex" | "inline-flex";

export type ViewOverflowX = "auto" | "hidden" | "visible";

export type ViewOverflowY = "auto" | "hidden" | "visible";

export type ViewHeight = string | number;

export type ViewWidth = string | number;

export type ViewMaxHeight = string | number;

export type ViewMaxWidth = string | number;

export type ViewMinHeight = string | number;

export type ViewMinWidth = string | number;

export type ViewTextAlign = "start" | "center" | "end";

export type ViewBorderColor = "default" | "inverse" | "brand" | "info" | "success" | "warning" | "alert" | "danger";

export type ViewBackground = "default" | "inverse" | "light" | "transparent" | "brand" | "alert" | "info" | "success" | "danger" | "warning";

export type ViewPosition = "static" | "absolute" | "relative" | "sticky" | "fixed";

export type ViewFocusPosition = "offset" | "inset";

export type ViewFocusColor = "info" | "inverse" | "success" | "danger";

export interface ViewProps {
    /**
     * The element to render as the component root, `span` by default
     */
    as?: any;
    /**
     * provides a reference to the underlying html element
     */
    elementRef?: (...args: any[])=>any;
    /**
     * By default the display prop is 'auto', meaning it takes on the
     * display rules of the html element it's rendered as (see `as` prop).
     */
    display?: ViewDisplay;
    overflowX?: ViewOverflowX;
    overflowY?: ViewOverflowY;
    /**
     * Set the margin using familiar CSS shorthand
     */
    margin?: any;
    /**
     * Set the padding using familiar CSS shorthand
     */
    padding?: any;
    height?: ViewHeight;
    width?: ViewWidth;
    maxHeight?: ViewMaxHeight;
    maxWidth?: ViewMaxWidth;
    minHeight?: ViewMinHeight;
    minWidth?: ViewMinWidth;
    /**
     * The children to render inside the `<View />`
     */
    children?: React.ReactNode;
    /**
     * Designates the text alignment within the `<View />`
     */
    textAlign?: ViewTextAlign;
    /**
     * Accepts the familiar CSS shorthand to designate border widths corresponding
     * to edges
     */
    borderWidth?: any;
    /**
     * Accepts `small`, `medium`, `large`, `circle`, and `pill`. Border radius can be
     * assigned to individual corners in CSS shorthand style (e.g., `"medium large none pill"`).
     */
    borderRadius?: any;
    /**
     * Sets the color of the View border
     */
    borderColor?: ViewBorderColor;
    /**
     * Designates the background style of the `<View />`
     */
    background?: ViewBackground;
    /**
     * Controls the shadow depth for the `<View />`
     */
    shadow?: any;
    /**
     * Controls the z-index depth for the `<View />`
     */
    stacking?: any;
    /**
     * Specify a mouse cursor to use when hovering over the `<View />`
     */
    cursor?: any;
    /**
     * Specify a value for the CSS position property. Use `relative` if `focusable` will be true.
     */
    position?: ViewPosition;
    /**
     * The `left` CSS property in left-to-right interfaces. Will not do anything if `position === "static"`.
     */
    insetInlineStart?: string;
    /**
     * The `right` CSS property in left-to-right interfaces. Will not do anything if `position === "static"`.
     */
    insetInlineEnd?: string;
    /**
     * The `top` CSS property. Will not do anything if `position === "static"`.
     */
    insetBlockStart?: string;
    /**
     * The `bottom` CSS property. Will not do anything if `position === "static"`.
     */
    insetBlockEnd?: string;
    /**
     * When true and position prop is `relative`, show focus outline.
     */
    focused?: boolean;
    /**
     * Determines whether the focus outline displays offset or inset from the focused View
     */
    focusPosition?: ViewFocusPosition;
    /**
     * Determines the color of the focus outline
     */
    focusColor?: ViewFocusColor;
    shouldAnimateFocus?: boolean;
    /**
     * Activate a dotted outline around the component to make building your
     * layout easier
     */
    debug?: boolean;
}

export class View extends React.Component<ViewProps, any> {
    render(): JSX.Element;

}


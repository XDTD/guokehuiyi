"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scopeStylesToNode = scopeStylesToNode;
exports.scopeCssText = scopeCssText;
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _transformCss = require("./transformCss");

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
function scopeStylesToNode(domNode, cssText, scope) {
  var styleNode = domNode.querySelector("#".concat(scope));
  var attr = scope.toLowerCase();

  if (!cssText) {
    if (styleNode) {
      if (!styleNode.scoped) {
        removeScopeFromDomNode(domNode, attr);
      }

      domNode.removeChild(styleNode);
    }
  } else {
    var shouldInsertNode = !styleNode;
    var scopedCSS = cssText;

    if (shouldInsertNode) {
      styleNode = document.createElement('style');
      styleNode.setAttribute('scoped', true);
      styleNode.setAttribute('type', 'text/css');
      styleNode.id = scope;
    }

    if (!styleNode.scoped) {
      // if scoped styles are not supported
      addScopeToDomNode(domNode, attr);
      scopedCSS = scopeCssText(scopedCSS, "[".concat(attr, "]"));
    }

    if (shouldInsertNode) {
      domNode.insertBefore(styleNode, domNode.firstChild);
    }

    if ('textContent' in styleNode) {
      styleNode.textContent = scopedCSS;
    } else {
      styleNode.styleSheet.cssText = scopedCSS;
    }
  }
}

function scopeCssText(cssText, scope) {
  return (0, _transformCss.transformCss)(cssText, function (rule) {
    var transformed = (0, _objectSpread2.default)({}, rule);

    if (!rule.isScoped) {
      transformed.selector = scopeRule(rule, scope);
      transformed.isScoped = true;
    }

    return transformed;
  });
}

function addScopeToDomNode(node, scope) {
  // for SVG nodes children is undefined in IE/Edge
  var children = node.children || node.childNodes;

  if (node.setAttribute) {
    node.setAttribute(scope, '');
  }

  for (var i = 0; i < children.length; i++) {
    addScopeToDomNode(children[i], scope);
  }
}

function removeScopeFromDomNode(node, scope) {
  var children = node.children || node.childNodes;

  if (node.removeAttribute) {
    node.removeAttribute(scope);
  }

  for (var i = 0; i < children.length; i++) {
    removeScopeFromDomNode(children[i], scope);
  }
}

function isRootSelector(selector) {
  // eslint-disable-next-line no-useless-escape
  return selector.match(/^(_|html|body|\:root)/i);
}

function isClassSelector(selector) {
  return selector.match(/(^)((\S+)?(\.)(\S+))/);
}

function scopeSimpleSelector(selector, scope) {
  var parts = selector.split(':');
  parts[0] += scope;
  return parts.join(':');
}

function scopeCompoundSelector(selector, combinator, scope) {
  if (isRootSelector(selector)) {
    return selector;
  }

  var scopedSelector = scope ? scopeSimpleSelector(selector, scope) : selector;
  return combinator + scopedSelector;
}

function scopeComplexSelector(selector, scope) {
  var scopedSelector = selector.trim();
  scopedSelector = scopedSelector.replace( // eslint-disable-next-line no-useless-escape
  /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=\[])+)/g, function (match, combinator, selector) {
    var offset = arguments[arguments.length - 2];

    if (isClassSelector(selector) || offset > 0) {
      return scopeCompoundSelector(selector, combinator, scope);
    } else {
      return selector;
    }
  });
  return scopedSelector;
}

function scopeRule(rule, scope) {
  var parts = rule.selector.split(',');

  if (!(0, _transformCss.isKeyframesSelector)(rule)) {
    parts = parts.map(function (part) {
      return scopeComplexSelector(part, scope);
    });
  }

  return parts.join(',');
}

var _default = scopeStylesToNode;
exports.default = _default;
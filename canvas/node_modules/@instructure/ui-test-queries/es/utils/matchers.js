/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import { label, title } from "./helpers.js";
import { normalizeText } from "./normalizeText.js";
import { getNodeText } from "./getNodeText.js";

function matches(textToMatch, matcherString) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    exact: true,
    trim: true,
    collapseWhitespace: true
  };
  var exact = options.exact,
      collapseWhitespace = options.collapseWhitespace,
      trim = options.trim;
  var matcher = exact ? exactMatches : fuzzyMatches;
  return matcher(textToMatch, matcherString, {
    collapseWhitespace: collapseWhitespace,
    trim: trim
  });
}

function fuzzyMatches(textToMatch, matcher) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      _ref$collapseWhitespa = _ref.collapseWhitespace,
      collapseWhitespace = _ref$collapseWhitespa === void 0 ? true : _ref$collapseWhitespa,
      _ref$trim = _ref.trim,
      trim = _ref$trim === void 0 ? true : _ref$trim;

  if (typeof textToMatch !== 'string') {
    return false;
  }

  var normalizedText = normalizeText(textToMatch, {
    trim: trim,
    collapseWhitespace: collapseWhitespace
  });

  if (typeof matcher === 'string') {
    return normalizedText.toLowerCase().includes(matcher.toLowerCase());
  } else {
    return matcher.test(normalizedText);
  }
}

function exactMatches(textToMatch, matcher) {
  var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      _ref2$collapseWhitesp = _ref2.collapseWhitespace,
      collapseWhitespace = _ref2$collapseWhitesp === void 0 ? true : _ref2$collapseWhitesp,
      _ref2$trim = _ref2.trim,
      trim = _ref2$trim === void 0 ? true : _ref2$trim;

  if (typeof textToMatch !== 'string') {
    return false;
  }

  var normalizedText = normalizeText(textToMatch, {
    trim: trim,
    collapseWhitespace: collapseWhitespace
  });

  if (typeof matcher === 'string') {
    return normalizedText === matcher;
  } else {
    return matcher.test(normalizedText);
  }
}

function matchElementByTitle(element, titleText, options) {
  return matches(title(element), titleText, options);
}

function matchElementByLabel(element, labelText, options) {
  return matches(label(element), labelText, options);
}

function matchElementByText(element, text, options) {
  return matches(getNodeText(element), text, options);
}

function matchElementByAttributeValue(element, name, value, options) {
  return matches(element.getAttribute(name), value, options);
}

export { matches, matchElementByTitle, matchElementByLabel, matchElementByAttributeValue, matchElementByText };
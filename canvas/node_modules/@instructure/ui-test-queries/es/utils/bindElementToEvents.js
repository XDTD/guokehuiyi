import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import keycode from 'keycode';
import { isElement } from "./isElement.js";
import { find } from "./queries.js";
export function bindElementToEvents(element, events) {
  return Object.entries(events).reduce(function (bound, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        fn = _ref2[1];

    if (['keyDown', 'keyPress', 'keyUp'].includes(key)) {
      // eslint-disable-next-line no-param-reassign
      bound[key] = fireKeyboardEvent.bind(null, element, fn);
    } else if (['focus'].includes(key)) {
      // eslint-disable-next-line no-param-reassign
      bound[key] = fireFocusEvent.bind(null, element, fn);
    } else if (['blur'].includes(key)) {
      // eslint-disable-next-line no-param-reassign
      bound[key] = fireBlurEvent.bind(null, element, fn);
    } else if (['click'].includes(key)) {
      // eslint-disable-next-line no-param-reassign
      bound[key] = fireClickEvent.bind(null, element, fn);
    } else if (['dblClick'].includes(key) || key.startsWith('mouse') || key.startsWith('drag') || key.startsWith('touch')) {
      // eslint-disable-next-line no-param-reassign
      bound[key] = firePointerEvent.bind(null, element, fn);
    } else {
      // eslint-disable-next-line no-param-reassign
      bound[key] = fireDOMEvent.bind(null, element, fn);
    }

    return bound;
  }, {});
}

function fireDOMEvent(element, fn, init) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var fireEvent = fn.bind(null, element);
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      try {
        resolve(fireEvent(init));
      } catch (e) {
        reject(e);
      }
    }, 0);
  });
}

function firePointerEvent(_x, _x2, _x3) {
  return _firePointerEvent.apply(this, arguments);
}

function _firePointerEvent() {
  _firePointerEvent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(element, fn, init) {
    var options,
        clickable,
        _args = arguments;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = _args.length > 3 && _args[3] !== void 0 ? _args[3] : {
              clickable: true
            };
            clickable = element;

            if (!options.clickable) {
              _context.next = 6;
              break;
            }

            _context.next = 5;
            return find(element, ':clickable');

          case 5:
            clickable = _context.sent;

          case 6:
            if (clickable && typeof clickable.getDOMNode === 'function') {
              clickable = clickable.getDOMNode();
            }

            return _context.abrupt("return", new Promise(function (resolve, reject) {
              setTimeout(function () {
                try {
                  if (isElement(clickable)) {
                    var fireEvent = fn.bind(null, clickable);
                    resolve(fireEvent(init));
                  } else {
                    reject(new Error("[ui-test-queries] could not fire a pointer event on an element that is not 'clickable': ".concat(element)));
                  }
                } catch (e) {
                  /* istanbul ignore next */
                  reject(e);
                }
              }, 0);
            }));

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _firePointerEvent.apply(this, arguments);
}

function fireClickEvent(_x4, _x5, _x6) {
  return _fireClickEvent.apply(this, arguments);
}

function _fireClickEvent() {
  _fireClickEvent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(element, fn, init) {
    var options,
        clickable,
        _args2 = arguments;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            options = _args2.length > 3 && _args2[3] !== void 0 ? _args2[3] : {
              clickable: true,
              simulate: false
            };
            clickable = element;

            if (!options.clickable) {
              _context2.next = 6;
              break;
            }

            _context2.next = 5;
            return find(element, ':clickable');

          case 5:
            clickable = _context2.sent;

          case 6:
            if (clickable && typeof clickable.getDOMNode === 'function') {
              clickable = clickable.getDOMNode();
            }

            return _context2.abrupt("return", new Promise(function (resolve, reject) {
              setTimeout(function () {
                try {
                  if (isElement(clickable)) {
                    if (!options.simulate) {
                      var fireEvent = fn.bind(null, clickable);
                      resolve(fireEvent(init));
                    } else {
                      resolve(clickable.click());
                    }
                  } else {
                    reject(new Error("[ui-test-queries] could not fire a click event on an element that is not 'clickable': ".concat(element)));
                  }
                } catch (e) {
                  /* istanbul ignore next */
                  reject(e);
                }
              }, 0);
            }));

          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _fireClickEvent.apply(this, arguments);
}

function fireBlurEvent(_x7, _x8, _x9) {
  return _fireBlurEvent.apply(this, arguments);
}

function _fireBlurEvent() {
  _fireBlurEvent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(element, fn, init) {
    var options,
        focusable,
        _args3 = arguments;
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            options = _args3.length > 3 && _args3[3] !== void 0 ? _args3[3] : {
              focusable: true,
              simulate: false
            };
            focusable = element;

            if (!options.focusable) {
              _context3.next = 6;
              break;
            }

            _context3.next = 5;
            return find(element, ':focusable');

          case 5:
            focusable = _context3.sent;

          case 6:
            if (focusable && typeof focusable.getDOMNode === 'function') {
              focusable = focusable.getDOMNode();
            }

            return _context3.abrupt("return", new Promise(function (resolve, reject) {
              setTimeout(function () {
                try {
                  if (isElement(focusable)) {
                    if (!options.simulate) {
                      var fireEvent = fn.bind(null, focusable);
                      console.warn("[ui-test-queries] passing FocusEvent initilization prevents programmatic blur.\n        Test event handlers (with event initialization) and focus state behavior separately.\n        Note: this means that .focused will be true unless you call .blur without event initialization.");
                      resolve(fireEvent(init));
                    } else {
                      // We need to call Element.blur here because firing the FocusEvent doesn't actually move focus.
                      resolve(focusable.blur());
                    }
                  } else {
                    reject(new Error("[ui-test-queries] could not fire a 'blur' event on an element that is not 'focusable': ".concat(element)));
                  }
                } catch (e) {
                  /* istanbul ignore next */
                  reject(e);
                }
              }, 0);
            }));

          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _fireBlurEvent.apply(this, arguments);
}

function fireFocusEvent(_x10, _x11, _x12) {
  return _fireFocusEvent.apply(this, arguments);
}

function _fireFocusEvent() {
  _fireFocusEvent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(element, fn, init) {
    var options,
        focusable,
        _args4 = arguments;
    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            options = _args4.length > 3 && _args4[3] !== void 0 ? _args4[3] : {
              focusable: true,
              simulate: false
            };
            focusable = element;

            if (!options.focusable) {
              _context4.next = 6;
              break;
            }

            _context4.next = 5;
            return find(element, ':focusable');

          case 5:
            focusable = _context4.sent;

          case 6:
            if (focusable && typeof focusable.getDOMNode === 'function') {
              focusable = focusable.getDOMNode();
            }

            return _context4.abrupt("return", new Promise(function (resolve, reject) {
              setTimeout(function () {
                try {
                  if (isElement(focusable)) {
                    if (!init || options.simulate) {
                      // We need to call Element.focus here because firing the FocusEvent doesn't actually move focus.
                      resolve(focusable.focus());
                    } else {
                      var fireEvent = fn.bind(null, focusable);
                      console.warn("[ui-test-queries] passing FocusEvent initilization prevents programmatic focus.\n        Test event handlers (with event initialization) and focus state behavior separately.\n        Note: this means that .focused will be false unless you call .focus without event initialization.");
                      resolve(fireEvent(init));
                    }
                  } else {
                    reject(new Error("[ui-test-queries] could not fire a 'focus' event on an element that is not 'focusable': ".concat(element)));
                  }
                } catch (e) {
                  /* istanbul ignore next */
                  reject(e);
                }
              }, 0);
            }));

          case 8:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _fireFocusEvent.apply(this, arguments);
}

function fireKeyboardEvent(_x13, _x14, _x15, _x16) {
  return _fireKeyboardEvent.apply(this, arguments);
}

function _fireKeyboardEvent() {
  _fireKeyboardEvent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(element, fn, whichKey, init) {
    var options,
        focusable,
        keyCode,
        key,
        _args5 = arguments;
    return _regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            options = _args5.length > 4 && _args5[4] !== void 0 ? _args5[4] : {
              focusable: true
            };
            focusable = element;

            if (!options.focusable) {
              _context5.next = 6;
              break;
            }

            _context5.next = 5;
            return find(element, ':focusable');

          case 5:
            focusable = _context5.sent;

          case 6:
            if (focusable && typeof focusable.getDOMNode === 'function') {
              focusable = focusable.getDOMNode();
            }

            keyCode = typeof whichKey === 'string' ? keycode(whichKey) : whichKey;
            key = typeof whichKey === 'number' ? keycode(whichKey) : whichKey;
            return _context5.abrupt("return", new Promise(function (resolve, reject) {
              setTimeout(function () {
                try {
                  if (isElement(focusable)) {
                    var fireEvent = fn.bind(null, focusable);
                    resolve(fireEvent(_objectSpread({}, init, {
                      key: key,
                      which: keyCode,
                      keyCode: keyCode
                    })));
                  } else {
                    reject(new Error("[ui-test-queries] could not fire a ".concat(key, " event on an element that is not 'focusable': ").concat(element)));
                  }
                } catch (e) {
                  /* istanbul ignore next */
                  reject(e);
                }
              }, 0);
            }));

          case 10:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _fireKeyboardEvent.apply(this, arguments);
}
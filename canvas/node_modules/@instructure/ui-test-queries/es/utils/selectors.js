/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import Sizzle from 'sizzle';
import { parseQueryArguments } from "./parseQueryArguments.js";
import { firstOrNull } from "./firstOrNull.js";
import { elementToString } from "./elementToString.js";
import { tabbable, focusable, clickable, visible, exists } from "./helpers.js";
import { matchElementByTitle, matchElementByLabel, matchElementByText } from "./matchers.js";
Sizzle.selectors.cacheLength = 1;

function querySelectorAll() {
  var _parseQueryArguments = parseQueryArguments.apply(void 0, arguments),
      element = _parseQueryArguments.element,
      selector = _parseQueryArguments.selector,
      options = _parseQueryArguments.options;

  var results = [];

  if (selector) {
    results = findAllMatches(element, selector, options);
  } else {
    throwQueryError(element, selector);
  }

  return results;
}

function querySelector() {
  return firstOrNull(querySelectorAll.apply(void 0, arguments));
}

function querySelectorParents(element, selector, options) {
  var results = [];

  if (matchesSelector(element, selector)) {
    results.push(element);
  }

  var parentNode = element.parentNode;

  while (parentNode && parentNode !== document) {
    if (matchesSelector(parentNode, selector, options)) {
      results.push(parentNode);
    }

    parentNode = parentNode.parentNode;
  }

  return results;
}

function querySelectorFrames(element, selector, options) {
  return querySelectorAll(element, 'iframe').filter(function (frame) {
    return matchesSelector(frame, selector, options);
  }).map(function (frame) {
    var doc = null;

    try {
      doc = frame.contentDocument.documentElement;
    } catch (e) {
      console.warn("[ui-test-queries] could not find document element for iframe: ".concat(e));
    }

    return doc;
  }).filter(function (doc) {
    return doc !== null;
  });
}

function querySelectorAllWithin(containerSelector, element, selector, options) {
  // find all of the container root nodes...
  var containers = querySelectorAll(element, containerSelector, options);

  if (selector) {
    // if there is a selector, filter out containers that don't have a match inside...
    containers = containers.filter(function (container) {
      var results = querySelectorAll(container, selector).filter(function (result) {
        return firstOrNull(querySelectorParents(result, containerSelector, options)) === container;
      });
      return results.length > 0;
    });
  }

  return containers;
}

function matchesSelector() {
  var _parseQueryArguments2 = parseQueryArguments.apply(void 0, arguments),
      element = _parseQueryArguments2.element,
      selector = _parseQueryArguments2.selector,
      options = _parseQueryArguments2.options;

  if (element && selector) {
    return matches(element, selector, options);
  } else {
    throwQueryError(element, selector);
  }
}

function throwQueryError(element, selector) {
  throw new Error(["[ui-test-queries] Invalid query arguments:", "element: ".concat(elementToString(element, 7000, {
    highlight: false
  })), "selector: ".concat(JSON.stringify(selector))].filter(Boolean).join('\n'));
}

function findAllMatches(element, selector, options) {
  var results = [];

  if (matchesSelector(element, selector, options)) {
    results.push(element);
  }

  addPseudos(options);
  Sizzle(selector, element, results);

  if (options.ignore) {
    results = results.filter(function (result) {
      return !matchesSelector(result, options.ignore);
    });
  }

  results = results.filter(function (result) {
    return matchesSelector(result, ':exists');
  });
  return results;
}

function matches(element, selector, options) {
  addPseudos(options);
  return element && Sizzle.matchesSelector(element, selector);
}

function addPseudos() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    exact: true,
    trim: true,
    collapseWhitespace: true
  };
  var createPseudo = Sizzle.selectors.createPseudo; // :withLabel(text)

  Sizzle.selectors.pseudos.withLabel = createPseudo(function (text) {
    return function (element) {
      return matchElementByLabel(element, text, options);
    };
  });
  Sizzle.selectors.pseudos.label = Sizzle.selectors.pseudos.withLabel; // :withText(text)

  Sizzle.selectors.pseudos.withText = createPseudo(function (text) {
    return function (element) {
      return matchElementByText(element, text, options);
    };
  });
  Sizzle.selectors.pseudos.textContent = Sizzle.selectors.pseudos.withText; // :withTitle(text)

  Sizzle.selectors.pseudos.withTitle = createPseudo(function (text) {
    return function (element) {
      return matchElementByTitle(element, text, options);
    };
  });
  Sizzle.selectors.pseudos.title = Sizzle.selectors.pseudos.withTitle; // :clickable

  Sizzle.selectors.pseudos.clickable = function (element) {
    return clickable(element);
  }; // :focusable


  Sizzle.selectors.pseudos.focusable = function (element) {
    return focusable(element);
  }; // :tabbable


  Sizzle.selectors.pseudos.tabbable = function (element) {
    return tabbable(element);
  }; // :exists


  Sizzle.selectors.pseudos.exists = function (element) {
    return exists(element);
  }; // :visible


  Sizzle.selectors.pseudos.visible = function (element) {
    return visible(element);
  };
}

export { matchesSelector, querySelector, querySelectorAll, querySelectorParents, querySelectorAllWithin, querySelectorFrames };
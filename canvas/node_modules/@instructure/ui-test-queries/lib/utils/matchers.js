"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.matches = matches;
exports.matchElementByTitle = matchElementByTitle;
exports.matchElementByLabel = matchElementByLabel;
exports.matchElementByAttributeValue = matchElementByAttributeValue;
exports.matchElementByText = matchElementByText;

var _helpers = require("./helpers.js");

var _normalizeText = require("./normalizeText.js");

var _getNodeText = require("./getNodeText.js");

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
function matches(textToMatch, matcherString) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    exact: true,
    trim: true,
    collapseWhitespace: true
  };
  var exact = options.exact,
      collapseWhitespace = options.collapseWhitespace,
      trim = options.trim;
  var matcher = exact ? exactMatches : fuzzyMatches;
  return matcher(textToMatch, matcherString, {
    collapseWhitespace: collapseWhitespace,
    trim: trim
  });
}

function fuzzyMatches(textToMatch, matcher) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      _ref$collapseWhitespa = _ref.collapseWhitespace,
      collapseWhitespace = _ref$collapseWhitespa === void 0 ? true : _ref$collapseWhitespa,
      _ref$trim = _ref.trim,
      trim = _ref$trim === void 0 ? true : _ref$trim;

  if (typeof textToMatch !== 'string') {
    return false;
  }

  var normalizedText = (0, _normalizeText.normalizeText)(textToMatch, {
    trim: trim,
    collapseWhitespace: collapseWhitespace
  });

  if (typeof matcher === 'string') {
    return normalizedText.toLowerCase().includes(matcher.toLowerCase());
  } else {
    return matcher.test(normalizedText);
  }
}

function exactMatches(textToMatch, matcher) {
  var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      _ref2$collapseWhitesp = _ref2.collapseWhitespace,
      collapseWhitespace = _ref2$collapseWhitesp === void 0 ? true : _ref2$collapseWhitesp,
      _ref2$trim = _ref2.trim,
      trim = _ref2$trim === void 0 ? true : _ref2$trim;

  if (typeof textToMatch !== 'string') {
    return false;
  }

  var normalizedText = (0, _normalizeText.normalizeText)(textToMatch, {
    trim: trim,
    collapseWhitespace: collapseWhitespace
  });

  if (typeof matcher === 'string') {
    return normalizedText === matcher;
  } else {
    return matcher.test(normalizedText);
  }
}

function matchElementByTitle(element, titleText, options) {
  return matches((0, _helpers.title)(element), titleText, options);
}

function matchElementByLabel(element, labelText, options) {
  return matches((0, _helpers.label)(element), labelText, options);
}

function matchElementByText(element, text, options) {
  return matches((0, _getNodeText.getNodeText)(element), text, options);
}

function matchElementByAttributeValue(element, name, value, options) {
  return matches(element.getAttribute(name), value, options);
}
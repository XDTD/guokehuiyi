"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toString = toString;
exports.getId = getId;
exports.getOwnerWindow = getOwnerWindow;
exports.getOwnerDocument = getOwnerDocument;
exports.getComputedStyle = getComputedStyle;
exports.getTagName = getTagName;
exports.typeIn = typeIn;
exports.getAttribute = getAttribute;
exports.getDOMNode = getDOMNode;
exports.debug = debug;
exports.accessible = accessible;
exports.getTextContent = getTextContent;
exports.getParentNode = getParentNode;
exports.getBoundingClientRect = getBoundingClientRect;
exports.hasClass = hasClass;
exports.containsFocus = containsFocus;
exports.focused = focused;
exports.visible = visible;
exports.focusable = focusable;
exports.tabbable = tabbable;
exports.clickable = clickable;
exports.onscreen = onscreen;
exports.exists = exists;
exports.empty = empty;
exports.contains = contains;
exports.descendants = descendants;
exports.ancestors = ancestors;
exports.style = style;
exports.classNames = classNames;
exports.matches = matches;
exports.bounds = bounds;
exports.checked = checked;
exports.selected = selected;
exports.disabled = disabled;
exports.readonly = readonly;
exports.role = role;
exports.value = value;
exports.label = label;
exports.title = title;
exports.parents = exports.children = exports.id = exports.attribute = exports.text = exports.rect = exports.parent = exports.node = exports.tagName = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _uiAxeCheck = _interopRequireDefault(require("@instructure/ui-axe-check"));

var _elementToString = require("./elementToString.js");

var _events = require("./events.js");

var _isElement = require("./isElement.js");

var _selectors = require("./selectors.js");

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
function getOwnerDocument(element) {
  return element.ownerDocument || document;
}

function getOwnerWindow(element) {
  var doc = getOwnerDocument(element);
  return doc.defaultView || doc.parentWindow;
}

function typeIn(element, text, options) {
  var initialValue = element.value;
  var characterCount = text.length;
  var eventInit = {
    bubbles: true,
    cancelable: true,
    defaultPrevented: false,
    eventPhase: 2,
    isTrusted: true
  };
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      try {
        for (var i = 0; i < characterCount; ++i) {
          var code = text.charCodeAt(i);
          var keyEventData = (0, _objectSpread2.default)({
            altKey: false,
            charCode: code,
            ctrlKey: false,
            keyCode: code,
            metaKey: false,
            shiftKey: false,
            which: code
          }, eventInit);
          var inputEventData = (0, _objectSpread2.default)({
            charCode: code,
            target: {
              value: initialValue + text.slice(0, i + 1)
            }
          }, eventInit);

          _events.fireEvent.keyDown(element, keyEventData);

          _events.fireEvent.keyPress(element, keyEventData);

          _events.fireEvent.beforeInput(element, inputEventData);

          _events.fireEvent.input(element, inputEventData);

          _events.fireEvent.change(element, inputEventData);

          _events.fireEvent.keyUp(element, keyEventData);
        }

        resolve();
      } catch (err) {
        reject(err);
      }
    }, 0);
  });
}

function getTextContent(element) {
  if ((0, _selectors.matchesSelector)(element, 'input[type=submit], input[type=button]')) {
    return element.value;
  }

  return element.textContent;
} // aliases:


var text = getTextContent;
exports.text = text;

function getTagName(element) {
  return element.tagName.toLowerCase();
} // aliases


var tagName = getTagName;
exports.tagName = tagName;

function getComputedStyle(element) {
  if ((0, _isElement.isElement)(element)) {
    return getOwnerWindow(element).getComputedStyle(element);
  } else {
    throw new Error("[ui-test-queries] cannot get computed style for an invalid Element: ".concat(element));
  }
}

function positioned(element) {
  var style = getComputedStyle(element);
  var transform = style.getPropertyValue('-webkit-transform') || style.getPropertyValue('-moz-transform') || style.getPropertyValue('-ms-transform') || style.getPropertyValue('-o-transform') || style.getPropertyValue('transform') || 'none';
  return style.position !== 'static' || // initial value of transform can be 'none' or a matrix equivalent
  transform !== 'none' && transform !== 'matrix(1, 0, 0, 1, 0, 0)';
}

function getViewportRects(element) {
  var doc = getOwnerDocument(element);
  var win = getOwnerWindow(element);
  var viewport = {
    width: Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth, doc.body.offsetWidth, doc.documentElement.offsetWidth, doc.body.clientWidth, doc.documentElement.clientWidth, win.innerWidth || 0),
    height: Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight, doc.body.offsetHeight, doc.documentElement.offsetHeight, doc.body.clientHeight, doc.documentElement.clientHeight, win.innerHeight || 0)
  };
  return [(0, _objectSpread2.default)({}, viewport, {
    top: 0,
    right: viewport.width,
    bottom: viewport.height,
    left: 0,
    overflow: null,
    positioned: false
  })];
}

function getPositionedParents(element) {
  var parents = [];
  var parent = element; // eslint-disable-next-line no-cond-assign

  while ((parent = parent.parentNode) && parent && (0, _isElement.isElement)(parent) && parent.tagName.toLowerCase() !== 'body') {
    if (positioned(parent)) {
      parents.push(parent);
    }
  }

  return parents;
}

function rectToObject(rect) {
  return {
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    width: rect.width,
    height: rect.height,
    x: rect.x,
    y: rect.y
  };
}

function getClientRects(element) {
  var props = {
    overflow: getComputedStyle(element).overflow,
    positioned: positioned(element)
  };
  var rects = [(0, _objectSpread2.default)({}, rectToObject(element.getBoundingClientRect()), {}, props)];
  rects = rects.concat(Array.from(element.getClientRects()).map(function (rect) {
    return (0, _objectSpread2.default)({}, rectToObject(rect), {}, props);
  }));
  return rects;
}

function visible(element) {
  if (!(0, _isElement.isElement)(element) || element && element.tagName.toLowerCase() === 'html') {
    return true;
  }

  var style = getComputedStyle(element);

  if (style.visibility === 'hidden' || style.display === 'none' || style.opacity === '0') {
    return false;
  }

  var elementRects = getClientRects(element);
  var elementWidth = element.offsetWidth || elementRects[0].width || 0;
  var elementHeight = element.offsetHeight || elementRects[0].height || 0;
  var children = Array.from(element.childNodes); // handle inline elements with block children...

  if (element.tagName.toLowerCase() !== 'iframe' && style.display === 'inline' && children.length > 0 && children.filter(function (child) {
    return visible(child);
  }).length === 0) {
    return false;
  } else if (elementWidth <= 0 && elementHeight <= 0) {
    return false;
  }

  var rects = [elementRects].concat(getPositionedParents(element).map(function (parent) {
    return getClientRects(parent);
  }));
  rects.push(getViewportRects(element));
  return rects.reduce(function (previousIsVisible, childRects, index) {
    var parentRects = rects[index + 1];

    if (!parentRects) {
      return previousIsVisible;
    }

    return previousIsVisible && parentRects.reduce(function (visibleInPreviousParent, parentRect) {
      return visibleInPreviousParent || childRects.reduce(function (previousChildIsVisible, childRect) {
        var childIsPositioned = childRect.positioned && parentRect.overflow === 'visible';
        var currentChildIsVisible = childIsPositioned || childRect.top <= parentRect.bottom && childRect.top + parentRect.bottom >= 0 && childRect.bottom > parentRect.top && childRect.left <= parentRect.right && childRect.left + parentRect.right >= 0 && childRect.right > parentRect.left;
        return previousChildIsVisible || currentChildIsVisible;
      }, false);
    }, false);
  }, true);
}

function onscreen(element) {
  return visible(element);
}

function clickable(element) {
  var rects = Array.from(element.getClientRects()).concat(element.getBoundingClientRect());
  return visible(element) && rects.reduce(function (onscreen, rect) {
    if (onscreen) return true;
    var doc = getOwnerDocument(element);

    for (var x = Math.floor(rect.left), maxX = Math.ceil(rect.right); x <= maxX; x++) {
      for (var y = Math.floor(rect.top), maxY = Math.ceil(rect.bottom); y <= maxY; y++) {
        var elementFromPoint = doc.elementFromPoint(x, y);

        if (element.contains(elementFromPoint) || element === elementFromPoint) {
          return true;
        }
      }
    }

    return false;
  }, false);
}

function focusable(element) {
  var selector = ['a[href]:not([disabled])', 'frame', 'iframe', 'object', 'input:not([type=hidden]):not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', '*[tabindex]'];
  return !element.disabled && visible(element) && (0, _selectors.matchesSelector)(element, selector.join(','));
}

function tabbable(element) {
  return focusable(element) && parseInt(getAttribute(element, 'tabindex')) > 0;
}

function getAttribute(element) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return element.getAttribute.apply(element, args);
}

function getParentNode(element) {
  return element.parentNode;
}

var parent = getParentNode;
exports.parent = parent;

function containsFocus(element) {
  var activeElement = getOwnerDocument(element).activeElement;
  return element && (activeElement === element || element.contains(activeElement));
}

function focused(element) {
  return element === getOwnerDocument(element).activeElement;
}

function getDOMNode(element) {
  return element;
}

var node = getDOMNode;
exports.node = node;

function getBoundingClientRect(element) {
  return element.getBoundingClientRect();
}

var rect = getBoundingClientRect;
exports.rect = rect;

function hasClass(element, classname) {
  return element.classList.contains(classname);
}

function getId(element) {
  return element.id;
} // aliases:


var id = getId;
exports.id = id;

function debug() {
  // eslint-disable-next-line no-console
  console.log(toString.apply(void 0, arguments));
}

function toString() {
  return _elementToString.elementToString.apply(void 0, arguments);
}

function accessible() {
  var element = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document.body;
  var options = arguments.length > 1 ? arguments[1] : void 0;

  if ((0, _isElement.isElement)(element)) {
    return (0, _uiAxeCheck.default)(element, options);
  } else {
    throw new Error('[ui-test-queries] accessibility check can only run on a single, valid DOM Element!');
  }
}

function exists(element) {
  var doc = getOwnerDocument(element);
  return doc && doc.body.contains(element);
}

function empty(element) {
  if (element && element.value) {
    return element.value.length === 0 || !element.value.trim();
  } else if (element && element.children) {
    return element.children.length === 0;
  } else {
    throw new Error("[ui-test-queries] cannot determine if a non-element is empty: ".concat(toString(element)));
  }
}

function contains(element, elementOrSelector) {
  if (typeof elementOrSelector === 'string') {
    return (0, _selectors.querySelector)(element, elementOrSelector);
  } else if ((0, _isElement.isElement)(elementOrSelector)) {
    return element.contains(elementOrSelector);
  } else if (elementOrSelector && typeof elementOrSelector.getDOMNode === 'function') {
    return element.contains(elementOrSelector.getDOMNode());
  } else {
    return false;
  }
}

function descendants(element, selector) {
  return (0, _selectors.querySelectorAll)(element, selector).filter(function (match) {
    return match !== element;
  });
} // aliases:


var children = descendants;
exports.children = children;

function ancestors(element, selector) {
  var ancestors = [];
  var parentNode = element.parentNode;

  while (parentNode && parentNode !== document && (0, _isElement.isElement)(parentNode)) {
    if ((0, _selectors.matchesSelector)(parentNode, selector)) {
      ancestors.push(parentNode);
    }

    parentNode = parentNode.parentNode;
  }

  return ancestors;
} // aliases:


var parents = ancestors;
exports.parents = parents;
var attribute = getAttribute;
exports.attribute = attribute;

function style(element, property) {
  return getComputedStyle(element).getPropertyValue(property);
}

function classNames(element) {
  return Array.from(element.classList);
}

function matches(element, selector) {
  return (0, _selectors.matchesSelector)(element, selector);
}

function bounds(element, property) {
  return getBoundingClientRect(element).property;
}

function checked(element) {
  return element.checked || getAttribute(element, 'aria-checked');
}

function selected(element) {
  return element.selected || getAttribute(element, 'aria-selected');
}

function disabled(element) {
  return getAttribute(element, 'disabled') || getAttribute(element, 'aria-disabled');
}

function readonly(element) {
  return element.readonly || getAttribute(element, 'aria-readonly');
}

function role(element) {
  return getAttribute(element, 'role');
}

function value(element) {
  return element.value;
}

function label(element) {
  var doc = getOwnerDocument(element);

  if ((0, _selectors.matchesSelector)(element, '[aria-label]')) {
    return getAttribute(element, 'aria-label');
  } else if ((0, _selectors.matchesSelector)(element, '[aria-labelledby]')) {
    var ids = getAttribute(element, 'aria-labelledby').split(/\s+/);
    var labels = ids.map(function (id) {
      return doc.getElementById(id);
    });
    return labels.map(function (label) {
      return label ? label.textContent : '';
    }).join(' ');
  } else if ((0, _selectors.matchesSelector)(element, 'button, a[href], [role="button"], [role="link"]')) {
    return getTextContent(element);
  } else if ((0, _selectors.matchesSelector)(element, 'fieldset')) {
    var legend = (0, _selectors.querySelector)(element, 'legend');

    if (legend) {
      return getTextContent(legend);
    }
  } else if ((0, _selectors.matchesSelector)(element, '[id]')) {
    var _labels = Array.from((0, _selectors.querySelectorAll)(doc, "[for=\"".concat(getAttribute(element, 'id'), "\"]")));

    return _labels.map(function (label) {
      return label ? label.textContent : '';
    }).join(' ');
  } else if ((0, _selectors.matchesSelector)(element, 'input,textarea,select')) {
    var _labels2 = ancestors(element, 'label');

    if (_labels2.length > 0) {
      return getTextContent(_labels2[0]);
    }
  }
}

function title(element) {
  if ((0, _selectors.matchesSelector)(element, '[title]')) {
    return getAttribute(element, 'title');
  } else if ((0, _selectors.matchesSelector)(element, 'svg')) {
    var _title = (0, _selectors.querySelector)(element, 'title');

    if (_title) {
      return getTextContent(_title);
    }
  }
}
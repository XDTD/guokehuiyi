import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import { DateTime } from 'luxon';
import { translate } from '../constants/translated/translations';
import * as types from '../constants/ActionTypes';

var getDefaultFileName = function getDefaultFileName() {
  return "[".concat(translate('FILE_PLACEHOLDER'), " ").concat(new Date(DateTime.local()), "]");
};

export var audioDeviceChanged = function audioDeviceChanged(id) {
  return {
    type: types.AUDIO_DEVICE_CHANGED,
    id: id
  };
};
export var audioDeviceDisabled = function audioDeviceDisabled(id) {
  return {
    type: types.AUDIO_DEVICE_DISABLED
  };
};
export var cleanUp = function cleanUp() {
  return {
    type: types.CLEAN_UP
  };
};
export var closeClicked = function closeClicked() {
  return function (dispatch) {
    dispatch({
      type: types.CLOSE_CLICKED
    });
    dispatch(cleanUp());
  };
};
export var countdownComplete = function countdownComplete() {
  return {
    type: types.COUNTDOWN_COMPLETE
  };
};
export var finishClicked = function finishClicked() {
  return function (dispatch) {
    dispatch({
      type: types.FINISH_CLICKED,
      fileName: getDefaultFileName()
    });
    dispatch(cleanUp());
  };
};
export var onComplete = function onComplete() {
  return {
    type: types.ONCOMPLETE
  };
};
export var startClicked = function startClicked() {
  return {
    type: types.START_CLICKED
  };
};
export var startoverClicked = function startoverClicked() {
  return {
    type: types.STARTOVER_CLICKED
  };
};
export var titleEdited = function titleEdited(text) {
  return {
    type: types.TITLE_EDITED,
    text: text
  };
};
export var videoDeviceChanged = function videoDeviceChanged(id) {
  return {
    type: types.VIDEO_DEVICE_CHANGED,
    id: id
  };
};
export var videoDeviceDisabled = function videoDeviceDisabled() {
  return {
    type: types.VIDEO_DEVICE_DISABLED
  };
};
export var deviceRequestAccepted = function deviceRequestAccepted() {
  return {
    type: types.DEVICE_REQUEST_ACCEPTED
  };
};
export var mediaRecorderInitialized = function mediaRecorderInitialized(mr) {
  return {
    type: types.MEDIA_RECORDER_INITIALIZED,
    mr: mr
  };
};
export var videoObjectGenerated = function videoObjectGenerated(src, blob) {
  return {
    type: types.VIDEO_OBJECT_GENERATED,
    src: src,
    blob: blob
  };
};
export var errorOccurred = function errorOccurred(msg) {
  return {
    type: types.ERROR_OCCURRED,
    msg: msg
  };
};
export var devicesFound = function devicesFound(devices, currentVideoTrack) {
  return function (dispatch) {
    var selectedVideoTrack = null;

    if (currentVideoTrack) {
      var _devices$videoinput$f = devices.videoinput.filter(function (d) {
        return d.label === currentVideoTrack.label;
      });

      var _devices$videoinput$f2 = _slicedToArray(_devices$videoinput$f, 1);

      selectedVideoTrack = _devices$videoinput$f2[0];
    }

    dispatch({
      type: types.DEVICES_FOUND,
      devices: devices,
      selectedVideoId: selectedVideoTrack ? selectedVideoTrack.deviceId : '',
      selectedAudioId: getDefaultAudioDeviceId(devices.audioinput)
    });
  };
}; // NOTE: it will drop default audioDevice if the related physical device is present

function getDefaultAudioDeviceId(audioDevices) {
  if (audioDevices.length === 0) return '';
  var defaultAudioDeviceId = 'default';
  var defaultAudioDeviceIndex = audioDevices.findIndex(function (d) {
    return d.deviceId === defaultAudioDeviceId;
  });
  if (defaultAudioDeviceIndex === -1) return audioDevices[0].deviceId;
  var defaultAudioDevice = audioDevices[defaultAudioDeviceIndex];
  var defaultPhysicalAudioDevice = audioDevices.find(function (d) {
    return d.deviceId !== defaultAudioDeviceId && d.groupId === defaultAudioDevice.groupId;
  });
  if (!defaultPhysicalAudioDevice) return defaultAudioDevice.deviceId;
  audioDevices.splice(defaultAudioDeviceIndex, 1);
  return defaultPhysicalAudioDevice.deviceId;
}

export var soundMeterInitialized = function soundMeterInitialized(sm) {
  return {
    type: types.SOUND_METER_INITIALIZED,
    sm: sm
  };
};
export var saveClicked = function saveClicked(fileName) {
  return function (dispatch) {
    if (fileName.length === 0) {
      dispatch({
        type: types.SAVE_CLICKED,
        fileName: getDefaultFileName()
      });
    } else {
      dispatch({
        type: types.SAVE_CLICKED,
        fileName: fileName
      });
    }

    dispatch(onComplete());
  };
};
export var trackEnded = function trackEnded() {
  return function (dispatch) {
    dispatch({
      type: types.TRACK_ENDED,
      fileName: getDefaultFileName()
    });
    dispatch(cleanUp());
  };
};
export var systemAudioAllowedChanged = function systemAudioAllowedChanged(allowed) {
  return {
    type: types.SYSTEM_AUDIO_ALLOWED_CHANGED,
    allowed: allowed
  };
};
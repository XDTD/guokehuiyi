"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFileType = getFileType;
exports.startMediaRecorder = startMediaRecorder;
exports.default = exports.AUDIO_FILE_TYPE = exports.VIDEO_FILE_TYPE = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _tsEbml = require("ts-ebml");

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var VIDEO_FILE_TYPE = 'video/webm; codecs="vp8, opus"';
exports.VIDEO_FILE_TYPE = VIDEO_FILE_TYPE;
var AUDIO_FILE_TYPE = 'audio/webm; codecs="opus"'; // for testing only

exports.AUDIO_FILE_TYPE = AUDIO_FILE_TYPE;

function getFileType(requestAudioOnly) {
  return requestAudioOnly ? AUDIO_FILE_TYPE : VIDEO_FILE_TYPE;
}

function startMediaRecorder(stream, onMediaRecorderInit, success, error) {
  var requestAudioOnly = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var FILE_TYPE = getFileType(requestAudioOnly);
  var mediaFile = new MediaFile(stream, FILE_TYPE, success, error);
  onMediaRecorderInit(mediaFile.mediaRecorder);
  mediaFile.mediaRecorder.start(10);
}

var MediaFile = function MediaFile(stream, fileType, fileSuccess, fileError) {
  var _this = this;

  (0, _classCallCheck2.default)(this, MediaFile);

  this.addToChunks = function (e) {
    _this.chunks.push(e.data);

    var task = function task() {
      return _this.readAsArrayBuffer(e.data).then(function (buf) {
        var elms = _this.decoder.decode(buf).filter(function (elm) {
          return elm.type !== "unknown";
        });

        elms.forEach(function (elm) {
          _this.reader.read(elm);
        });
      }).catch(function (e) {
        _this.onError(e);
      });
    };

    return _this.tasks.then(function () {
      return task();
    });
  };

  this.readAsArrayBuffer = function (blob) {
    return new Promise(function (resolve, reject) {
      var reader = new FileReader(); // eslint-disable-line compat/compat

      reader.readAsArrayBuffer(blob);

      reader.onloadend = function () {
        resolve(reader.result);
      };

      reader.onerror = function (ev) {
        reject(ev.error);
      };
    });
  };

  this.onError = function (e) {
    _this.fileError(e);
  };

  this.cleanUp = function () {
    _this.stream = null;
    _this.fileType = null;
    _this.fileSuccess = null;
    _this.fileError = null;
    _this.tasks = null;
    _this.decoder = null;
    _this.reader = null;
    _this.chunks = null;
    _this.mediaRecorder = null;
  };

  this.onStop = /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
    var webM, webMBuf, refinedMetadataBuf, body;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return _this.tasks;

          case 3:
            webM = new Blob(_this.chunks, {
              type: _this.fileType
            });

            if (!(_this.chunks && _this.chunks[0].type !== 'audio/ogg')) {
              _context.next = 11;
              break;
            }

            _context.next = 7;
            return _this.readAsArrayBuffer(webM);

          case 7:
            webMBuf = _context.sent;
            refinedMetadataBuf = _tsEbml.tools.makeMetadataSeekable(_this.reader.metadatas, _this.reader.duration, _this.reader.cues);
            body = webMBuf.slice(_this.reader.metadataSize);
            webM = new Blob([refinedMetadataBuf, body], {
              type: _this.fileType
            });

          case 11:
            _this.fileSuccess(webM);

            _context.next = 17;
            break;

          case 14:
            _context.prev = 14;
            _context.t0 = _context["catch"](0);

            _this.onError(_context.t0);

          case 17:
            _context.prev = 17;

            _this.cleanUp();

            return _context.finish(17);

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 14, 17, 20]]);
  }));
  this.stream = stream;
  this.fileType = fileType;
  this.fileSuccess = fileSuccess;
  this.fileError = fileError;
  this.tasks = Promise.resolve();
  this.decoder = new _tsEbml.Decoder();
  this.reader = new _tsEbml.Reader();
  this.chunks = []; // eslint-disable-next-line compat/compat

  this.mediaRecorder = new MediaRecorder(stream, {
    mimeType: this.fileType
  });
  this.mediaRecorder.ondataavailable = this.addToChunks;
  this.mediaRecorder.onerror = this.onError;
  this.mediaRecorder.onstop = this.onStop;
};

var _default = MediaFile;
exports.default = _default;
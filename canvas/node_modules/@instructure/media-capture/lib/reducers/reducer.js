"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInitialState = getInitialState;
exports.reducer = reducer;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _ActionTypes = require("../constants/ActionTypes");

var _CaptureStates = require("../constants/CaptureStates");

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
function getInitialState(onCompleted, onCancel) {
  return {
    captureState: _CaptureStates.LOADING,
    hasStarted: false,
    videoSrc: '',
    videoBlob: '',
    msg: '',
    devices: {
      audioinput: [],
      videoinput: []
    },
    audioDeviceId: '',
    videoDeviceId: '',
    requestAudioOnly: false,
    fileName: '',
    onCompleted: onCompleted,
    onCancel: onCancel,
    systemAudioAllowed: true
  };
}

function reducer(state, action) {
  switch (action.type) {
    case _ActionTypes.AUDIO_DEVICE_CHANGED:
      return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
        audioDeviceId: action.id
      });

    case _ActionTypes.AUDIO_DEVICE_DISABLED:
      return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
        audioDeviceId: ''
      });

    case _ActionTypes.SOUND_METER_INITIALIZED:
      return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
        soundMeter: action.sm
      });

    case _ActionTypes.CLEAN_UP:
      {
        state.soundMeter && state.soundMeter.stop();
        state.mediaRecorder && state.mediaRecorder.state !== 'inactive' && state.mediaRecorder.stop();
        return state;
      }

    case _ActionTypes.CLOSE_CLICKED:
      if ([_CaptureStates.READY, _CaptureStates.STARTING, _CaptureStates.RECORDING, _CaptureStates.PREVIEWSAVE].includes(state.captureState)) {
        return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
          captureState: _CaptureStates.READY
        });
      } else {
        return state;
      }

    case _ActionTypes.COUNTDOWN_COMPLETE:
      if (state.captureState !== _CaptureStates.STARTING) {
        return state;
      }

      return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
        captureState: _CaptureStates.RECORDING
      });

    case _ActionTypes.DEVICE_REQUEST_ACCEPTED:
      return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
        captureState: _CaptureStates.READY
      });

    case _ActionTypes.DEVICES_FOUND:
      return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
        devices: action.devices,
        audioDeviceId: action.selectedAudioId,
        videoDeviceId: action.selectedVideoId
      });

    case _ActionTypes.ERROR_OCCURRED:
      return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
        msg: action.msg,
        captureState: _CaptureStates.ERROR
      });

    case _ActionTypes.FINISH_CLICKED:
      {
        if (state.captureState !== _CaptureStates.RECORDING) {
          return state;
        }

        return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
          fileName: action.fileName,
          captureState: _CaptureStates.PREVIEWSAVE
        });
      }

    case _ActionTypes.ONCOMPLETE:
      {
        if (![_CaptureStates.SAVING, _CaptureStates.FINISHED].includes(state.captureState)) {
          return state;
        }

        var type = state.requestAudioOnly ? 'audio/webm' : 'video/webm';
        state.onCompleted(new File([state.videoBlob], state.fileName, {
          type: type
        }), state.videoSrc); // eslint-disable-line compat/compat

        return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
          soundMeter: state.soundMeter,
          captureState: _CaptureStates.FINISHED
        });
      }

    case _ActionTypes.MEDIA_RECORDER_INITIALIZED:
      return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
        mediaRecorder: action.mr
      });

    case _ActionTypes.SAVE_CLICKED:
      if (state.captureState !== _CaptureStates.PREVIEWSAVE) {
        return state;
      }

      return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
        fileName: action.fileName,
        captureState: _CaptureStates.SAVING
      });

    case _ActionTypes.START_CLICKED:
      if (state.captureState !== _CaptureStates.READY) {
        return state;
      }

      return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
        hasStarted: true,
        captureState: _CaptureStates.STARTING
      });

    case _ActionTypes.STARTOVER_CLICKED:
      if (![_CaptureStates.RECORDING, _CaptureStates.PREVIEWSAVE, _CaptureStates.FINISHED].includes(state.captureState)) {
        return state;
      }

      state.mediaRecorder && state.mediaRecorder.state !== 'inactive' && state.mediaRecorder.stop();
      return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, getInitialState(state.onCompleted, state.onCancel)), {}, {
        hasStarted: state.hasStarted,
        devices: state.devices,
        audioDeviceId: state.audioDeviceId,
        videoDeviceId: state.videoDeviceId,
        soundMeter: state.soundMeter,
        captureState: state.captureState === _CaptureStates.PREVIEWSAVE ? _CaptureStates.LOADING : _CaptureStates.READY
      });

    case _ActionTypes.TITLE_EDITED:
      return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
        title: action.text
      });

    case _ActionTypes.VIDEO_DEVICE_CHANGED:
      return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
        requestAudioOnly: false,
        videoDeviceId: action.id
      });

    case _ActionTypes.VIDEO_DEVICE_DISABLED:
      return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
        requestAudioOnly: true,
        videoDeviceId: ''
      });

    case _ActionTypes.VIDEO_OBJECT_GENERATED:
      return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
        videoSrc: action.src,
        videoBlob: action.blob
      });

    case _ActionTypes.TRACK_ENDED:
      switch (state.captureState) {
        case _CaptureStates.RECORDING:
          return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
            fileName: action.fileName,
            captureState: _CaptureStates.PREVIEWSAVE
          });

        default:
          if (typeof state.onCancel === 'function') state.onCancel();
          return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
            captureState: _CaptureStates.FINISHED
          });
      }

    case _ActionTypes.SYSTEM_AUDIO_ALLOWED_CHANGED:
      return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, state), {}, {
        systemAudioAllowed: action.allowed
      });

    default:
      return state;
  }
}
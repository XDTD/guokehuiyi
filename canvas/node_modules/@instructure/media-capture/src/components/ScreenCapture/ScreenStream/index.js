/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import React, { Component } from 'react'
import themeable from '@instructure/ui-themeable'
import { bindActionCreators } from 'redux'
import { connect } from 'react-redux'
import * as CaptureActions from '../../../actions'
import { getScreenMediaStreams, getWebcamStream, enumerateDevices, getUserMedia } from '../../../core/mediaDevices'
import StreamMerger from '../../../core/StreamMerger'
import { startMediaRecorder } from '../../../core/mediaRecorder'
import { LOADING, RECORDING } from '../../../constants/CaptureStates'
import { translate } from '../../../constants/translated/translations'

import styles from './styles.css'

const FRAME_RATE = 25

const CONFIG = {
  desktop: {
    video: {
      frameRate: FRAME_RATE,
      resizeMode: 'none'
    },
    audio: {
      gain: 0.5
    }
  },
  webcam: {
    video: {
      width: 200,
      height: 200,
      position: {
        x: 1280 - 200 - 24,
        y: 720 - 200 - 24
      },
      frameRate: FRAME_RATE,
      resizeMode: 'none'
    },
    audio: {
      muted: false,
      gain: 1.0
    },
  }
}

/**
---
private: true
---
**/
@themeable({}, styles)
class ScreenStream extends Component {
  constructor (props) {
    super(props)
    this.state = {recording: false, cancelled: false}
  }

  componentDidMount () {
    this.rawStreams = {}
    this.startStream()
    this.captureStreamMerger = new StreamMerger(this.canvas, FRAME_RATE)
  }

  async startStream () {
    try {
      getUserMedia() // we ask for cam and mic permissions
      const streams = await getScreenMediaStreams({
        audioDeviceId: this.props.audioDeviceId,
        videoDeviceId: this.props.videoDeviceId,
        webcamVideoConfig: CONFIG.webcam.video,
        desktopVideoConfig: CONFIG.desktop.video
      })

      if (!streams.desktopStream) {
        this.setState({cancelled: true})
        return
      }
      streams.desktopStream.getVideoTracks()[0].onended = this.props.actions.trackEnded

      this.rawStreams = {
        desktopStream: streams.desktopStream,
        webcamStream: streams.webcamStream
      }

      this.updateStreams()
      this.streamSuccess()
    } catch (e) {
      this.handleError(e)
    }
  }

  handleError = (err) => {
    if (!err || typeof this.props.actions.errorOccurred !== 'function') {
      return
    }

    this.props.actions.errorOccurred(translate('SCREEN_DEFAULT_ERROR'))
  }

  updateStreams() {
    const inputStreams = []
    if (this.rawStreams.desktopStream) {
      inputStreams.push({
        stream: this.rawStreams.desktopStream,
        videoConfig: CONFIG.desktop.video,
        audioConfig: {
          gain: CONFIG.desktop.audio.gain,
          muted: !this.props.systemAudioAllowed
        }
      })
    }
    if (this.rawStreams.webcamStream) {
      inputStreams.push({
        stream: this.rawStreams.webcamStream,
        videoConfig: CONFIG.webcam.video,
        audioConfig: {
          gain: CONFIG.webcam.audio.gain,
          muted: !this.props.audioDeviceId
        }
      })
    }

    this.recordStream = this.captureStreamMerger.mergeStreams(inputStreams)
  }

  streamSuccess = () => {
    enumerateDevices(this.deviceSuccess, this.handleError)
    this.streamLoaded()
  }

  deviceSuccess = (types) => {
    const [videoTrack] = this.rawStreams.desktopStream.getVideoTracks()
    this.props.actions.devicesFound(types, videoTrack)
  }

  streamLoaded = () => {
    this.props.captureState === LOADING && this.props.actions.deviceRequestAccepted()
  }

  shouldComponentUpdate (nextProps, nextState) {
    return (
      this.state.cancelled !== nextState.cancelled ||
      this.props.captureState !== nextProps.captureState ||
      this.isDeviceChanged(nextProps.audioDeviceId, nextProps.videoDeviceId) ||
      this.isSystemAudioAllowedChanged(nextProps.systemAudioAllowed)
    )
  }

  isDeviceChanged = (audioId, videoId) => {
    return this.isAudioDeviceChanged(audioId) || this.isVideoDeviceChanged(videoId)
  }

  isAudioDeviceChanged = audioId => {
    return this.props.audioDeviceId !== audioId
  }

  isVideoDeviceChanged = videoId => {
    return this.props.videoDeviceId !== videoId
  }

  isSystemAudioAllowedChanged = newValue => {
    return this.props.systemAudioAllowed !== newValue
  }


  componentDidUpdate (prevProps) {
    if (this.state.cancelled) {
      this.props.actions.trackEnded()
      return
    }

    if (this.isVideoDeviceChanged(prevProps.videoDeviceId)) {
      this.handleVideoChange()
    }

    if (this.isAudioDeviceChanged(prevProps.audioDeviceId)) {
      this.handleAudioChange()
    }

    if (this.isSystemAudioAllowedChanged(prevProps.systemAudioAllowed)) {
      this.handleSystemAudioAllowedChange()
    }

    if (!this.shouldStartRecorder()) return
    startMediaRecorder(
      this.recordStream,
      this.onMediaRecorderInit,
      this.blobSuccess,
      this.handleError
    )
    this.setState({recording: true})
  }

  async handleVideoChange () {
    await this.updateWebcamStream()
  }

  async handleAudioChange () {
    await this.updateWebcamStream()
  }

  async updateWebcamStream() {
    const newWebcamStream = await getWebcamStream({
      audioDeviceId: this.props.audioDeviceId,
      videoDeviceId: this.props.videoDeviceId,
      webcamVideoConfig: CONFIG.webcam.video
    })

    this.stopStreamTracks(this.rawStreams.webcamStream)
    if (!newWebcamStream) {
      delete this.rawStreams.webcamStream
    } else {
      this.rawStreams.webcamStream = newWebcamStream
    }

    this.updateStreams()
  }

  async handleSystemAudioAllowedChange () {
    this.updateStreams()
  }

  shouldStartRecorder () {
    return !this.state.recording && this.recordStream && this.props.captureState === RECORDING
  }

  onMediaRecorderInit = (mediaRecorder) => {
    this.props.actions.mediaRecorderInitialized(mediaRecorder)
  }

  blobSuccess = (blob) => {
    // eslint-disable-next-line compat/compat
    const src = window.URL.createObjectURL(blob)
    this.props.actions.videoObjectGenerated(src, blob)
  }

  componentWillUnmount () {
    this.setState({recording: false})
    if (this.captureStreamMerger) this.captureStreamMerger.stop()
    this.stopStreamTracks(this.recordStream)
    this.stopRawStreamTracks()
  }

  stopRawStreamTracks () {
    Object.values(this.rawStreams).forEach(this.stopStreamTracks)
  }

  stopStreamTracks (stream) {
    if (!stream || typeof stream.getTracks !== 'function') return
    stream.getTracks().forEach(track => track.stop())
  }

  render () {
    return (
      <div>
        <canvas
          className={styles.canvas}
          tabIndex="-1"
          width="1280"
          height="720"
          ref={el => { this.canvas = el }}
        />
      </div>
    )
  }
}

const mapStateToProps = state => ({
  captureState: state.captureState,
  audioDeviceId: state.audioDeviceId,
  videoDeviceId: state.videoDeviceId,
  systemAudioAllowed: state.systemAudioAllowed,
  fileName: state.fileName
})

const mapDispatchToProps = dispatch => ({
  actions: bindActionCreators(CaptureActions, dispatch)
})

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(ScreenStream)

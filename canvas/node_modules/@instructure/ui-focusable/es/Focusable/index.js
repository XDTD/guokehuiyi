import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";
import { warn as _warn } from "@instructure/console";

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import { Component } from 'react';
import PropTypes from 'prop-types';
import { addInputModeListener, addEventListener, containsActiveElement, findFocusable } from '@instructure/ui-dom-utils';

/**
---
category: components/utilities
---
**/
var Focusable = /*#__PURE__*/function (_Component) {
  _inherits(Focusable, _Component);

  var _super = _createSuper(Focusable);

  function Focusable() {
    var _this;

    _classCallCheck(this, Focusable);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this._focusListener = null;
    _this._blurListener = null;
    _this._inputModeListener = null;
    _this.state = {
      focused: false,
      focusable: false
    };

    _this.handleInputModeChange = function () {
      _this.forceUpdate();
    };

    _this.handleFocus = function (event) {
      _this.removeFocusListener();

      _this.setState({
        focused: true
      });
    };

    _this.handleBlur = function (event) {
      _this.removeBlurListener();

      _this.setState({
        focused: false
      });
    };

    return _this;
  }

  _createClass(Focusable, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var focusable = this.focusable,
          focused = this.focused;
      this.addFocusableListeners(focusable, focused);
      this._inputModeListener = addInputModeListener({
        onInputModeChange: this.handleInputModeChange
      });
      this.setState({
        focusable: focusable,
        focused: focused
      });
    }
  }, {
    key: "getSnapshotBeforeUpdate",
    value: function getSnapshotBeforeUpdate(prevProps, prevState) {
      var _this$props = this.props,
          render = _this$props.render,
          children = _this$props.children; // prevent blur from firing when focusable element is replaced

      if (prevProps.children !== children || prevProps.render !== render) {
        this.removeFocusableListeners();
      }

      return null;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var focusable = this.focusable;

      if (!focusable && this.state.focusable) {
        this.removeFocusableListeners();
        this.setState({
          focusable: false,
          focused: false
        });
      } else if (focusable !== this.state.focusable) {
        this.removeFocusableListeners();

        if (this.state.focused) {
          focusable.focus();
        }

        this.addFocusableListeners(focusable, this.state.focused);
        this.setState({
          focusable: focusable
        });
      } else {
        this.addFocusableListeners(focusable, this.state.focused);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this._inputModeListener) {
        this._inputModeListener.remove();

        this._inputModeListener = null;
      }

      this.removeFocusableListeners();
    }
  }, {
    key: "addFocusableListeners",
    value: function addFocusableListeners(focusable, focused) {
      if (!focusable) return;

      if (focused && !this._blurListener) {
        this._blurListener = addEventListener(focusable, 'blur', this.handleBlur, true);
      } else if (!this._focusListener) {
        this._focusListener = addEventListener(focusable, 'focus', this.handleFocus, true);
      }
    }
  }, {
    key: "removeFocusableListeners",
    value: function removeFocusableListeners() {
      this.removeFocusListener();
      this.removeBlurListener();
    }
  }, {
    key: "removeFocusListener",
    value: function removeFocusListener() {
      if (this._focusListener) {
        this._focusListener.remove();

        this._focusListener = null;
      }
    }
  }, {
    key: "removeBlurListener",
    value: function removeBlurListener() {
      if (this._blurListener) {
        this._blurListener.remove();

        this._blurListener = null;
      }
    }
  }, {
    key: "focus",
    value: function focus() {
      var focusable = this.focusable;

      if (focusable) {
        focusable.focus();
      }
    }
  }, {
    key: "isFocusVisible",
    value: function isFocusVisible(focusable, focused) {
      if (!focusable || !focused) return false; // always show focus for keyboard input mode

      if (this._inputModeListener && this._inputModeListener.isKeyboardMode()) return true;
      var tagName = focusable.tagName,
          type = focusable.type,
          isContentEditable = focusable.isContentEditable;

      if (tagName == 'INPUT' && Focusable.inputTypes[type]) {
        return true;
      }

      if (tagName == 'TEXTAREA') {
        return true;
      }

      if (isContentEditable) {
        return true;
      }

      return false;
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          children = _this$props2.children,
          _this$props2$render = _this$props2.render,
          render = _this$props2$render === void 0 ? children : _this$props2$render;
      var _this$state = this.state,
          focusable = _this$state.focusable,
          focused = _this$state.focused;

      if (typeof render === 'function') {
        return render({
          focused: focused,
          focusable: focusable,
          focusVisible: this.isFocusVisible(focusable, focused)
        });
      } else {
        return null;
      }
    }
  }, {
    key: "focused",
    get: function get() {
      return containsActiveElement(this);
    }
  }, {
    key: "focusable",
    get: function get() {
      var focusable = findFocusable(this, function () {
        return true;
      }, true) || [];
      var focusableCount = focusable && focusable.length || 0;

      /*#__PURE__*/

      /*#__PURE__*/
      _warn(focusableCount === 1, "[Focusable] Exactly one focusable child is required (".concat(focusableCount, " found)."));

      focusable = focusable ? focusable[0] : false;

      if (focusable && typeof focusable.focus === 'function') {
        return focusable;
      } else {
        return false;
      }
    }
  }, {
    key: "focusVisible",
    get: function get() {
      var _this$state2 = this.state,
          focusable = _this$state2.focusable,
          focused = _this$state2.focused;
      return this.isFocusVisible(focusable, focused);
    }
  }]);

  Focusable.displayName = "Focusable";
  return Focusable;
}(Component);

Focusable.propTypes = {
  /**
   * @param {Object} renderProps
   * @param {Boolean} renderProps.focused - Is the element focused (via keyboard only)?
   * @param {HTMLElement} renderProps.focusable - The focusable element
   * @param {Boolean} renderProps.focusVisible - Whether the focus state should be visible or not
   */
  children: PropTypes.func,

  /**
   * Identical to children
   */
  render: PropTypes.func
};
Focusable.defaultProps = {
  children: null,
  render: void 0
};
Focusable.inputTypes = {
  text: true,
  search: true,
  url: true,
  tel: true,
  email: true,
  password: true,
  number: true,
  date: true,
  month: true,
  week: true,
  time: true,
  datetime: true,
  'datetime-local': true
};
export default Focusable;
export { Focusable };
export { default as FocusableView } from "../FocusableView/index.js";
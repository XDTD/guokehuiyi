import * as React from 'react';

export type ModalSize = "auto" | "small" | "medium" | "large" | "fullscreen";

export type ModalVariant = "default" | "inverse";

export type ModalDefaultFocusElement = React.ReactElement<any> | ((...args: any[])=>any);

export type ModalMountNode = any | ((...args: any[])=>any);

export type ModalInsertAt = "bottom" | "top";

export type ModalLiveRegion = React.ReactElement<any>[] | React.ReactElement<any> | ((...args: any[])=>any);

export type ModalConstrain = "window" | "parent";

export type ModalOverflow = "scroll" | "fit";

export interface ModalProps {
    /**
     * An accessible label for the `<Modal />` content
     */
    label: string;
    /**
     * The children to be rendered within the `<Modal />`
     */
    children?: any;
    /**
     * The size of the `<Modal />` content
     */
    size?: ModalSize;
    /**
     * Designates the background style of the `<Modal />`
     */
    variant?: ModalVariant;
    /**
     * Whether or not the `<Modal />` is open
     */
    open?: boolean;
    /**
     * An element or a function returning an element to focus by default
     */
    defaultFocusElement?: ModalDefaultFocusElement;
    /**
     * Whether focus should be returned to the trigger when the `<Modal/>` is closed
     */
    shouldReturnFocus?: boolean;
    /**
     * Whether the `<Modal/>` should request close when the document is clicked
     */
    shouldCloseOnDocumentClick?: boolean;
    /**
     * Callback fired when `<Modal />` content has been mounted in the DOM
     */
    onOpen?: (...args: any[])=>any;
    /**
     * Callback fired when `<Modal />` has been unmounted from the DOM
     */
    onClose?: (...args: any[])=>any;
    /**
     * Callback fired when the `<Modal />` is requesting to be closed
     */
    onDismiss?: (...args: any[])=>any;
    /**
     * A function that returns a reference to the content element
     */
    contentRef?: (...args: any[])=>any;
    /**
     * An element or a function returning an element to use as the mount node
     * for the `<Modal />` (defaults to `document.body`)
     */
    mountNode?: ModalMountNode;
    /**
     * Insert the element at the 'top' of the mountNode or at the 'bottom'
     */
    insertAt?: ModalInsertAt;
    /**
     * An element, function returning an element, or array of elements that will not be hidden from
     * the screen reader when the `<Modal />` is open
     */
    liveRegion?: ModalLiveRegion;
    transition?: any;
    /**
     * Callback fired before the <Modal /> transitions in
     */
    onEnter?: (...args: any[])=>any;
    /**
     * Callback fired as the <Modal /> begins to transition in
     */
    onEntering?: (...args: any[])=>any;
    /**
     * Callback fired after the <Modal /> finishes transitioning in
     */
    onEntered?: (...args: any[])=>any;
    /**
     * Callback fired right before the <Modal /> transitions out
     */
    onExit?: (...args: any[])=>any;
    /**
     * Callback fired as the <Modal /> begins to transition out
     */
    onExiting?: (...args: any[])=>any;
    /**
     * Callback fired after the <Modal /> finishes transitioning out
     */
    onExited?: (...args: any[])=>any;
    /**
     * Constrain the Modal to the document window or its closest positioned parent
     */
    constrain?: ModalConstrain;
    /**
     * Should ModalBody handle overflow with scrollbars, or fit its
     * content within its own height?
     */
    overflow?: ModalOverflow;
}

export class Modal extends React.Component<ModalProps, any> {
    render(): JSX.Element;

}




export type MaskPlacement = "top" | "center" | "bottom" | "stretch";

export interface MaskProps {
    onDismiss?: (...args: any[])=>any;
    placement?: MaskPlacement;
    fullscreen?: boolean;
    children?: React.ReactNode;
    onClick?: (...args: any[])=>any;
    elementRef?: (...args: any[])=>any;
}

export class Mask extends React.Component<MaskProps, any> {
    render(): JSX.Element;

}




export type OverlayMountNode = any | ((...args: any[])=>any);

export type OverlayInsertAt = "bottom" | "top";

export type OverlayDefaultFocusElement = React.ReactElement<any> | ((...args: any[])=>any);

export type OverlayApplicationElement = React.ReactElement<any>[] | React.ReactElement<any> | ((...args: any[])=>any);

export type OverlayContentElement = React.ReactElement<any> | ((...args: any[])=>any);

export interface OverlayProps {
    children?: React.ReactNode;
    /**
     * Whether or not the `<Overlay />` is open
     */
    open?: boolean;
    /**
     * Callback fired when `<Portal />` content has been mounted in the DOM
     */
    onOpen?: (...args: any[])=>any;
    /**
     * Callback fired when `<Portal />` has been unmounted from the DOM
     */
    onClose?: (...args: any[])=>any;
    /**
     * An element or a function returning an element to use as the mount node
     * for the `<Portal />` (defaults to `document.body`)
     */
    mountNode?: OverlayMountNode;
    /**
     * Insert the element at the 'top' of the mountNode or at the 'bottom'
     */
    insertAt?: OverlayInsertAt;
    /**
     * An accessible label for the `<Overlay />` content
     */
    label: string;
    /**
     * Callback fired when the `<Overlay />` is requesting to be closed
     */
    onDismiss?: (...args: any[])=>any;
    /**
     * An element or a function returning an element to focus by default
     */
    defaultFocusElement?: OverlayDefaultFocusElement;
    /**
     * An element or a function returning an element to apply `aria-hidden` to
     */
    applicationElement?: OverlayApplicationElement;
    /**
     * An element or a function returning an element that wraps the content of the `<Overlay />`
     */
    contentElement?: OverlayContentElement;
    shouldContainFocus?: boolean;
    shouldReturnFocus?: boolean;
    shouldCloseOnDocumentClick?: boolean;
    shouldCloseOnEscape?: boolean;
    /**
     * The type of `<Transition />` to use for animating in/out
     */
    transition?: any;
    /**
     * Show the component; triggers the enter or exit animation
     */
    in?: boolean;
    /**
     * Unmount the component (remove it from the DOM) when it is not shown
     */
    unmountOnExit?: boolean;
    /**
     * Run the enter animation when the component mounts, if it is initially
     * shown
     */
    transitionOnMount?: boolean;
    /**
     * Run the enter animation
     */
    transitionEnter?: boolean;
    /**
     * Run the exit animation
     */
    transitionExit?: boolean;
    /**
     * Callback fired before the "entering" classes are applied
     */
    onEnter?: (...args: any[])=>any;
    /**
     * Callback fired after the "entering" classes are applied
     */
    onEntering?: (...args: any[])=>any;
    /**
     * Callback fired after the "enter" classes are applied
     */
    onEntered?: (...args: any[])=>any;
    /**
     * Callback fired before the "exiting" classes are applied
     */
    onExit?: (...args: any[])=>any;
    /**
     * Callback fired after the "exiting" classes are applied
     */
    onExiting?: (...args: any[])=>any;
    /**
     * Callback fired after the "exited" classes are applied
     */
    onExited?: (...args: any[])=>any;
}

export class Overlay extends React.Component<OverlayProps, any> {
    render(): JSX.Element;

}




export type PopoverOn = "click" | "hover" | "focus" | ("click" | "hover" | "focus")[];

export type PopoverVariant = "default" | "inverse";

export type PopoverDefaultFocusElement = React.ReactElement<any> | ((...args: any[])=>any);

export type PopoverOffsetX = string | number;

export type PopoverOffsetY = string | number;

export type PopoverInsertAt = "bottom" | "top";

export type PopoverLiveRegion = React.ReactElement<any>[] | React.ReactElement<any> | ((...args: any[])=>any);

export type PopoverPositionTarget = any | ((...args: any[])=>any);

export interface PopoverProps {
    /**
     * Children of the `<Popover />`
     */
    children?: any;
    /**
     * The placement of the content in relation to the trigger
     */
    placement?: any;
    /**
     * The action that causes the Content to display (`click`, `hover`, `focus`)
     */
    on?: PopoverOn;
    variant?: PopoverVariant;
    /**
     * Controls the shadow depth for the `<Popover />`
     */
    shadow?: any;
    /**
     * Controls the z-index depth for the `<Popover />` content
     */
    stacking?: any;
    /**
     * Whether or not the content should be rendered on initial render.
     */
    defaultShow?: boolean;
    /**
     * Whether or not the `<Popover />` is shown (should be accompanied by `onToggle`)
     */
    show?: any;
    /**
     * A function that returns a reference to the content element
     */
    contentRef?: (...args: any[])=>any;
    /**
     * Call this function when the content visibility is toggled. When used with `show`,
     * `<Popover />` will not control its own state.
     */
    onToggle?: (...args: any[])=>any;
    /**
     * Callback fired when component is clicked
     */
    onClick?: (...args: any[])=>any;
    /**
     * Callback fired when trigger is focused
     */
    onFocus?: (...args: any[])=>any;
    /**
     * Callback fired when component is blurred
     */
    onBlur?: (...args: any[])=>any;
    onKeyDown?: (...args: any[])=>any;
    /**
     * Callback fired when content is rendered and positioned
     */
    onShow?: (...args: any[])=>any;
    /**
     * Callback fired when mouse is over trigger
     */
    onMouseOver?: (...args: any[])=>any;
    /**
     * Callback fired when mouse leaves trigger
     */
    onMouseOut?: (...args: any[])=>any;
    /**
     * Callback fired when the `<Popover />` requests to be hidden (via close button, escape key, etc.)
     */
    onDismiss?: (...args: any[])=>any;
    /**
     * Should the `<Popover />` display with an arrow pointing to the trigger
     */
    withArrow?: boolean;
    /**
     * An accessible label for the `<Popover />` content
     */
    label?: string;
    /**
     * An element or a function returning an element to focus by default
     */
    defaultFocusElement?: PopoverDefaultFocusElement;
    /**
     * Should the `<Popover />` render offscreen when visually hidden
     */
    shouldRenderOffscreen?: boolean;
    /**
     * Whether focus should contained within the `<Popover/>` when it is open
     */
    shouldContainFocus?: boolean;
    /**
     * Whether focus should be returned to the trigger when the `<Popover/>` is closed
     */
    shouldReturnFocus?: boolean;
    /**
     * Should the `<Popover />` hide when clicks occur outside the content
     */
    shouldCloseOnDocumentClick?: boolean;
    /**
     * Should the `<Popover />` hide when the escape key is pressed
     */
    shouldCloseOnEscape?: boolean;
    /**
     * The horizontal offset for the positioned content
     */
    offsetX?: PopoverOffsetX;
    /**
     * The vertical offset for the positioned content
     */
    offsetY?: PopoverOffsetY;
    /**
     * Callback fired when the position changes
     */
    onPositionChanged?: (...args: any[])=>any;
    /**
     * Callback fired when content has been mounted and is initially positioned
     */
    onPositioned?: (...args: any[])=>any;
    /**
     * Whether or not position should be tracked or just set on initial render
     */
    trackPosition?: boolean;
    /**
     * The parent in which to constrain the popover.
     * One of: 'window', 'scroll-parent', 'parent', 'none', an element,
     * or a function returning an element
     */
    constrain?: any;
    /**
     * An element or a function returning an element to use as the mount node
     * for the `<Popover />` (defaults to `document.body`)
     */
    mountNode?: any;
    /**
     * Insert the element at the 'top' of the mountNode or at the 'bottom'
     */
    insertAt?: PopoverInsertAt;
    /**
     * An element, function returning an element, or array of elements that will not be hidden from
     * the screen reader when the `<Popover />` is open
     */
    liveRegion?: PopoverLiveRegion;
    /**
     * Target element for positioning the Popover (if it differs from the trigger)
     */
    positionTarget?: PopoverPositionTarget;
    /**
     * should the content offset to align by its arrow
     */
    alignArrow?: boolean;
    id?: string;
    /**
     * should the content become focused when the trigger is blurred
     */
    shouldFocusContentOnTriggerBlur?: boolean;
}

export class Popover extends React.Component<PopoverProps, any> {
    render(): JSX.Element;

}




export type TooltipChildren = React.ReactNode | ((...args: any[])=>any);

export type TooltipOn = "click" | "hover" | "focus" | ("click" | "hover" | "focus")[];

export type TooltipVariant = "default" | "inverse";

export type TooltipPositionTarget = any | ((...args: any[])=>any);

export interface TooltipProps {
    /**
     * @param {Object} renderProps
     * @param {Boolean} renderProps.focused - Is the Tooltip trigger focused?
     * @param {Function} renderProps.getTriggerProps - Props to be spread onto the trigger element
     */
    children: TooltipChildren;
    tip: React.ReactNode;
    /**
     * the element type to render as (assumes a single child if 'as' is undefined)
     */
    as?: any;
    on?: TooltipOn;
    variant?: TooltipVariant;
    /**
     * Specifies where the Tooltip will be placed in relation to the target element.
     * Ex. placement="bottom" will render the Tooltip below the triggering element
     * (Note: if there is not room, it will position opposite. Ex. "top" will
     * automatically switch to "bottom").
     */
    placement?: any;
    /**
     * An element or a function returning an element to use as the mount node
     * for the `<Tooltip />` (defaults to `document.body`)
     */
    mountNode?: any;
    /**
     * Target element for positioning the Tooltip (if it differs from children/trigger)
     */
    positionTarget?: TooltipPositionTarget;
    /**
     * The parent in which to constrain the tooltip.
     * One of: 'window', 'scroll-parent', 'parent', 'none', an element,
     * or a function returning an element
     */
    constrain?: any;
}

export class Tooltip extends React.Component<TooltipProps, any> {
    render(): JSX.Element;

}




export type TraySize = "x-small" | "small" | "regular" | "medium" | "large";

export type TrayPlacement = "top" | "bottom" | "start" | "end";

export type TrayDefaultFocusElement = React.ReactElement<any> | ((...args: any[])=>any);

export type TrayMountNode = any | ((...args: any[])=>any);

export type TrayInsertAt = "bottom" | "top";

export type TrayLiveRegion = React.ReactElement<any>[] | React.ReactElement<any> | ((...args: any[])=>any);

export interface TrayProps {
    label: string;
    children?: React.ReactNode;
    /**
     * The size (width) of the `<Tray />` when placement is `start` or `end`
     */
    size?: TraySize;
    /**
     * Placement to determine where the `<Tray />` should display in the viewport
     */
    placement?: TrayPlacement;
    /**
     * Whether or not the `<Tray />` is open
     */
    open?: boolean;
    /**
     * An element or a function returning an element to focus by default
     */
    defaultFocusElement?: TrayDefaultFocusElement;
    /**
     * A function that returns a reference to the content element
     */
    contentRef?: (...args: any[])=>any;
    /**
     * Whether focus should be contained within the `<Tray/>` when it is open
     */
    shouldContainFocus?: boolean;
    /**
     * Whether focus should be restored when the `<Tray/>` is closed
     */
    shouldReturnFocus?: boolean;
    /**
     * Should the `<Tray />` hide when clicks occur outside the content
     */
    shouldCloseOnDocumentClick?: boolean;
    /**
     * Callback fired when `<Tray />` content has been mounted in the DOM
     */
    onOpen?: (...args: any[])=>any;
    /**
     * Callback fired when `<Tray />` has been unmounted from the DOM
     */
    onClose?: (...args: any[])=>any;
    /**
     * Callback fired when the `<Tray />` is requesting to be closed
     */
    onDismiss?: (...args: any[])=>any;
    /**
     * An element or a function returning an element to use as the mount node
     * for the `<Tray />` (defaults to `document.body`)
     */
    mountNode?: TrayMountNode;
    /**
     * Insert the element at the 'top' of the mountNode or at the 'bottom'
     */
    insertAt?: TrayInsertAt;
    /**
     * An element, function returning an element, or array of elements that will not be hidden from
     * the screen reader when the `<Tray />` is open
     */
    liveRegion?: TrayLiveRegion;
    /**
     * Callback fired when the <Tray /> transitions in/out
     */
    onTransition?: (...args: any[])=>any;
    /**
     * Callback fired before the <Tray /> transitions in
     */
    onEnter?: (...args: any[])=>any;
    /**
     * Callback fired as the <Tray /> begins to transition in
     */
    onEntering?: (...args: any[])=>any;
    /**
     * Callback fired after the <Tray /> finishes transitioning in
     */
    onEntered?: (...args: any[])=>any;
    /**
     * Callback fired right before the <Tray /> transitions out
     */
    onExit?: (...args: any[])=>any;
    /**
     * Callback fired as the <Tray /> begins to transition out
     */
    onExiting?: (...args: any[])=>any;
    /**
     * Callback fired after the <Tray /> finishes transitioning out
     */
    onExited?: (...args: any[])=>any;
    /**
     * Should the `<Tray />` have a border
     */
    border?: boolean;
    /**
     * Should the `<Tray />` have a box shadow
     */
    shadow?: boolean;
}

export class Tray extends React.Component<TrayProps, any> {
    render(): JSX.Element;

}


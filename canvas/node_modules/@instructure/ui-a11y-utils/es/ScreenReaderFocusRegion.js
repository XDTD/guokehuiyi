import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import { warn as _warn } from "@instructure/console";

var ScreenReaderFocusRegion = /*#__PURE__*/function () {
  function ScreenReaderFocusRegion(element) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      shouldContainFocus: true,
      liveRegion: []
    };

    _classCallCheck(this, ScreenReaderFocusRegion);

    this._observer = null;
    this._attributes = [];
    this._nodes = [];
    this._parents = [];

    this.handleDOMMutation = function (records) {
      records.forEach(function (record) {
        var addedNodes = Array.from(record.addedNodes);
        var removedNodes = Array.from(record.removedNodes);

        _this.hideNodes(addedNodes);

        removedNodes.forEach(function (removedNode) {
          // Node has been removed from the DOM, make sure it is
          // removed from our list of hidden nodes as well
          if (removedNode.tagName.toLowerCase() !== 'iframe') {
            _this.restoreNode(removedNode);
          }

          var iframeBodies = _this.parseIframeBodies(removedNode);

          iframeBodies.forEach(function (iframeBody) {
            _this.restoreNode(iframeBody);
          });
        });
      });
    };

    var liveRegion = typeof options.liveRegion === 'function' ? options.liveRegion() : options.liveRegion;
    this._liveRegion = Array.isArray(liveRegion) ? liveRegion : [liveRegion];
    this._contextElement = element;
    this._options = options;
  }

  _createClass(ScreenReaderFocusRegion, [{
    key: "updateElement",
    value: function updateElement(element) {
      this._contextElement = element;
    }
  }, {
    key: "muteNode",
    value: function muteNode(node) {
      var _this2 = this;

      if (node && node.tagName.toLowerCase() !== 'script') {
        // When we are trapping screen reader focus on an element that
        // is deep inside the DOM, we can't apply aria-hidden to the
        // parents, so parent regions will be read if they have a role
        // and/or aria-label assigned. To optimize SR ux we remove the role,
        // aria-label, and aria-hidden attrs temporarily when the region
        // is focused, and then we restore them when focus is lost.
        ;
        ['role', 'aria-label', 'aria-hidden' // this should never happen right?
        ].forEach(function (attribute) {
          var value = node.getAttribute(attribute);

          if (value !== null) {
            _this2._attributes.push([node, attribute, value]);

            node.removeAttribute(attribute);
          }
        });

        this._observer.observe(node, {
          childList: true
        });
      }
    }
  }, {
    key: "hideNodes",
    value: function hideNodes(nodes) {
      var _this3 = this;

      nodes.forEach(function (node) {
        var _node$getAttribute;

        var ariaLive = typeof node.getAttribute === 'function' && ((_node$getAttribute = node.getAttribute('aria-live')) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.toLowerCase());

        if (node && node.nodeType === 1 && node.tagName.toLowerCase() !== 'script' && ariaLive !== 'assertive' && ariaLive !== 'polite' && _this3._parents.indexOf(node) === -1 && _this3._nodes.indexOf(node) === -1 && _this3._liveRegion.indexOf(node) === -1 && !_this3._contextElement.contains(node)) {
          if (node.tagName.toLowerCase() !== 'iframe') {
            _this3.hideNode(node);
          }

          var iframeBodies = _this3.parseIframeBodies(node);

          iframeBodies.forEach(function (iframeBody) {
            _this3.hideNode(iframeBody);
          });
        }
      });
    }
  }, {
    key: "hideNode",
    value: function hideNode(node) {
      if (node.getAttribute('aria-hidden') !== 'true') {
        node.setAttribute('aria-hidden', 'true');

        this._nodes.push(node);
      }
    }
  }, {
    key: "restoreNode",
    value: function restoreNode(removedNode) {
      var index = this._nodes.indexOf(removedNode);

      if (index >= 0) {
        removedNode.removeAttribute('aria-hidden');

        this._nodes.splice(index, 1);
      }
    }
  }, {
    key: "parseIframeBodies",
    value: function parseIframeBodies(node) {
      if (!node) return [];
      var iframes = [];

      if (node.tagName.toLowerCase() === 'iframe') {
        iframes.push(node);
      } else {
        if (node.getElementsByTagName) {
          iframes = Array.from(node.getElementsByTagName('iframe'));
        }
      }

      return iframes.map(function (iframe) {
        var body = null;

        try {
          body = iframe.contentDocument.body;
        } catch (e) {
          /*#__PURE__*/

          /*#__PURE__*/
          _warn(false, "[ui-a11y] could not find a document for iframe: ".concat(e), iframe);
        }

        return body;
      }).filter(function (body) {
        return body !== null;
      });
    }
  }, {
    key: "activate",
    value: function activate() {
      if (!this._options.shouldContainFocus) {
        return;
      }

      this._observer = new MutationObserver(this.handleDOMMutation);
      var node = this._contextElement;

      while (node && node.nodeType === 1 && node.tagName.toLowerCase() !== 'body') {
        var parent = node.parentElement; // can be null

        if (parent) {
          this._parents.push(parent);

          this.muteNode(parent);
          this.hideNodes(Array.prototype.slice.call(parent.childNodes));
        }

        node = node.parentNode; // should never be null, will default to doc element
      }
    }
  }, {
    key: "deactivate",
    value: function deactivate() {
      if (this._observer) {
        this._observer.disconnect();

        this._observer = null;
      }

      this._nodes.forEach(function (node) {
        node.removeAttribute('aria-hidden');
      });

      this._nodes = [];

      this._attributes.forEach(function (attribute) {
        attribute[0].setAttribute(attribute[1], attribute[2] || '');
      });

      this._attributes = [];
      this._parents = [];
    }
  }]);

  return ScreenReaderFocusRegion;
}();

export default ScreenReaderFocusRegion;
export {
/**
 * ---
 * category: utilities/a11y
 * ---
 * @module ScreenReaderFocusRegion
 * Utility that hides all DOM elements outside of a specified node. Used,
 * for example, in overlay components where we want to restrict the screen
 * readers to the overlay content
 */
ScreenReaderFocusRegion };
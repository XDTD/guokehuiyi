import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";
import { error as _error } from "@instructure/console";

var _dec, _dec2, _dec3, _dec4, _class, _class2, _temp;

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import React, { Component, createElement } from 'react';
import PropTypes from 'prop-types';
import classnames from 'classnames';
import keycode from 'keycode';
import { View } from '@instructure/ui-view';
import { themeable, ThemeablePropTypes } from '@instructure/ui-themeable';
import { Children } from '@instructure/ui-prop-types';
import { deprecated, matchComponentTypes, safeCloneElement, passthroughProps } from '@instructure/ui-react-utils';
import { uid } from '@instructure/uid';
import { testable } from '@instructure/ui-testable';
import { Focusable } from '@instructure/ui-focusable';
import { addResizeListener, getBoundingClientRect } from '@instructure/ui-dom-utils';
import { debounce } from '@instructure/debounce';
import { px } from '@instructure/ui-utils';
import { bidirectional } from '@instructure/ui-i18n';
import { Tab } from "./Tab/index.js";
import { Panel } from "./Panel/index.js";
var styles = {
  componentId: 'dCppM',
  template: function template(theme) {
    return "\n\n.dCppM_ddES{background:".concat(theme.defaultBackground || 'inherit', "}\n\n.dCppM_ddES .dCppM_bXVH{margin-bottom:calc(").concat(theme.tabVerticalOffset || 'inherit', "*-1)}\n\n.dCppM_eSIm{display:flex;width:100%}\n\n.dCppM_Lbvy{flex-flow:row wrap}\n\n.dCppM_etmn{overflow-x:auto}\n\n.dCppM_ddES .dCppM_etmn::-webkit-scrollbar-track{background-color:transparent}\n\n.dCppM_ddES .dCppM_etmn::-webkit-scrollbar{background-color:transparent;height:0.0625rem}\n\n.dCppM_ddES .dCppM_etmn::-webkit-scrollbar-thumb{background-color:transparent}\n\n.dCppM_fgct{background:linear-gradient(270deg,").concat(theme.scrollFadeColor || 'inherit', " 0%,hsla(0,0%,100%,0));height:calc(100% - ").concat(theme.tabVerticalOffset || 'inherit', " - 0.25rem);inset-inline-end:0;pointer-events:none;position:absolute;top:0;z-index:").concat(theme.zIndex || 'inherit', "}\n\n[dir=ltr] .dCppM_fgct{right:0}\n\n[dir=rtl] .dCppM_fgct{background:linear-gradient(90deg,").concat(theme.scrollFadeColor || 'inherit', " 0%,hsla(0,0%,100%,0));inset-inline-end:auto;inset-inline-start:0;left:0}\n\n[dir=ltr] [dir=rtl] .dCppM_fgct{left:0;right:auto}\n\n[dir=rtl] [dir=rtl] .dCppM_fgct{left:auto;right:0}\n\n.dCppM_ddES .dCppM_fgct{width:").concat(theme.scrollOverlayWidthDefault || 'inherit', "}\n\n.dCppM_eLeB .dCppM_fgct{width:").concat(theme.scrollOverlayWidthSecondary || 'inherit', "}\n\n.dCppM_ciZv{flex-shrink:0}\n\n.dCppM_ddES .dCppM_ciZv{flex-basis:").concat(theme.scrollOverlayWidthDefault || 'inherit', "}\n\n.dCppM_eLeB .dCppM_ciZv{flex-basis:").concat(theme.scrollOverlayWidthSecondary || 'inherit', "}");
  },
  'default': 'dCppM_ddES',
  'tabs': 'dCppM_bXVH',
  'tabList': 'dCppM_eSIm',
  'tabOverflow--stack': 'dCppM_Lbvy',
  'tabOverflow--scroll': 'dCppM_etmn',
  'scrollOverlay': 'dCppM_fgct',
  'secondary': 'dCppM_eLeB',
  'scrollSpacer': 'dCppM_ciZv'
};
import theme from "./theme.js";
/**
---
category: components
---
**/

var Tabs = (_dec = deprecated('8.0.0', {
  title: 'renderTitle',
  size: 'maxWidth',
  selectedIndex: true,
  onChange: 'onRequestTabChange',
  focus: 'shouldFocusOnRender'
}), _dec2 = testable(), _dec3 = bidirectional(), _dec4 = themeable(theme, styles), _dec(_class = _dec2(_class = _dec3(_class = _dec4(_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
  _inherits(Tabs, _Component);

  var _super = _createSuper(Tabs);

  function Tabs(props) {
    var _this;

    _classCallCheck(this, Tabs);

    _this = _super.call(this);

    _this.handleTabClick = function (event, _ref) {
      var index = _ref.index,
          id = _ref.id;

      var nextTab = _this.getNextTab(index, 0);

      _this.fireOnChange(event, nextTab);
    };

    _this.handleTabKeyDown = function (event, _ref2) {
      var index = _ref2.index;
      var nextTab;

      if (event.keyCode === keycode.codes.up || event.keyCode === keycode.codes.left) {
        // Select next tab to the left
        nextTab = _this.getNextTab(index, -1);
      } else if (event.keyCode === keycode.codes.down || event.keyCode === keycode.codes.right) {
        // Select next tab to the right
        nextTab = _this.getNextTab(index, 1);
      }

      if (nextTab) {
        event.preventDefault();

        _this.fireOnChange(event, nextTab);
      }
    };

    _this.handleResize = function () {
      _this.setState({
        withTabListOverflow: _this._tabList.scrollWidth > _this._tabList.offsetWidth
      });

      _this._tabListPosition = getBoundingClientRect(_this._tabList);
    };

    _this.handleFocusableRef = function (el) {
      _this._focusable = el;
    };

    _this.handleTabListRef = function (el) {
      _this._tabList = el;
    };

    _this._tabList = null;
    _this._tabListPosition = null;
    _this.state = {
      withTabListOverflow: false
    };
    return _this;
  }

  _createClass(Tabs, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.tabOverflow === 'scroll' && this._tabList) {
        this.startScrollOverflow(); // make sure active tab is always visible

        var activeTabEl = this._tabList.querySelector('[aria-selected="true"]');

        this.showActiveTabIfOverlayed(activeTabEl);
      }

      if (this.props.focus || this.props.shouldFocusOnRender) {
        this.focus();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props.focus && !prevProps.focus || this.props.shouldFocusOnRender && !prevProps.shouldFocusOnRender) {
        this.focus();
      } // start event listeners for scroll overflow


      if (prevProps.tabOverflow === 'stack' && this.props.tabOverflow === 'scroll') {
        this.startScrollOverflow();
      } // cancel event listeners for scroll overflow


      if (prevProps.tabOverflow === 'scroll' && this.props.tabOverflow === 'stack') {
        this.cancelScrollOverflow();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.cancelScrollOverflow();
    }
  }, {
    key: "startScrollOverflow",
    value: function startScrollOverflow() {
      this.handleResize();
      this._debounced = debounce(this.handleResize, 300, {
        leading: true,
        trailing: true
      });
      this._resizeListener = addResizeListener(this._tabList, this._debounced);
      this._tabListPosition = getBoundingClientRect(this._tabList);
    }
  }, {
    key: "cancelScrollOverflow",
    value: function cancelScrollOverflow() {
      if (this._resizeListener) {
        this._resizeListener.remove();
      }

      if (this._debounced) {
        this._debounced.cancel();
      }
    }
  }, {
    key: "getOverlayWidth",
    value: function getOverlayWidth() {
      var _this$props = this.props,
          variant = _this$props.variant,
          tabOverflow = _this$props.tabOverflow;

      if (tabOverflow === 'scroll') {
        if (variant === 'default') {
          return px(this.theme.scrollOverlayWidthDefault);
        } else {
          return px(this.theme.scrollOverlayWidthSecondary);
        }
      }
    }
  }, {
    key: "showActiveTabIfOverlayed",
    value: function showActiveTabIfOverlayed(activeTabEl) {
      if (this._tabList && this._tabListPosition && typeof this._tabList.scrollTo === 'function' // test for scrollTo support
      ) {
          var rtl = this.dir === bidirectional.DIRECTION.rtl;
          var tabPosition = getBoundingClientRect(activeTabEl);
          var tabListPosition = this._tabListPosition;
          var tabListBoundStart = rtl ? tabListPosition.left + this.getOverlayWidth() : tabListPosition.left;
          var tabListBoundEnd = rtl ? tabListPosition.right : tabListPosition.right + this.getOverlayWidth();
          var tabPositionStart = tabPosition.left;
          var tabPositionEnd = tabPosition.right;

          if (tabListBoundEnd > tabPositionEnd) {
            var offset = Math.round(tabListBoundEnd - tabPositionEnd);

            this._tabList.scrollTo({
              top: 0,
              left: this._tabList.scrollLeft + offset,
              behavior: 'smooth'
            });
          } else if (tabListBoundStart > tabPositionStart) {
            var _offset = Math.round(tabListBoundStart - tabPositionStart);

            this._tabList.scrollTo({
              top: 0,
              left: this._tabList.scrollLeft - _offset,
              behavior: 'smooth'
            });
          }
        }
    }
  }, {
    key: "getNextTab",
    value: function getNextTab(startIndex, step) {
      var tabs = React.Children.toArray(this.props.children).map(function (child) {
        return matchComponentTypes(child, [Panel]) && child;
      });
      var count = tabs.length;
      var change = step < 0 ? step + count : step;

      /*#__PURE__*/

      /*#__PURE__*/
      _error(startIndex >= 0 && startIndex < count, "[Tabs] Invalid tab index: '".concat(startIndex, "'."));

      var nextIndex = startIndex;
      var nextTab;

      do {
        nextIndex = (nextIndex + change) % count;
        nextTab = tabs[nextIndex];
      } while (nextTab && nextTab.props && (nextTab.props.disabled || nextTab.props.isDisabled));

      /*#__PURE__*/

      /*#__PURE__*/
      _error(nextIndex >= 0 && nextIndex < count, "[Tabs] Invalid tab index: '".concat(nextIndex, "'."));

      return {
        index: nextIndex,
        id: nextTab.props.id
      };
    }
  }, {
    key: "fireOnChange",
    value: function fireOnChange(event, _ref3) {
      var index = _ref3.index,
          id = _ref3.id;

      if (typeof this.props.onChange === 'function') {
        this.props.onChange(event, {
          index: index
        });
      }

      if (typeof this.props.onRequestTabChange === 'function') {
        this.props.onRequestTabChange(event, {
          index: index,
          id: id
        });
      }

      this.state.withTabListOverflow && this.showActiveTabIfOverlayed(this._tabList.querySelector("#tab-".concat(id)));
    }
  }, {
    key: "createTab",
    value: function createTab(index, generatedId, selected, panel) {
      var id = panel.props.id || generatedId;
      var disabled = panel.props.disabled || panel.props.isDisabled;
      return createElement(Tab, {
        variant: this.props.variant,
        key: "tab-".concat(id),
        id: "tab-".concat(id),
        controls: panel.props.id || "panel-".concat(id),
        index: index,
        selected: void 0,
        isSelected: selected,
        disabled: void 0,
        isDisabled: disabled,
        children: panel.props.renderTitle || panel.props.title,
        onClick: this.handleTabClick,
        onKeyDown: this.handleTabKeyDown
      });
    }
  }, {
    key: "clonePanel",
    value: function clonePanel(index, generatedId, selected, panel) {
      var id = panel.props.id || generatedId;
      return safeCloneElement(panel, {
        id: panel.props.id || "panel-".concat(id),
        labelledBy: "tab-".concat(id),
        selected: void 0,
        isSelected: selected,
        key: panel.props.id || "panel-".concat(id),
        variant: this.props.variant,
        padding: panel.props.padding || this.props.padding,
        textAlign: panel.props.textAlign || this.props.textAlign,
        maxHeight: panel.maxHeight || this.props.maxHeight,
        minHeight: panel.minHeight || this.props.minHeight
      });
    }
  }, {
    key: "focus",
    value: function focus() {
      this._focusable && typeof this._focusable.focus === 'function' && this._focusable.focus();
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var panels = [];
      var tabs = [];

      var _this$props2 = this.props,
          children = _this$props2.children,
          elementRef = _this$props2.elementRef,
          size = _this$props2.size,
          maxWidth = _this$props2.maxWidth,
          variant = _this$props2.variant,
          margin = _this$props2.margin,
          screenReaderLabel = _this$props2.screenReaderLabel,
          onRequestTabChange = _this$props2.onRequestTabChange,
          tabOverflow = _this$props2.tabOverflow,
          onChange = _this$props2.onChange,
          props = _objectWithoutProperties(_this$props2, ["children", "elementRef", "size", "maxWidth", "variant", "margin", "screenReaderLabel", "onRequestTabChange", "tabOverflow", "onChange"]);

      var selectedChildIndex = React.Children.toArray(children).filter(function (child) {
        return matchComponentTypes(child, [Panel]);
      }).findIndex(function (child) {
        return (child.props.selected || child.props.isSelected) && !(child.props.disabled || child.props.isDisabled);
      });
      var index = 0;
      var selectedIndex = props.selectedIndex || (selectedChildIndex >= 0 ? selectedChildIndex : 0);
      React.Children.forEach(children, function (child) {
        if (matchComponentTypes(child, [Panel])) {
          var selected = !(child.props.disabled || child.props.isDisabled) && (child.props.selected || child.props.isSelected || selectedIndex === index);
          var id = uid();
          tabs.push(_this2.createTab(index, id, selected, child));
          panels.push(_this2.clonePanel(index, id, selected, child));
          index++;
        } else {
          panels.push(child);
        }
      });
      var withScrollFade = tabOverflow === 'scroll' && this.state.withTabListOverflow; // suppress overlay whenever final Tab is active, or Firefox will cover it

      var scrollOverlay = selectedIndex !== React.Children.count(children) - 1 ? /*#__PURE__*/React.createElement("span", {
        key: "overlay",
        className: styles.scrollOverlay
      }) : null;
      var scrollFadeEls = [
      /*#__PURE__*/
      // spacer element prevents final Tab from being obscured by scroll overflow gradient
      React.createElement("span", {
        key: "spacer",
        className: styles.scrollSpacer
      }), scrollOverlay];
      return /*#__PURE__*/React.createElement(View, Object.assign({}, passthroughProps(props), {
        elementRef: elementRef,
        maxWidth: maxWidth ? maxWidth : this.theme[size],
        margin: margin,
        as: "div",
        className: classnames(_defineProperty({}, styles[variant], true))
      }), /*#__PURE__*/React.createElement(Focusable, {
        ref: this.handleFocusableRef
      }, function (_ref4) {
        var _classnames2;

        var focusVisible = _ref4.focusVisible;
        return /*#__PURE__*/React.createElement(View, {
          as: "div",
          position: "relative",
          borderRadius: "medium",
          withFocusOutline: focusVisible,
          shouldAnimateFocus: false,
          className: styles.tabs
        }, /*#__PURE__*/React.createElement(View, {
          as: "div",
          role: "tablist",
          className: classnames((_classnames2 = {}, _defineProperty(_classnames2, styles.tabList, true), _defineProperty(_classnames2, styles["tabOverflow--".concat(tabOverflow)], true), _classnames2)),
          "aria-label": screenReaderLabel,
          elementRef: _this2.handleTabListRef
        }, tabs, withScrollFade && scrollFadeEls));
      }), panels);
    }
  }]);

  Tabs.displayName = "Tabs";
  return Tabs;
}(Component), _class2.propTypes = {
  /**
   * children of type `Tabs.Panel`
   */
  children: Children.oneOf([Panel, null]),
  variant: PropTypes.oneOf(['default', 'secondary']),

  /**
   * A screen ready only label for the list of tabs
   */
  screenReaderLabel: PropTypes.string,

  /**
   * Called when the selected tab should change
   */
  onRequestTabChange: PropTypes.func,
  maxWidth: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  maxHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  minHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
   * Valid values are `0`, `none`, `auto`, `xxx-small`, `xx-small`, `x-small`,
   * `small`, `medium`, `large`, `x-large`, `xx-large`. Apply these values via
   * familiar CSS-like shorthand. For example: `margin="small auto large"`.
   */
  margin: ThemeablePropTypes.spacing,

  /**
   * Valid values are `0`, `none`, `xxx-small`, `xx-small`, `x-small`,
   * `small`, `medium`, `large`, `x-large`, `xx-large`. Apply these values via
   * familiar CSS-like shorthand. For example: `padding="small x-large large"`.
   */
  padding: ThemeablePropTypes.spacing,
  textAlign: PropTypes.oneOf(['start', 'center', 'end']),
  elementRef: PropTypes.func,

  /**
   * Choose whether Tabs should stack or scroll when they exceed the width of their
   * container.
   */
  tabOverflow: PropTypes.oneOf(['stack', 'scroll']),
  shouldFocusOnRender: PropTypes.bool,

  /**
   * __Deprecated - use `onRequestTabChange` instead__
   */
  onChange: PropTypes.func,

  /**
   * __Deprecated__
   */
  size: PropTypes.oneOf(['small', 'medium', 'large']),

  /**
   * __Deprecated__
   */
  selectedIndex: PropTypes.number,

  /**
   * __Deprecated - use `shouldFocusOnRender` instead__
   */
  focus: PropTypes.bool
}, _class2.defaultProps = {
  selectedIndex: void 0,
  variant: 'default',
  padding: void 0,
  textAlign: void 0,
  size: void 0,
  maxWidth: void 0,
  maxHeight: void 0,
  minHeight: void 0,
  onChange: void 0,
  onRequestTabChange: function onRequestTabChange(event, _ref5) {
    var index = _ref5.index,
        id = _ref5.id;
  },
  margin: void 0,
  children: null,
  elementRef: function elementRef(el) {},
  screenReaderLabel: void 0,
  focus: void 0,
  shouldFocusOnRender: false,
  tabOverflow: 'stack'
}, _class2.Panel = Panel, _class2.Tab = Tab, _temp)) || _class) || _class) || _class) || _class);
export default Tabs;
export { Tabs, Panel };
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Panel", {
  enumerable: true,
  get: function get() {
    return _index2.Panel;
  }
});
exports.Tabs = exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _createSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/createSuper"));

var _console = require("@instructure/console");

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames3 = _interopRequireDefault(require("classnames"));

var _keycode = _interopRequireDefault(require("keycode"));

var _View = require("@instructure/ui-view/lib/View");

var _themeable = require("@instructure/ui-themeable/lib/themeable.js");

var _ThemeablePropTypes = require("@instructure/ui-themeable/lib/ThemeablePropTypes.js");

var _Children = require("@instructure/ui-prop-types/lib/Children.js");

var _deprecated = require("@instructure/ui-react-utils/lib/deprecated.js");

var _matchComponentTypes = require("@instructure/ui-react-utils/lib/matchComponentTypes.js");

var _safeCloneElement = require("@instructure/ui-react-utils/lib/safeCloneElement.js");

var _passthroughProps = require("@instructure/ui-react-utils/lib/passthroughProps.js");

var _uid = require("@instructure/uid");

var _testable = require("@instructure/ui-testable/lib/testable.js");

var _Focusable = require("@instructure/ui-focusable/lib/Focusable");

var _addResizeListener = require("@instructure/ui-dom-utils/lib/addResizeListener.js");

var _getBoundingClientRect = require("@instructure/ui-dom-utils/lib/getBoundingClientRect.js");

var _debounce = require("@instructure/debounce");

var _px = require("@instructure/ui-utils/lib/px.js");

var _bidirectional = require("@instructure/ui-i18n/lib/bidirectional.js");

var _index = require("./Tab/index.js");

var _index2 = require("./Panel/index.js");

var _theme = _interopRequireDefault(require("./theme.js"));

var _dec, _dec2, _dec3, _dec4, _class, _class2, _temp;

var styles = {
  componentId: 'dCppM',
  template: function template(theme) {
    return "\n\n.dCppM_ddES{background:".concat(theme.defaultBackground || 'inherit', "}\n\n.dCppM_ddES .dCppM_bXVH{margin-bottom:calc(").concat(theme.tabVerticalOffset || 'inherit', "*-1)}\n\n.dCppM_eSIm{display:flex;width:100%}\n\n.dCppM_Lbvy{flex-flow:row wrap}\n\n.dCppM_etmn{overflow-x:auto}\n\n.dCppM_ddES .dCppM_etmn::-webkit-scrollbar-track{background-color:transparent}\n\n.dCppM_ddES .dCppM_etmn::-webkit-scrollbar{background-color:transparent;height:0.0625rem}\n\n.dCppM_ddES .dCppM_etmn::-webkit-scrollbar-thumb{background-color:transparent}\n\n.dCppM_fgct{background:linear-gradient(270deg,").concat(theme.scrollFadeColor || 'inherit', " 0%,hsla(0,0%,100%,0));height:calc(100% - ").concat(theme.tabVerticalOffset || 'inherit', " - 0.25rem);inset-inline-end:0;pointer-events:none;position:absolute;top:0;z-index:").concat(theme.zIndex || 'inherit', "}\n\n[dir=ltr] .dCppM_fgct{right:0}\n\n[dir=rtl] .dCppM_fgct{background:linear-gradient(90deg,").concat(theme.scrollFadeColor || 'inherit', " 0%,hsla(0,0%,100%,0));inset-inline-end:auto;inset-inline-start:0;left:0}\n\n[dir=ltr] [dir=rtl] .dCppM_fgct{left:0;right:auto}\n\n[dir=rtl] [dir=rtl] .dCppM_fgct{left:auto;right:0}\n\n.dCppM_ddES .dCppM_fgct{width:").concat(theme.scrollOverlayWidthDefault || 'inherit', "}\n\n.dCppM_eLeB .dCppM_fgct{width:").concat(theme.scrollOverlayWidthSecondary || 'inherit', "}\n\n.dCppM_ciZv{flex-shrink:0}\n\n.dCppM_ddES .dCppM_ciZv{flex-basis:").concat(theme.scrollOverlayWidthDefault || 'inherit', "}\n\n.dCppM_eLeB .dCppM_ciZv{flex-basis:").concat(theme.scrollOverlayWidthSecondary || 'inherit', "}");
  },
  'default': 'dCppM_ddES',
  'tabs': 'dCppM_bXVH',
  'tabList': 'dCppM_eSIm',
  'tabOverflow--stack': 'dCppM_Lbvy',
  'tabOverflow--scroll': 'dCppM_etmn',
  'scrollOverlay': 'dCppM_fgct',
  'secondary': 'dCppM_eLeB',
  'scrollSpacer': 'dCppM_ciZv'
};

/**
---
category: components
---
**/
var Tabs = (_dec = (0, _deprecated.deprecated)('8.0.0', {
  title: 'renderTitle',
  size: 'maxWidth',
  selectedIndex: true,
  onChange: 'onRequestTabChange',
  focus: 'shouldFocusOnRender'
}), _dec2 = (0, _testable.testable)(), _dec3 = (0, _bidirectional.bidirectional)(), _dec4 = (0, _themeable.themeable)(_theme.default, styles), _dec(_class = _dec2(_class = _dec3(_class = _dec4(_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
  (0, _inherits2.default)(Tabs, _Component);

  var _super = (0, _createSuper2.default)(Tabs);

  function Tabs(props) {
    var _this;

    (0, _classCallCheck2.default)(this, Tabs);
    _this = _super.call(this);

    _this.handleTabClick = function (event, _ref) {
      var index = _ref.index,
          id = _ref.id;

      var nextTab = _this.getNextTab(index, 0);

      _this.fireOnChange(event, nextTab);
    };

    _this.handleTabKeyDown = function (event, _ref2) {
      var index = _ref2.index;
      var nextTab;

      if (event.keyCode === _keycode.default.codes.up || event.keyCode === _keycode.default.codes.left) {
        // Select next tab to the left
        nextTab = _this.getNextTab(index, -1);
      } else if (event.keyCode === _keycode.default.codes.down || event.keyCode === _keycode.default.codes.right) {
        // Select next tab to the right
        nextTab = _this.getNextTab(index, 1);
      }

      if (nextTab) {
        event.preventDefault();

        _this.fireOnChange(event, nextTab);
      }
    };

    _this.handleResize = function () {
      _this.setState({
        withTabListOverflow: _this._tabList.scrollWidth > _this._tabList.offsetWidth
      });

      _this._tabListPosition = (0, _getBoundingClientRect.getBoundingClientRect)(_this._tabList);
    };

    _this.handleFocusableRef = function (el) {
      _this._focusable = el;
    };

    _this.handleTabListRef = function (el) {
      _this._tabList = el;
    };

    _this._tabList = null;
    _this._tabListPosition = null;
    _this.state = {
      withTabListOverflow: false
    };
    return _this;
  }

  (0, _createClass2.default)(Tabs, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.tabOverflow === 'scroll' && this._tabList) {
        this.startScrollOverflow(); // make sure active tab is always visible

        var activeTabEl = this._tabList.querySelector('[aria-selected="true"]');

        this.showActiveTabIfOverlayed(activeTabEl);
      }

      if (this.props.focus || this.props.shouldFocusOnRender) {
        this.focus();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props.focus && !prevProps.focus || this.props.shouldFocusOnRender && !prevProps.shouldFocusOnRender) {
        this.focus();
      } // start event listeners for scroll overflow


      if (prevProps.tabOverflow === 'stack' && this.props.tabOverflow === 'scroll') {
        this.startScrollOverflow();
      } // cancel event listeners for scroll overflow


      if (prevProps.tabOverflow === 'scroll' && this.props.tabOverflow === 'stack') {
        this.cancelScrollOverflow();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.cancelScrollOverflow();
    }
  }, {
    key: "startScrollOverflow",
    value: function startScrollOverflow() {
      this.handleResize();
      this._debounced = (0, _debounce.debounce)(this.handleResize, 300, {
        leading: true,
        trailing: true
      });
      this._resizeListener = (0, _addResizeListener.addResizeListener)(this._tabList, this._debounced);
      this._tabListPosition = (0, _getBoundingClientRect.getBoundingClientRect)(this._tabList);
    }
  }, {
    key: "cancelScrollOverflow",
    value: function cancelScrollOverflow() {
      if (this._resizeListener) {
        this._resizeListener.remove();
      }

      if (this._debounced) {
        this._debounced.cancel();
      }
    }
  }, {
    key: "getOverlayWidth",
    value: function getOverlayWidth() {
      var _this$props = this.props,
          variant = _this$props.variant,
          tabOverflow = _this$props.tabOverflow;

      if (tabOverflow === 'scroll') {
        if (variant === 'default') {
          return (0, _px.px)(this.theme.scrollOverlayWidthDefault);
        } else {
          return (0, _px.px)(this.theme.scrollOverlayWidthSecondary);
        }
      }
    }
  }, {
    key: "showActiveTabIfOverlayed",
    value: function showActiveTabIfOverlayed(activeTabEl) {
      if (this._tabList && this._tabListPosition && typeof this._tabList.scrollTo === 'function' // test for scrollTo support
      ) {
          var rtl = this.dir === _bidirectional.bidirectional.DIRECTION.rtl;
          var tabPosition = (0, _getBoundingClientRect.getBoundingClientRect)(activeTabEl);
          var tabListPosition = this._tabListPosition;
          var tabListBoundStart = rtl ? tabListPosition.left + this.getOverlayWidth() : tabListPosition.left;
          var tabListBoundEnd = rtl ? tabListPosition.right : tabListPosition.right + this.getOverlayWidth();
          var tabPositionStart = tabPosition.left;
          var tabPositionEnd = tabPosition.right;

          if (tabListBoundEnd > tabPositionEnd) {
            var offset = Math.round(tabListBoundEnd - tabPositionEnd);

            this._tabList.scrollTo({
              top: 0,
              left: this._tabList.scrollLeft + offset,
              behavior: 'smooth'
            });
          } else if (tabListBoundStart > tabPositionStart) {
            var _offset = Math.round(tabListBoundStart - tabPositionStart);

            this._tabList.scrollTo({
              top: 0,
              left: this._tabList.scrollLeft - _offset,
              behavior: 'smooth'
            });
          }
        }
    }
  }, {
    key: "getNextTab",
    value: function getNextTab(startIndex, step) {
      var tabs = _react.default.Children.toArray(this.props.children).map(function (child) {
        return (0, _matchComponentTypes.matchComponentTypes)(child, [_index2.Panel]) && child;
      });

      var count = tabs.length;
      var change = step < 0 ? step + count : step;

      /*#__PURE__*/
      ( /*#__PURE__*/0, _console.error)(startIndex >= 0 && startIndex < count, "[Tabs] Invalid tab index: '".concat(startIndex, "'."));
      var nextIndex = startIndex;
      var nextTab;

      do {
        nextIndex = (nextIndex + change) % count;
        nextTab = tabs[nextIndex];
      } while (nextTab && nextTab.props && (nextTab.props.disabled || nextTab.props.isDisabled));

      /*#__PURE__*/
      ( /*#__PURE__*/0, _console.error)(nextIndex >= 0 && nextIndex < count, "[Tabs] Invalid tab index: '".concat(nextIndex, "'."));
      return {
        index: nextIndex,
        id: nextTab.props.id
      };
    }
  }, {
    key: "fireOnChange",
    value: function fireOnChange(event, _ref3) {
      var index = _ref3.index,
          id = _ref3.id;

      if (typeof this.props.onChange === 'function') {
        this.props.onChange(event, {
          index: index
        });
      }

      if (typeof this.props.onRequestTabChange === 'function') {
        this.props.onRequestTabChange(event, {
          index: index,
          id: id
        });
      }

      this.state.withTabListOverflow && this.showActiveTabIfOverlayed(this._tabList.querySelector("#tab-".concat(id)));
    }
  }, {
    key: "createTab",
    value: function createTab(index, generatedId, selected, panel) {
      var id = panel.props.id || generatedId;
      var disabled = panel.props.disabled || panel.props.isDisabled;
      return (0, _react.createElement)(_index.Tab, {
        variant: this.props.variant,
        key: "tab-".concat(id),
        id: "tab-".concat(id),
        controls: panel.props.id || "panel-".concat(id),
        index: index,
        selected: void 0,
        isSelected: selected,
        disabled: void 0,
        isDisabled: disabled,
        children: panel.props.renderTitle || panel.props.title,
        onClick: this.handleTabClick,
        onKeyDown: this.handleTabKeyDown
      });
    }
  }, {
    key: "clonePanel",
    value: function clonePanel(index, generatedId, selected, panel) {
      var id = panel.props.id || generatedId;
      return (0, _safeCloneElement.safeCloneElement)(panel, {
        id: panel.props.id || "panel-".concat(id),
        labelledBy: "tab-".concat(id),
        selected: void 0,
        isSelected: selected,
        key: panel.props.id || "panel-".concat(id),
        variant: this.props.variant,
        padding: panel.props.padding || this.props.padding,
        textAlign: panel.props.textAlign || this.props.textAlign,
        maxHeight: panel.maxHeight || this.props.maxHeight,
        minHeight: panel.minHeight || this.props.minHeight
      });
    }
  }, {
    key: "focus",
    value: function focus() {
      this._focusable && typeof this._focusable.focus === 'function' && this._focusable.focus();
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var panels = [];
      var tabs = [];
      var _this$props2 = this.props,
          children = _this$props2.children,
          elementRef = _this$props2.elementRef,
          size = _this$props2.size,
          maxWidth = _this$props2.maxWidth,
          variant = _this$props2.variant,
          margin = _this$props2.margin,
          screenReaderLabel = _this$props2.screenReaderLabel,
          onRequestTabChange = _this$props2.onRequestTabChange,
          tabOverflow = _this$props2.tabOverflow,
          onChange = _this$props2.onChange,
          props = (0, _objectWithoutProperties2.default)(_this$props2, ["children", "elementRef", "size", "maxWidth", "variant", "margin", "screenReaderLabel", "onRequestTabChange", "tabOverflow", "onChange"]);

      var selectedChildIndex = _react.default.Children.toArray(children).filter(function (child) {
        return (0, _matchComponentTypes.matchComponentTypes)(child, [_index2.Panel]);
      }).findIndex(function (child) {
        return (child.props.selected || child.props.isSelected) && !(child.props.disabled || child.props.isDisabled);
      });

      var index = 0;
      var selectedIndex = props.selectedIndex || (selectedChildIndex >= 0 ? selectedChildIndex : 0);

      _react.default.Children.forEach(children, function (child) {
        if ((0, _matchComponentTypes.matchComponentTypes)(child, [_index2.Panel])) {
          var selected = !(child.props.disabled || child.props.isDisabled) && (child.props.selected || child.props.isSelected || selectedIndex === index);
          var id = (0, _uid.uid)();
          tabs.push(_this2.createTab(index, id, selected, child));
          panels.push(_this2.clonePanel(index, id, selected, child));
          index++;
        } else {
          panels.push(child);
        }
      });

      var withScrollFade = tabOverflow === 'scroll' && this.state.withTabListOverflow; // suppress overlay whenever final Tab is active, or Firefox will cover it

      var scrollOverlay = selectedIndex !== _react.default.Children.count(children) - 1 ? /*#__PURE__*/_react.default.createElement("span", {
        key: "overlay",
        className: styles.scrollOverlay
      }) : null;
      var scrollFadeEls = [
      /*#__PURE__*/
      // spacer element prevents final Tab from being obscured by scroll overflow gradient
      _react.default.createElement("span", {
        key: "spacer",
        className: styles.scrollSpacer
      }), scrollOverlay];
      return /*#__PURE__*/_react.default.createElement(_View.View, Object.assign({}, (0, _passthroughProps.passthroughProps)(props), {
        elementRef: elementRef,
        maxWidth: maxWidth ? maxWidth : this.theme[size],
        margin: margin,
        as: "div",
        className: (0, _classnames3.default)((0, _defineProperty2.default)({}, styles[variant], true))
      }), /*#__PURE__*/_react.default.createElement(_Focusable.Focusable, {
        ref: this.handleFocusableRef
      }, function (_ref4) {
        var _classnames2;

        var focusVisible = _ref4.focusVisible;
        return /*#__PURE__*/_react.default.createElement(_View.View, {
          as: "div",
          position: "relative",
          borderRadius: "medium",
          withFocusOutline: focusVisible,
          shouldAnimateFocus: false,
          className: styles.tabs
        }, /*#__PURE__*/_react.default.createElement(_View.View, {
          as: "div",
          role: "tablist",
          className: (0, _classnames3.default)((_classnames2 = {}, (0, _defineProperty2.default)(_classnames2, styles.tabList, true), (0, _defineProperty2.default)(_classnames2, styles["tabOverflow--".concat(tabOverflow)], true), _classnames2)),
          "aria-label": screenReaderLabel,
          elementRef: _this2.handleTabListRef
        }, tabs, withScrollFade && scrollFadeEls));
      }), panels);
    }
  }]);
  Tabs.displayName = "Tabs";
  return Tabs;
}(_react.Component), _class2.propTypes = {
  /**
   * children of type `Tabs.Panel`
   */
  children: _Children.Children.oneOf([_index2.Panel, null]),
  variant: _propTypes.default.oneOf(['default', 'secondary']),

  /**
   * A screen ready only label for the list of tabs
   */
  screenReaderLabel: _propTypes.default.string,

  /**
   * Called when the selected tab should change
   */
  onRequestTabChange: _propTypes.default.func,
  maxWidth: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
  maxHeight: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
  minHeight: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),

  /**
   * Valid values are `0`, `none`, `auto`, `xxx-small`, `xx-small`, `x-small`,
   * `small`, `medium`, `large`, `x-large`, `xx-large`. Apply these values via
   * familiar CSS-like shorthand. For example: `margin="small auto large"`.
   */
  margin: _ThemeablePropTypes.ThemeablePropTypes.spacing,

  /**
   * Valid values are `0`, `none`, `xxx-small`, `xx-small`, `x-small`,
   * `small`, `medium`, `large`, `x-large`, `xx-large`. Apply these values via
   * familiar CSS-like shorthand. For example: `padding="small x-large large"`.
   */
  padding: _ThemeablePropTypes.ThemeablePropTypes.spacing,
  textAlign: _propTypes.default.oneOf(['start', 'center', 'end']),
  elementRef: _propTypes.default.func,

  /**
   * Choose whether Tabs should stack or scroll when they exceed the width of their
   * container.
   */
  tabOverflow: _propTypes.default.oneOf(['stack', 'scroll']),
  shouldFocusOnRender: _propTypes.default.bool,

  /**
   * __Deprecated - use `onRequestTabChange` instead__
   */
  onChange: _propTypes.default.func,

  /**
   * __Deprecated__
   */
  size: _propTypes.default.oneOf(['small', 'medium', 'large']),

  /**
   * __Deprecated__
   */
  selectedIndex: _propTypes.default.number,

  /**
   * __Deprecated - use `shouldFocusOnRender` instead__
   */
  focus: _propTypes.default.bool
}, _class2.defaultProps = {
  selectedIndex: void 0,
  variant: 'default',
  padding: void 0,
  textAlign: void 0,
  size: void 0,
  maxWidth: void 0,
  maxHeight: void 0,
  minHeight: void 0,
  onChange: void 0,
  onRequestTabChange: function onRequestTabChange(event, _ref5) {
    var index = _ref5.index,
        id = _ref5.id;
  },
  margin: void 0,
  children: null,
  elementRef: function elementRef(el) {},
  screenReaderLabel: void 0,
  focus: void 0,
  shouldFocusOnRender: false,
  tabOverflow: 'stack'
}, _class2.Panel = _index2.Panel, _class2.Tab = _index.Tab, _temp)) || _class) || _class) || _class) || _class);
exports.Tabs = Tabs;
var _default = Tabs;
exports.default = _default;
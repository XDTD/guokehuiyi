import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";

var _dec, _class, _class2, _temp;

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import React, { Component, Children } from 'react';
import PropTypes from 'prop-types';
import { Children as ChildrenPropTypes, controllable } from '@instructure/ui-prop-types';
import { FormPropTypes } from '@instructure/ui-form-field';
import { PositionPropTypes } from '@instructure/ui-position';
import { testable } from '@instructure/ui-testable';
import { matchComponentTypes, passthroughProps, callRenderProp, getInteraction } from '@instructure/ui-react-utils';
import { uid } from '@instructure/uid';
import { Select } from '@instructure/ui-select';
import { Option } from "./Option/index.js";
import { Group } from "./Group/index.js";
/**
---
category: components
tags: form, field, dropdown
---
**/

var SimpleSelect = (_dec = testable(), _dec(_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
  _inherits(SimpleSelect, _Component);

  var _super = _createSuper(SimpleSelect);

  function SimpleSelect(props) {
    var _this;

    _classCallCheck(this, SimpleSelect);

    _this = _super.call(this, props);
    _this._emptyOptionId = uid('Select-EmptyOption');

    _this.handleRef = function (node) {
      _this._select = node;
    };

    _this.handleBlur = function (event) {
      _this.setState({
        highlightedOptionId: null
      });

      _this.props.onBlur(event);
    };

    _this.handleShowOptions = function (event) {
      _this.setState({
        isShowingOptions: true
      });

      _this.props.onShowOptions(event);
    };

    _this.handleHideOptions = function (event) {
      _this.setState(function (state) {
        var option = _this.getOption('id', state.selectedOptionId);

        return {
          isShowingOptions: false,
          highlightedOptionId: null,
          inputValue: option ? option.props.children : ''
        };
      });

      _this.props.onHideOptions(event);
    };

    _this.handleHighlightOption = function (event, _ref) {
      var id = _ref.id;
      if (id === _this._emptyOptionId) return;

      var option = _this.getOption('id', id);

      var label = option.props.children;
      var inputValue = event.type === 'keydown' ? label : _this.state.inputValue;

      _this.setState({
        highlightedOptionId: id,
        inputValue: inputValue
      });
    };

    _this.handleSelectOption = function (event, _ref2) {
      var id = _ref2.id;

      if (id === _this._emptyOptionId) {
        // selected option is the empty option
        _this.setState({
          isShowingOptions: false
        });

        return;
      }

      var option = _this.getOption('id', id);

      var value = option && option.props.value;

      if (_this.isControlled) {
        _this.setState({
          isShowingOptions: false
        });
      } else {
        _this.setState(function (state) {
          return {
            isShowingOptions: false,
            selectedOptionId: id,
            inputValue: option ? option.props.children : state.inputValue
          };
        });
      } // fire onChange if selected option changed


      option && _this.props.onChange(event, {
        value: value,
        id: id
      }); // hide options list whenever selection is made

      _this.props.onHideOptions(event);
    };

    var _option = _this.getInitialOption(props);

    _this.state = {
      inputValue: _option ? _option.props.children : '',
      isShowingOptions: false,
      highlightedOptionId: null,
      selectedOptionId: _option ? _option.props.id : null
    };
    return _this;
  }

  _createClass(SimpleSelect, [{
    key: "focus",
    value: function focus() {
      this._select && this._select.focus();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props.value !== prevProps.value) {
        var option = this.getOption('value', this.props.value);

        if (typeof this.props.value === 'undefined') {
          // preserve current value when changing from controlled to uncontrolled
          option = this.getOption('value', prevProps.value);
        }

        this.setState({
          inputValue: option ? option.props.children : '',
          selectedOptionId: option ? option.props.id : ''
        });
      }
    }
  }, {
    key: "getInitialOption",
    value: function getInitialOption(props) {
      var value = props.value,
          defaultValue = props.defaultValue;
      var initialValue = value || defaultValue;

      if (typeof initialValue === 'string') {
        // get option based on value or defaultValue, if provided
        return this.getOption('value', initialValue);
      } // otherwise get the first option


      return this.getOptionByIndex(0);
    }
  }, {
    key: "getOptionLabelById",
    value: function getOptionLabelById(id) {
      var option = this.getOption('id', id);
      return option ? option.props.children : '';
    }
  }, {
    key: "getOptionByIndex",
    value: function getOptionByIndex(index) {
      var children = Children.toArray(this.props.children);
      var match = null;

      for (var i = 0; i < children.length; i++) {
        var child = children[i];

        if (matchComponentTypes(child, [Option])) {
          match = child;
        } else if (matchComponentTypes(child, [Group])) {
          // first child is a group, not an option, find first child in group
          match = Children.toArray(child.props.children)[0];
        }

        if (match) {
          break;
        }
      }

      return match;
    }
  }, {
    key: "getOption",
    value: function getOption(field, value) {
      var children = Children.toArray(this.props.children);
      var match = null;

      for (var i = 0; i < children.length; ++i) {
        var child = children[i];

        if (matchComponentTypes(child, [Option])) {
          if (child.props[field] === value) {
            match = child;
          }
        } else if (matchComponentTypes(child, [Group])) {
          var groupChildren = Children.toArray(child.props.children);

          for (var j = 0; j < groupChildren.length; ++j) {
            var groupChild = groupChildren[j];

            if (groupChild.props[field] === value) {
              match = groupChild;
              break;
            }
          }
        }

        if (match) break;
      }

      return match;
    }
  }, {
    key: "renderChildren",
    value: function renderChildren() {
      var _this2 = this;

      var children = Children.toArray(this.props.children);
      children = Children.map(children, function (child) {
        if (matchComponentTypes(child, [Option])) {
          return _this2.renderOption(child);
        } else if (matchComponentTypes(child, [Group])) {
          return _this2.renderGroup(child);
        }

        return null;
      }).filter(function (child) {
        return !!child;
      });

      if (children.length === 0) {
        // no valid children, render empty option
        return this.renderEmptyOption();
      }

      return children;
    }
  }, {
    key: "renderEmptyOption",
    value: function renderEmptyOption() {
      return /*#__PURE__*/React.createElement(Select.Option, {
        id: this._emptyOptionId,
        isHighlighted: false,
        isSelected: false
      }, callRenderProp(this.props.renderEmptyOption));
    }
  }, {
    key: "renderOption",
    value: function renderOption(option) {
      var _option$props = option.props,
          id = _option$props.id,
          value = _option$props.value,
          children = _option$props.children,
          renderBeforeLabel = _option$props.renderBeforeLabel,
          renderAfterLabel = _option$props.renderAfterLabel,
          rest = _objectWithoutProperties(_option$props, ["id", "value", "children", "renderBeforeLabel", "renderAfterLabel"]);

      return /*#__PURE__*/React.createElement(Select.Option, Object.assign({
        id: id,
        value: value,
        key: option.key || id,
        isHighlighted: id === this.state.highlightedOptionId,
        isSelected: id === this.state.selectedOptionId,
        isDisabled: option.props.isDisabled,
        renderBeforeLabel: renderBeforeLabel,
        renderAfterLabel: renderAfterLabel
      }, passthroughProps(rest)), children);
    }
  }, {
    key: "renderGroup",
    value: function renderGroup(group) {
      var _this3 = this;

      var _group$props = group.props,
          id = _group$props.id,
          renderLabel = _group$props.renderLabel,
          children = _group$props.children,
          rest = _objectWithoutProperties(_group$props, ["id", "renderLabel", "children"]);

      return /*#__PURE__*/React.createElement(Select.Group, Object.assign({
        renderLabel: renderLabel,
        key: group.key || id
      }, passthroughProps(rest)), Children.map(children, function (child) {
        return _this3.renderOption(child);
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          renderLabel = _this$props.renderLabel,
          value = _this$props.value,
          defaultValue = _this$props.defaultValue,
          id = _this$props.id,
          size = _this$props.size,
          assistiveText = _this$props.assistiveText,
          placeholder = _this$props.placeholder,
          interaction = _this$props.interaction,
          isRequired = _this$props.isRequired,
          isInline = _this$props.isInline,
          width = _this$props.width,
          optionsMaxWidth = _this$props.optionsMaxWidth,
          visibleOptionsCount = _this$props.visibleOptionsCount,
          messages = _this$props.messages,
          placement = _this$props.placement,
          constrain = _this$props.constrain,
          mountNode = _this$props.mountNode,
          inputRef = _this$props.inputRef,
          listRef = _this$props.listRef,
          renderEmptyOption = _this$props.renderEmptyOption,
          renderBeforeInput = _this$props.renderBeforeInput,
          renderAfterInput = _this$props.renderAfterInput,
          onFocus = _this$props.onFocus,
          onBlur = _this$props.onBlur,
          onShowOptions = _this$props.onShowOptions,
          onHideOptions = _this$props.onHideOptions,
          children = _this$props.children,
          rest = _objectWithoutProperties(_this$props, ["renderLabel", "value", "defaultValue", "id", "size", "assistiveText", "placeholder", "interaction", "isRequired", "isInline", "width", "optionsMaxWidth", "visibleOptionsCount", "messages", "placement", "constrain", "mountNode", "inputRef", "listRef", "renderEmptyOption", "renderBeforeInput", "renderAfterInput", "onFocus", "onBlur", "onShowOptions", "onHideOptions", "children"]);

      return /*#__PURE__*/React.createElement(Select, Object.assign({
        renderLabel: renderLabel,
        inputValue: this.state.inputValue,
        isShowingOptions: this.state.isShowingOptions,
        id: id,
        size: size,
        assistiveText: assistiveText,
        placeholder: placeholder,
        interaction: this.interaction,
        isRequired: isRequired,
        isInline: isInline,
        width: width,
        optionsMaxWidth: optionsMaxWidth,
        visibleOptionsCount: visibleOptionsCount,
        messages: messages,
        placement: placement,
        constrain: constrain,
        mountNode: mountNode,
        ref: this.handleRef,
        inputRef: inputRef,
        listRef: listRef,
        renderBeforeInput: renderBeforeInput,
        renderAfterInput: renderAfterInput,
        onFocus: onFocus,
        onBlur: this.handleBlur,
        onRequestShowOptions: this.handleShowOptions,
        onRequestHideOptions: this.handleHideOptions,
        onRequestHighlightOption: this.handleHighlightOption,
        onRequestSelectOption: this.handleSelectOption
      }, passthroughProps(rest)), this.renderChildren(children));
    }
  }, {
    key: "focused",
    get: function get() {
      return this._select && this._select.focused;
    }
  }, {
    key: "id",
    get: function get() {
      return this._select && this._select.id;
    }
  }, {
    key: "isControlled",
    get: function get() {
      return typeof this.props.value !== 'undefined';
    }
  }, {
    key: "interaction",
    get: function get() {
      return getInteraction({
        props: this.props
      });
    }
  }]);

  SimpleSelect.displayName = "SimpleSelect";
  return SimpleSelect;
}(Component), _class2.Option = Option, _class2.Group = Group, _class2.propTypes = {
  /**
   * The form field label.
   */
  renderLabel: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,

  /**
   * The value corresponding to the value of the selected option. If defined,
   * the component will act controlled and will not manage its own state.
   */
  value: controllable(PropTypes.string, 'onChange'),

  /**
   * The value of the option to select by default, when uncontrolled.
   */
  defaultValue: PropTypes.string,

  /**
   * The id of the text input. One is generated if not supplied.
   */
  id: PropTypes.string,

  /**
   * The size of the text input.
   */
  size: PropTypes.oneOf(['small', 'medium', 'large']),

  /**
   * Additional helpful text to provide to screen readers about the operation
   * of the component. Provided via aria-describedby.
   */
  assistiveText: PropTypes.string,

  /**
   * Html placeholder text to display when the input has no value. This should
   * be hint text, not a label replacement.
   */
  placeholder: PropTypes.string,

  /**
   * Specifies if interaction with the input is enabled, disabled, or readonly.
   * When "disabled", the input changes visibly to indicate that it cannot
   * receive user interactions. When "readonly" the input still cannot receive
   * user interactions but it keeps the same styles as if it were enabled.
   */
  interaction: PropTypes.oneOf(['enabled', 'disabled', 'readonly']),

  /**
   * Whether or not the text input is required.
   */
  isRequired: PropTypes.bool,

  /**
   * Whether the input is rendered inline with other elements or if it
   * is rendered as a block level element.
   */
  isInline: PropTypes.bool,

  /**
   * The width of the text input.
   */
  width: PropTypes.string,

  /**
   * The max width the options list can be before option text wraps. If not
   * set, the list will only display as wide as the text input.
   */
  optionsMaxWidth: PropTypes.string,

  /**
   * The number of options that should be visible before having to scroll.
   */
  visibleOptionsCount: PropTypes.number,

  /**
   * Displays messages and validation for the input. It should be an object
   * with the following shape:
   * `{
   *   text: PropTypes.string,
   *   type: PropTypes.oneOf(['error', 'hint', 'success', 'screenreader-only'])
   * }`
   */
  messages: PropTypes.arrayOf(FormPropTypes.message),

  /**
   * The placement of the options list.
   */
  placement: PositionPropTypes.placement,

  /**
   * The parent in which to constrain the placement.
   */
  constrain: PositionPropTypes.constrain,

  /**
   * An element or a function returning an element to use mount the options
   * list to in the DOM (defaults to `document.body`)
   */
  mountNode: PositionPropTypes.mountNode,

  /**
   * Callback fired when a new option is selected.
   * @param {Object} event - the event object
   * @param {Object} data - additional data
   * @param data.value - the value of selected option
   * @param data.id - the id of the selected option
   */
  onChange: PropTypes.func,

  /**
   * Callback fired when text input receives focus.
   */
  onFocus: PropTypes.func,

  /**
   * Callback fired when text input loses focus.
   */
  onBlur: PropTypes.func,

  /**
   * Callback fired when the options list is shown.
   */
  onShowOptions: PropTypes.func,

  /**
   * Callback fired when the options list is hidden.
   */
  onHideOptions: PropTypes.func,

  /**
   * A ref to the html `input` element.
   */
  inputRef: PropTypes.func,

  /**
   * A ref to the html `ul` element.
   */
  listRef: PropTypes.func,

  /**
   * Content to display in the list when no options are available.
   */
  renderEmptyOption: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

  /**
   * Content to display before the text input. This will commonly be an icon.
   */
  renderBeforeInput: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

  /**
   * Content to display after the text input. This content will replace the
   * default arrow icons.
   */
  renderAfterInput: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

  /**
   * Children of type `<SimpleSelect.Option />` or `<SimpleSelect.Group />`.
   */
  children: ChildrenPropTypes.oneOf([Group, Option])
}, _class2.defaultProps = {
  value: void 0,
  defaultValue: void 0,
  id: void 0,
  size: 'medium',
  assistiveText: void 0,
  placeholder: null,
  interaction: void 0,
  isRequired: false,
  isInline: false,
  width: void 0,
  optionsMaxWidth: void 0,
  visibleOptionsCount: 8,
  messages: void 0,
  placement: 'bottom stretch',
  mountNode: void 0,
  constrain: 'window',
  onChange: function onChange(event, data) {},
  onFocus: function onFocus(event) {},
  onBlur: function onBlur(event) {},
  onShowOptions: function onShowOptions(event) {},
  onHideOptions: function onHideOptions(event) {},
  inputRef: function inputRef(node) {},
  listRef: function listRef(node) {},
  renderEmptyOption: '---',
  renderBeforeInput: null,
  renderAfterInput: null,
  children: null
}, _temp)) || _class);
export { SimpleSelect };
export default SimpleSelect;
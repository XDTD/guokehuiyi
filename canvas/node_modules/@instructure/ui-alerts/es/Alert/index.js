import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";
import { error as _error } from "@instructure/console";

var _dec, _dec2, _class, _class2, _temp;

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types';
import classNames from 'classnames';
import keycode from 'keycode';
import { deprecated, callRenderProp } from '@instructure/ui-react-utils';
import { CloseButton } from '@instructure/ui-buttons';
import { View } from '@instructure/ui-view';
import { ScreenReaderContent } from '@instructure/ui-a11y-content';
import { IconCheckMarkSolid, IconInfoBorderlessSolid, IconWarningBorderlessSolid, IconNoSolid } from '@instructure/ui-icons';
import { Transition } from '@instructure/ui-motion';
import { themeable, ThemeablePropTypes } from '@instructure/ui-themeable';
import { uid } from '@instructure/uid';
var styles = {
  componentId: 'eMdva',
  template: function template(theme) {
    return "\n\n.eMdva_bgqc{background:".concat(theme.background || 'inherit', ";border-radius:").concat(theme.borderRadius || 'inherit', ";border-style:").concat(theme.borderStyle || 'inherit', ";border-width:").concat(theme.borderWidth || 'inherit', ";box-sizing:border-box;color:").concat(theme.color || 'inherit', ";display:flex;min-width:12rem}\n\n.eMdva_MrVJ{box-shadow:").concat(theme.boxShadow || 'inherit', "}\n\n.eMdva_caGd{box-sizing:border-box;flex:1;font-family:").concat(theme.contentFontFamily || 'inherit', ";font-size:").concat(theme.contentFontSize || 'inherit', ";font-weight:").concat(theme.contentFontWeight || 'inherit', ";line-height:").concat(theme.contentLineHeight || 'inherit', ";min-width:0.0625rem;padding:").concat(theme.contentPadding || 'inherit', "}\n\n.eMdva_dnnz{align-items:center;border-right:").concat(theme.borderWidth || 'inherit', " ").concat(theme.borderStyle || 'inherit', ";color:").concat(theme.iconColor || 'inherit', ";flex:0 0 2.5rem;font-size:1.125rem;justify-content:center}\n\n.eMdva_fsGh,.eMdva_dnnz{box-sizing:border-box;display:flex}\n\n.eMdva_fsGh{align-items:flex-start;margin-right:").concat(theme.closeButtonMarginRight || 'inherit', ";margin-top:").concat(theme.closeButtonMarginTop || 'inherit', ";order:1}\n\n.eMdva_cOXX{border-color:").concat(theme.successBorderColor || 'inherit', "}\n\n.eMdva_cOXX .eMdva_dnnz{background-color:").concat(theme.successIconBackground || 'inherit', ";border-right-color:").concat(theme.successIconBackground || 'inherit', "}\n\n.eMdva_pypk{border-color:").concat(theme.infoBorderColor || 'inherit', "}\n\n.eMdva_pypk .eMdva_dnnz{background:").concat(theme.infoIconBackground || 'inherit', ";border-right-color:").concat(theme.infoIconBackground || 'inherit', "}\n\n.eMdva_ddvR{border-color:").concat(theme.dangerBorderColor || 'inherit', "}\n\n.eMdva_ddvR .eMdva_dnnz{background:").concat(theme.dangerIconBackground || 'inherit', ";border-right-color:").concat(theme.dangerIconBackground || 'inherit', "}\n\n.eMdva_eRqw{border-color:").concat(theme.warningBorderColor || 'inherit', "}\n\n.eMdva_eRqw .eMdva_dnnz{background:").concat(theme.warningIconBackground || 'inherit', ";border-right-color:").concat(theme.warningIconBackground || 'inherit', "}");
  },
  'alert': 'eMdva_bgqc',
  'hasShadow': 'eMdva_MrVJ',
  'content': 'eMdva_caGd',
  'icon': 'eMdva_dnnz',
  'closeButton': 'eMdva_fsGh',
  'success': 'eMdva_cOXX',
  'info': 'eMdva_pypk',
  'error': 'eMdva_ddvR',
  'warning': 'eMdva_eRqw'
};
import theme from "./theme.js";
/**
---
category: components
---
**/

var Alert = (_dec = deprecated('8.0.0', {
  closeButtonLabel: 'renderCloseButtonLabel'
}), _dec2 = themeable(theme, styles), _dec(_class = _dec2(_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
  _inherits(Alert, _Component);

  var _super = _createSuper(Alert);

  function Alert(props) {
    var _this;

    _classCallCheck(this, Alert);

    _this = _super.call(this, props);
    _this._timeouts = [];

    _this.handleTimeout = function () {
      if (_this.props.timeout > 0) {
        _this._timeouts.push(setTimeout(function () {
          _this.close();
        }, _this.props.timeout));
      }
    };

    _this.onExitTransition = function () {
      if (_this.props.onDismiss) {
        _this.props.onDismiss();
      }
    };

    _this.close = function () {
      _this.clearTimeouts();

      _this.removeScreenreaderAlert();

      _this.setState({
        open: false
      }, function () {
        if (_this.props.onDismiss && _this.props.transition === 'none') {
          _this.props.onDismiss();
        }
      });
    };

    _this.handleKeyUp = function (event) {
      if ((_this.props.renderCloseButtonLabel || _this.props.closeButtonLabel) && event.keyCode === keycode.codes.esc) {
        _this.close();
      }
    };

    _this.state = {
      open: true
    };
    return _this;
  }

  _createClass(Alert, [{
    key: "variantUI",
    value: function variantUI() {
      return {
        error: {
          Icon: IconNoSolid,
          className: styles.error
        },
        info: {
          Icon: IconInfoBorderlessSolid,
          className: styles.info
        },
        success: {
          Icon: IconCheckMarkSolid,
          className: styles.success
        },
        warning: {
          Icon: IconWarningBorderlessSolid,
          className: styles.warning
        }
      }[this.props.variant];
    }
  }, {
    key: "clearTimeouts",
    value: function clearTimeouts() {
      this._timeouts.forEach(function (timeout) {
        return clearTimeout(timeout);
      });

      this._timeouts = [];
    }
  }, {
    key: "isDOMNode",
    // duck type for a dom node
    value: function isDOMNode(n) {
      return n && typeof n === 'object' && n.nodeType === 1;
    }
  }, {
    key: "getLiveRegion",
    value: function getLiveRegion() {
      var lr = null;

      if (typeof this.props.liveRegion === 'function') {
        lr = this.props.liveRegion();
      }

      return this.isDOMNode(lr) ? lr : null;
    }
  }, {
    key: "initLiveRegion",
    value: function initLiveRegion(liveRegion) {
      /*#__PURE__*/

      /*#__PURE__*/
      _error(liveRegion.getAttribute('role') === 'alert', "[Alert] live region must have role='alert' set on page load in order to announce content");

      if (liveRegion) {
        liveRegion.setAttribute('aria-live', this.props.liveRegionPoliteness);
        liveRegion.setAttribute('aria-relevant', 'additions text');
        liveRegion.setAttribute('aria-atomic', this.props.isLiveRegionAtomic);
      }
    }
  }, {
    key: "createScreenreaderContentNode",
    value: function createScreenreaderContentNode() {
      return /*#__PURE__*/React.createElement(ScreenReaderContent, null, this.props.children);
    }
  }, {
    key: "createScreenreaderAlert",
    value: function createScreenreaderAlert() {
      var liveRegion = this.getLiveRegion();

      if (liveRegion) {
        this.srid = uid('Alert');
        var div = document.createElement('div');
        div.setAttribute('id', this.srid);
        var content = this.createScreenreaderContentNode();
        ReactDOM.render(content, div);
        liveRegion.appendChild(div);
      }
    }
  }, {
    key: "updateScreenreaderAlert",
    value: function updateScreenreaderAlert() {
      var _this2 = this;

      if (this.getLiveRegion()) {
        var div = document.getElementById(this.srid);

        if (div) {
          ReactDOM.render(null, div, function () {
            var content = _this2.createScreenreaderContentNode();

            ReactDOM.render(content, div);
          });
        }
      }
    }
  }, {
    key: "removeScreenreaderAlert",
    value: function removeScreenreaderAlert() {
      var liveRegion = this.getLiveRegion();

      if (liveRegion) {
        var div = document.getElementById(this.srid);

        if (div) {
          // Accessibility attributes must be removed for the deletion of the node
          // and then reapplied because JAWS/IE will not respect the
          // "aria-relevant" attribute and read when the node is deleted if
          // the attributes are in place
          liveRegion.removeAttribute('aria-live');
          liveRegion.removeAttribute('aria-relevant');
          liveRegion.removeAttribute('aria-atomic');
          ReactDOM.unmountComponentAtNode(div);
          div.parentNode.removeChild(div);
          this.initLiveRegion(liveRegion);
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var liveRegion = this.getLiveRegion();

      if (liveRegion) {
        this.initLiveRegion(liveRegion);
      }

      this.handleTimeout();
      this.createScreenreaderAlert();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (!!this.props.open === false && !!this.props.open !== !!prevProps.open) {
        // this outside world is asking us to close the alert, which needs to
        // take place internally so the transition runs
        this.close();
      } else {
        if (this.props.children !== prevProps.children) {
          this.updateScreenreaderAlert();
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.removeScreenreaderAlert();
      this.clearTimeouts();
    }
  }, {
    key: "renderIcon",
    value: function renderIcon() {
      var _this$variantUI = this.variantUI(),
          Icon = _this$variantUI.Icon;

      return /*#__PURE__*/React.createElement("div", {
        className: styles.icon
      }, /*#__PURE__*/React.createElement(Icon, {
        className: styles.alertIcon
      }));
    }
  }, {
    key: "renderCloseButton",
    value: function renderCloseButton() {
      var closeButtonLabel = this.props.renderCloseButtonLabel && callRenderProp(this.props.renderCloseButtonLabel) || this.props.closeButtonLabel;
      return closeButtonLabel ? /*#__PURE__*/React.createElement("div", {
        className: styles.closeButton,
        key: "closeButton"
      }, /*#__PURE__*/React.createElement(CloseButton, {
        onClick: this.close,
        size: "small",
        screenReaderLabel: closeButtonLabel
      })) : null;
    }
  }, {
    key: "renderAlert",
    value: function renderAlert() {
      var _classNames;

      var _this$variantUI2 = this.variantUI(),
          className = _this$variantUI2.className;

      var classes = classNames((_classNames = {}, _defineProperty(_classNames, styles.alert, true), _defineProperty(_classNames, className, true), _defineProperty(_classNames, styles.hasShadow, this.props.hasShadow), _classNames));
      return /*#__PURE__*/React.createElement(View, {
        as: "div",
        margin: this.props.margin,
        className: classes,
        onKeyUp: this.handleKeyUp
      }, this.renderIcon(), /*#__PURE__*/React.createElement("div", {
        className: styles.content
      }, this.props.children), this.renderCloseButton());
    }
  }, {
    key: "render",
    value: function render() {
      // Don't render anything if screen reader only
      if (this.props.screenReaderOnly) {
        /*#__PURE__*/

        /*#__PURE__*/
        _error(this.getLiveRegion(), "[Alert] The 'screenReaderOnly' prop must be used in conjunction with 'liveRegion'.");

        return null;
      }

      if (this.props.transition === 'none') {
        return this.state.open ? this.renderAlert() : null;
      }

      return /*#__PURE__*/React.createElement(Transition, {
        type: this.props.transition,
        transitionOnMount: true,
        in: this.state.open,
        unmountOnExit: true,
        onExited: this.onExitTransition
      }, this.renderAlert());
    }
  }]);

  Alert.displayName = "Alert";
  return Alert;
}(Component), _class2.propTypes = {
  /**
   * content to be rendered within Alert
   */
  children: PropTypes.node,

  /**
   * Determines color and icon
   */
  variant: PropTypes.oneOf(['info', 'success', 'warning', 'error']),

  /**
   * Valid values are `0`, `none`, `auto`, `xxx-small`, `xx-small`, `x-small`,
   * `small`, `medium`, `large`, `x-large`, `xx-large`. Apply these values via
   * familiar CSS-like shorthand. For example: `margin="small auto large"`.
   */
  margin: ThemeablePropTypes.spacing,

  /**
   * Function that returns the DIV where screenreader alerts will be placed.
   */
  liveRegion: PropTypes.func,

  /**
   * Choose the politeness level of screenreader alerts.
   */
  liveRegionPoliteness: PropTypes.oneOf(['polite', 'assertive']),

  /**
   * If the screenreader alert should be atomic
   */
  isLiveRegionAtomic: PropTypes.bool,

  /**
   * If the alert should only be visible to screen readers
   */
  screenReaderOnly: PropTypes.bool,

  /**
   * Milliseconds until the Alert is dismissed automatically
   */
  timeout: PropTypes.number,

  /**
   * Close button label. Can be a React component
   */
  renderCloseButtonLabel: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),

  /**
   * __Deprecated - use `renderCloseButtonLabel` instead__
   */
  closeButtonLabel: PropTypes.string,

  /**
   * Callback after the alert is closed
   */
  onDismiss: PropTypes.func,

  /**
   * Transition used to make the alert appear and disappear
   */
  transition: PropTypes.oneOf(['none', 'fade']),

  /**
   * if open transitions from truthy to falsey, it's a signal to close and unmount the alert.
   * This is necessary to close the alert from the outside and still run the transition.
   */
  open: PropTypes.bool,

  /**
   * If the alert should have a shadow.
   */
  hasShadow: PropTypes.bool
}, _class2.defaultProps = {
  variant: 'info',
  margin: 'x-small 0',
  timeout: 0,
  transition: 'fade',
  open: true,
  screenReaderOnly: false,
  liveRegionPoliteness: 'assertive',
  isLiveRegionAtomic: false,
  onDismiss: void 0,
  liveRegion: void 0,
  renderCloseButtonLabel: void 0,
  closeButtonLabel: void 0,
  children: null,
  hasShadow: true
}, _temp)) || _class) || _class);
export default Alert;
export { Alert };
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";
import { error as _error } from "@instructure/console";

var _dec, _dec2, _class, _class2, _temp;

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import React, { Children, Component } from 'react';
import PropTypes from 'prop-types';
import keycode from 'keycode';
import { Popover } from '@instructure/ui-popover';
import { uid } from '@instructure/uid';
import { controllable, Children as ChildrenPropTypes } from '@instructure/ui-prop-types';
import { PositionPropTypes } from '@instructure/ui-position';
import { safeCloneElement, matchComponentTypes } from '@instructure/ui-react-utils';
import { themeable } from '@instructure/ui-themeable';
import { containsActiveElement } from '@instructure/ui-dom-utils';
import { testable } from '@instructure/ui-testable';
import { MenuContext } from '../MenuContext';
import { MenuItem } from './MenuItem';
import { MenuItemGroup } from './MenuItemGroup';
import { MenuItemSeparator } from './MenuItemSeparator';
var styles = {
  componentId: 'cAqHo',
  template: function template(theme) {
    return "\n\n.cAqHo_eAjd{background:".concat(theme.background || 'inherit', ";display:block;list-style-type:none;margin:0;max-width:").concat(theme.maxWidth || 'inherit', ";min-width:").concat(theme.minWidth || 'inherit', ";padding:0.25rem 0;position:relative}\n\n.cAqHo_eAjd:before{border:").concat(theme.focusBorderWidth || 'inherit', " ").concat(theme.focusBorderStyle || 'inherit', " ").concat(theme.focusBorderColor || 'inherit', ";border-radius:").concat(theme.focusBorderRadius || 'inherit', ";bottom:-0.25rem;content:\"\";left:-0.25rem;opacity:0;pointer-events:none;position:absolute;right:-0.25rem;top:-0.25rem;transform:scale(0.9)}\n\n.cAqHo_eAjd:focus{outline:none}\n\n.cAqHo_eAjd:focus:before{opacity:1;transform:scale(1)}");
  },
  'menu': 'cAqHo_eAjd'
};
import theme from './theme';
/**
---
category: components
---
**/

var Menu = (_dec = testable(), _dec2 = themeable(theme, styles), _dec(_class = _dec2(_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
  _inherits(Menu, _Component);

  var _super = _createSuper(Menu);

  function Menu(props) {
    var _this;

    _classCallCheck(this, Menu);

    _this = _super.call(this, props);
    _this.state = {
      hasFocus: false
    };
    _this._rootNode = null;
    _this._menuItems = [];
    _this._popover = null;
    _this._trigger = null;
    _this._menu = null;
    _this._labelId = uid('Menu__label');
    _this._activeSubMenu = null;

    _this.getMenuItemIndex = function (item) {
      return _this._menuItems.findIndex(function (i) {
        return i === item;
      });
    };

    _this.handleTriggerKeyDown = function (event) {
      if (_this.props.type === 'flyout' && event.keyCode === keycode.codes.right) {
        event.persist();

        _this.show();
      }
    };

    _this.handleTriggerMouseOver = function () {
      if (_this.props.type === 'flyout') {
        _this.show();
      }
    };

    _this.handleToggle = function (shown) {
      if (typeof _this.props.onToggle === 'function') {
        _this.props.onToggle(shown, _assertThisInitialized(_this));
      }
    };

    _this.handleMenuKeyDown = function (event) {
      var key = event && event.keyCode;
      var _keycode$codes = keycode.codes,
          down = _keycode$codes.down,
          up = _keycode$codes.up,
          pgup = _keycode$codes.pgup,
          pgdn = _keycode$codes.pgdn,
          tab = _keycode$codes.tab,
          left = _keycode$codes.left;

      if (key === down || key === pgdn) {
        event.preventDefault();
        event.stopPropagation();

        _this.moveFocus(1);

        _this.hideActiveSubMenu(event);
      } else if (key === up || key === pgup) {
        event.preventDefault();
        event.stopPropagation();

        _this.moveFocus(-1);

        _this.hideActiveSubMenu(event);
      } else if (key === tab || key === left) {
        event.persist();

        _this.hide(event);
      }

      if (typeof _this.props.onKeyDown === 'function') {
        _this.props.onKeyDown(event);
      }
    };

    _this.handleMenuItemSelect = function (event, value, selected, item) {
      if (_this.props.shouldHideOnSelect) {
        _this.hide(event);
      }

      if (typeof _this.props.onSelect === 'function') {
        _this.props.onSelect(event, value, selected, item);
      }
    };

    _this.handleMenuItemFocus = function () {
      _this.setState({
        hasFocus: true
      });
    };

    _this.handleMenuItemBlur = function () {
      _this.setState({
        hasFocus: _this.focusedIndex >= 0
      });
    };

    _this.handleMenuItemMouseOver = function (event, menuItem) {
      if (_this._activeSubMenu && menuItem !== _this._activeSubMenu._trigger) {
        _this.hideActiveSubMenu(event);
      }
    };

    _this.hideActiveSubMenu = function (event) {
      if (_this._activeSubMenu) {
        _this._activeSubMenu.hide(event);

        _this._activeSubMenu = null;
      }
    };

    _this.handleSubMenuToggle = function (shown, subMenu) {
      if (shown) {
        _this._activeSubMenu = subMenu;
      }
    };

    _this.handleSubMenuDismiss = function (event, documentClick) {
      if (event && event.keyCode === keycode.codes.tab || documentClick) {
        _this.hide(event);
      }
    };

    _this.hide = function (event) {
      if (_this._popover) {
        _this._popover.hide(event);
      }
    };

    _this.show = function (event) {
      if (_this._popover) {
        _this._popover.show(event);
      }
    };

    _this._id = _this.props.id || uid('Menu');
    return _this;
  }

  _createClass(Menu, [{
    key: "getChildContext",
    value: function getChildContext() {
      var _this2 = this;

      // if it's a submenu it will have a context defined by its parent Menu
      var context = MenuContext.getMenuContext(this.context);
      return MenuContext.makeMenuContext({
        registerMenuItem: function registerMenuItem(item) {
          var type = item.props.type; // if the item is a flyout trigger
          // we only want to add it to the parent Menu items list

          if (context && context.registerMenuItem && type === 'flyout') {
            context.registerMenuItem(item);
          } else if (_this2.getMenuItemIndex(item) < 0) {
            _this2._menuItems.push(item);
          }
        },
        removeMenuItem: function removeMenuItem(item) {
          var type = item.props.type; // if the item is a flyout trigger
          // we only want to remove it from the parent Menu items list

          if (context && context.removeMenuItem && type === 'flyout') {
            context.removeMenuItem(item);
          } else {
            var index = _this2.getMenuItemIndex(item);

            /*#__PURE__*/

            /*#__PURE__*/
            _error(index >= 0, '[Menu] Could not find registered menu item.');

            if (index >= 0) {
              _this2._menuItems.splice(index, 1);
            }
          }
        }
      });
    }
  }, {
    key: "focus",
    value: function focus() {
      if (this.shown) {
        /*#__PURE__*/

        /*#__PURE__*/
        _error(this._menu && this._menu.focus, '[Menu] Could not focus the menu.');

        this._menu.focus();
      } else {
        /*#__PURE__*/

        /*#__PURE__*/
        _error(this._trigger && this._trigger.focus, '[Menu] Could not focus the trigger.');

        this._trigger.focus();
      }
    }
  }, {
    key: "focused",
    value: function focused() {
      if (this.shown) {
        return containsActiveElement(this._menu) || this.state.hasFocus;
      } else {
        return containsActiveElement(this._trigger);
      }
    }
  }, {
    key: "moveFocus",
    value: function moveFocus(step) {
      var count = this.menuItems ? this.menuItems.length : 0;

      if (count <= 0) {
        return;
      }

      var current = this.focusedIndex < 0 && step < 0 ? 0 : this.focusedIndex;
      var nextItem = this.menuItems[(current + count + step) % count];

      /*#__PURE__*/

      /*#__PURE__*/
      _error(nextItem && nextItem.focus, '[Menu] Could not focus next menu item.');

      nextItem.focus();
    }
  }, {
    key: "renderChildren",
    value: function renderChildren() {
      var _this3 = this;

      var _this$props = this.props,
          children = _this$props.children,
          disabled = _this$props.disabled;
      var count = 0;
      return Children.map(children, function (child) {
        if (!matchComponentTypes(child, ['MenuItemSeparator', 'MenuItem', 'MenuItemGroup', 'Menu'])) {
          return;
        }

        count += 1;
        var isTabbable = !_this3.state.hasFocus && count === 1;

        if (matchComponentTypes(child, ['MenuItemSeparator'])) {
          return /*#__PURE__*/React.createElement("li", {
            role: "none"
          }, child);
        }

        var controls = child.props['aria-controls'] || child.props.controls || _this3.props['aria-controls'] || // eslint-disable-line react/prop-types
        _this3.props.controls // eslint-disable-line react/prop-types
        ;

        if (matchComponentTypes(child, ['MenuItem'])) {
          return /*#__PURE__*/React.createElement("li", {
            role: "none"
          }, safeCloneElement(child, {
            controls: controls,
            disabled: disabled || child.props.disabled,
            onFocus: _this3.handleMenuItemFocus,
            onBlur: _this3.handleMenuItemBlur,
            onSelect: _this3.handleMenuItemSelect,
            onMouseOver: _this3.handleMenuItemMouseOver,
            tabIndex: isTabbable ? 0 : -1
          }));
        }

        if (matchComponentTypes(child, ['MenuItemGroup'])) {
          return /*#__PURE__*/React.createElement("li", {
            role: "none"
          }, safeCloneElement(child, {
            controls: controls,
            disabled: disabled || child.props.disabled,
            onFocus: _this3.handleMenuItemFocus,
            onBlur: _this3.handleMenuItemBlur,
            onSelect: _this3.handleMenuItemSelect,
            onMouseOver: _this3.handleMenuItemMouseOver,
            isTabbable: isTabbable
          }));
        }

        if (matchComponentTypes(child, ['Menu'])) {
          var submenuDisabled = disabled || child.props.disabled;
          return /*#__PURE__*/React.createElement("li", {
            role: "none"
          }, safeCloneElement(child, {
            type: 'flyout',
            controls: controls,
            disabled: submenuDisabled,
            onSelect: _this3.handleMenuItemSelect,
            placement: 'end top',
            offsetX: -5,
            offsetY: 5,
            withArrow: false,
            onToggle: _this3.handleSubMenuToggle,
            onDismiss: _this3.handleSubMenuDismiss,
            trigger: /*#__PURE__*/React.createElement(MenuItem, {
              onMouseOver: _this3.handleMenuItemMouseOver,
              onFocus: _this3.handleMenuItemFocus,
              onBlur: _this3.handleMenuItemBlur,
              tabIndex: isTabbable ? 0 : -1,
              type: "flyout",
              disabled: submenuDisabled
            }, child.props.title || child.props.label)
          }));
        }
      });
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this4 = this;

      var _this$props2 = this.props,
          menuRef = _this$props2.menuRef,
          disabled = _this$props2.disabled,
          label = _this$props2.label,
          trigger = _this$props2.trigger,
          onKeyUp = _this$props2.onKeyUp,
          contentRef = _this$props2.contentRef;
      var labelledBy = this.props['aria-labelledby']; // eslint-disable-line react/prop-types

      var controls = this.props['aria-controls']; // eslint-disable-line react/prop-types

      return /*#__PURE__*/React.createElement("ul", {
        role: "menu",
        "aria-label": label,
        tabIndex: "0",
        className: styles.menu,
        "aria-labelledby": labelledBy || trigger && this._labelId,
        "aria-controls": controls,
        "aria-disabled": disabled ? 'true' : null,
        onKeyDown: this.handleMenuKeyDown,
        onKeyUp: onKeyUp,
        ref: function ref(el) {
          _this4._menu = el;

          if (typeof menuRef === 'function') {
            menuRef(el);
          }

          if (typeof contentRef === 'function') {
            contentRef(el);
          }
        }
      }, this.renderChildren());
    }
  }, {
    key: "render",
    value: function render() {
      var _this5 = this;

      var _this$props3 = this.props,
          show = _this$props3.show,
          defaultShow = _this$props3.defaultShow,
          placement = _this$props3.placement,
          withArrow = _this$props3.withArrow,
          trigger = _this$props3.trigger,
          mountNode = _this$props3.mountNode,
          popoverRef = _this$props3.popoverRef,
          disabled = _this$props3.disabled,
          onDismiss = _this$props3.onDismiss,
          onFocus = _this$props3.onFocus,
          onMouseOver = _this$props3.onMouseOver;
      return trigger ? /*#__PURE__*/React.createElement(Popover, {
        isShowingContent: show,
        defaultIsShowingContent: defaultShow,
        onHideContent: function onHideContent(event, _ref) {
          var documentClick = _ref.documentClick;
          onDismiss(event, documentClick);

          _this5.handleToggle(false);
        },
        onShowContent: function onShowContent() {
          return _this5.handleToggle(true);
        },
        mountNode: mountNode,
        placement: placement,
        withArrow: withArrow,
        id: this._id,
        on: ['click'],
        shouldContainFocus: true,
        shouldReturnFocus: true,
        onFocus: onFocus,
        onMouseOver: onMouseOver,
        ref: function ref(el) {
          _this5._popover = el;

          if (typeof popoverRef === 'function') {
            popoverRef(el);
          }
        },
        renderTrigger: safeCloneElement(trigger, {
          ref: function ref(el) {
            _this5._trigger = el;
          },
          'aria-haspopup': true,
          id: this._labelId,
          onMouseOver: this.handleTriggerMouseOver,
          onKeyDown: this.handleTriggerKeyDown,
          disabled: trigger.props.disabled || disabled
        })
      }, this.renderMenu()) : this.renderMenu();
    }
  }, {
    key: "menuItems",
    get: function get() {
      return this._menuItems;
    }
  }, {
    key: "focusedIndex",
    get: function get() {
      return this.menuItems.findIndex(function (item) {
        return item && item.focused === true;
      });
    }
  }, {
    key: "shown",
    get: function get() {
      return this._popover ? this._popover.shown : true;
    }
  }]);

  Menu.displayName = "Menu";
  return Menu;
}(Component), _class2.propTypes = {
  /**
   * Children of type `Menu.Item`, `Menu.Group`, `Menu.Separator`, or `Menu`
   */
  children: ChildrenPropTypes.oneOf(['MenuItem', 'MenuItemGroup', 'MenuItemSeparator', 'Menu']),

  /**
   * Description of the `<Menu />`
   */
  label: PropTypes.string,

  /**
   * Is the `<Menu />` disabled
   */
  disabled: PropTypes.bool,

  /**
   * The trigger element, if the `<Menu />` is to render as a popover
   */
  trigger: PropTypes.node,

  /**
   * If a trigger is supplied, where should the `<Menu />` be placed (relative to the trigger)
   */
  placement: PositionPropTypes.placement,

  /**
   * Should the `<Menu />` be open for the initial render
   */
  defaultShow: PropTypes.bool,

  /**
   * Is the `<Menu />` open (should be accompanied by `onToggle`)
   */
  show: controllable(PropTypes.bool, 'onToggle', 'defaultShow'),

  /**
   * Callback fired when the `<Menu />` is toggled open/closed. When used with `show`,
   * the component will not control its own state.
   */
  onToggle: PropTypes.func,

  /**
   * Callback fired when an item within the `<Menu />` is selected
   */
  onSelect: PropTypes.func,

  /**
   * If a trigger is supplied, callback fired when the `<Menu />` is closed
   */
  onDismiss: PropTypes.func,

  /**
   * If a trigger is supplied, callback fired when the `<Menu />` trigger is blurred
   */
  onBlur: PropTypes.func,

  /**
   * If a trigger is supplied, callback fired when the `<Menu />` trigger is focused
   */
  onFocus: PropTypes.func,

  /**
   * If a trigger is supplied, callback fired onMouseOver for the `<Menu />` trigger
   */
  onMouseOver: PropTypes.func,

  /**
   * Callback fired on the onKeyDown of the `<Menu />`
   */
  onKeyDown: PropTypes.func,

  /**
   * Callback fired on the onKeyUp of the `<Menu />`
   */
  onKeyUp: PropTypes.func,

  /*
   * A function that returns a reference to the `<Menu />`
   */
  menuRef: PropTypes.func,

  /**
   * A function that returns a reference to the `<Popover />`
   */
  popoverRef: PropTypes.func,

  /**
   * If a trigger is supplied, an element or a function returning an element to use as the mount node
   * for the `<Menu />` (defaults to `document.body`)
   */
  mountNode: PositionPropTypes.mountNode,

  /**
   * The parent in which to constrain the menu.
   * One of: 'window', 'scroll-parent', 'parent', 'none', an element,
   * or a function returning an element
   */
  constrain: PositionPropTypes.constrain,

  /**
   * If a trigger is supplied, an element, function returning an element, or array of elements that will not
   * be hidden from the screen reader when the `<Menu />` is open
   */
  liveRegion: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.element), PropTypes.element, PropTypes.func]),

  /**
   * If a trigger is supplied, should the `<Menu />` hide when an item is selected
   */
  shouldHideOnSelect: PropTypes.bool,

  /**
   * If a trigger is supplied, should the `<Menu />` focus the trigger on after closing
   */
  shouldFocusTriggerOnClose: PropTypes.bool,

  /**
   * The type of `<Menu />`
   */
  type: PropTypes.oneOf(['flyout']),
  id: PropTypes.string,

  /**
  * Whether or not an arrow pointing to the trigger should be rendered
  */
  withArrow: PropTypes.bool
}, _class2.defaultProps = {
  children: null,
  label: null,
  disabled: false,
  trigger: null,
  placement: 'bottom center',
  defaultShow: false,
  onToggle: function onToggle(shown, menu) {},
  onSelect: function onSelect(event, value, selected, item) {},
  onDismiss: function onDismiss(event, documentClick) {},
  onBlur: function onBlur(event) {},
  onFocus: function onFocus(event) {},
  onMouseOver: function onMouseOver(event) {},
  onKeyDown: function onKeyDown(event) {},
  onKeyUp: function onKeyUp(event) {},
  menuRef: function menuRef(el) {},
  popoverRef: function popoverRef(el) {},
  mountNode: null,
  constrain: 'window',
  liveRegion: null,
  shouldHideOnSelect: true,
  shouldFocusTriggerOnClose: true,
  show: void 0,
  id: void 0,
  type: void 0,
  withArrow: true
}, _class2.Item = MenuItem, _class2.Group = MenuItemGroup, _class2.Separator = MenuItemSeparator, _class2.childContextTypes = MenuContext.types, _class2.contextTypes = MenuContext.types, _temp)) || _class) || _class);
export default Menu;
export { Menu, MenuItem, MenuItemGroup, MenuItemSeparator };
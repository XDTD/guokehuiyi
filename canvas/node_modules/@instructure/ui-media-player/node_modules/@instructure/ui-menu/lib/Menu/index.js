"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "MenuItem", {
  enumerable: true,
  get: function get() {
    return _MenuItem.MenuItem;
  }
});
Object.defineProperty(exports, "MenuItemGroup", {
  enumerable: true,
  get: function get() {
    return _MenuItemGroup.MenuItemGroup;
  }
});
Object.defineProperty(exports, "MenuItemSeparator", {
  enumerable: true,
  get: function get() {
    return _MenuItemSeparator.MenuItemSeparator;
  }
});
exports.Menu = exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _createSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/createSuper"));

var _console = require("@instructure/console");

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _keycode = _interopRequireDefault(require("keycode"));

var _Popover = require("@instructure/ui-popover/lib/Popover");

var _uid = require("@instructure/uid");

var _controllable = require("@instructure/ui-prop-types/lib/controllable.js");

var _Children = require("@instructure/ui-prop-types/lib/Children.js");

var _PositionPropTypes = require("@instructure/ui-position/lib/PositionPropTypes.js");

var _safeCloneElement = require("@instructure/ui-react-utils/lib/safeCloneElement.js");

var _matchComponentTypes = require("@instructure/ui-react-utils/lib/matchComponentTypes.js");

var _themeable = require("@instructure/ui-themeable/lib/themeable.js");

var _containsActiveElement = require("@instructure/ui-dom-utils/lib/containsActiveElement.js");

var _testable = require("@instructure/ui-testable/lib/testable.js");

var _MenuContext = require("../MenuContext");

var _MenuItem = require("./MenuItem");

var _MenuItemGroup = require("./MenuItemGroup");

var _MenuItemSeparator = require("./MenuItemSeparator");

var _theme = _interopRequireDefault(require("./theme"));

var _dec, _dec2, _class, _class2, _temp;

var styles = {
  componentId: 'cAqHo',
  template: function template(theme) {
    return "\n\n.cAqHo_eAjd{background:".concat(theme.background || 'inherit', ";display:block;list-style-type:none;margin:0;max-width:").concat(theme.maxWidth || 'inherit', ";min-width:").concat(theme.minWidth || 'inherit', ";padding:0.25rem 0;position:relative}\n\n.cAqHo_eAjd:before{border:").concat(theme.focusBorderWidth || 'inherit', " ").concat(theme.focusBorderStyle || 'inherit', " ").concat(theme.focusBorderColor || 'inherit', ";border-radius:").concat(theme.focusBorderRadius || 'inherit', ";bottom:-0.25rem;content:\"\";left:-0.25rem;opacity:0;pointer-events:none;position:absolute;right:-0.25rem;top:-0.25rem;transform:scale(0.9)}\n\n.cAqHo_eAjd:focus{outline:none}\n\n.cAqHo_eAjd:focus:before{opacity:1;transform:scale(1)}");
  },
  'menu': 'cAqHo_eAjd'
};

/**
---
category: components
---
**/
var Menu = (_dec = (0, _testable.testable)(), _dec2 = (0, _themeable.themeable)(_theme.default, styles), _dec(_class = _dec2(_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
  (0, _inherits2.default)(Menu, _Component);

  var _super = (0, _createSuper2.default)(Menu);

  function Menu(props) {
    var _this;

    (0, _classCallCheck2.default)(this, Menu);
    _this = _super.call(this, props);
    _this.state = {
      hasFocus: false
    };
    _this._rootNode = null;
    _this._menuItems = [];
    _this._popover = null;
    _this._trigger = null;
    _this._menu = null;
    _this._labelId = (0, _uid.uid)('Menu__label');
    _this._activeSubMenu = null;

    _this.getMenuItemIndex = function (item) {
      return _this._menuItems.findIndex(function (i) {
        return i === item;
      });
    };

    _this.handleTriggerKeyDown = function (event) {
      if (_this.props.type === 'flyout' && event.keyCode === _keycode.default.codes.right) {
        event.persist();

        _this.show();
      }
    };

    _this.handleTriggerMouseOver = function () {
      if (_this.props.type === 'flyout') {
        _this.show();
      }
    };

    _this.handleToggle = function (shown) {
      if (typeof _this.props.onToggle === 'function') {
        _this.props.onToggle(shown, (0, _assertThisInitialized2.default)(_this));
      }
    };

    _this.handleMenuKeyDown = function (event) {
      var key = event && event.keyCode;
      var _keycode$codes = _keycode.default.codes,
          down = _keycode$codes.down,
          up = _keycode$codes.up,
          pgup = _keycode$codes.pgup,
          pgdn = _keycode$codes.pgdn,
          tab = _keycode$codes.tab,
          left = _keycode$codes.left;

      if (key === down || key === pgdn) {
        event.preventDefault();
        event.stopPropagation();

        _this.moveFocus(1);

        _this.hideActiveSubMenu(event);
      } else if (key === up || key === pgup) {
        event.preventDefault();
        event.stopPropagation();

        _this.moveFocus(-1);

        _this.hideActiveSubMenu(event);
      } else if (key === tab || key === left) {
        event.persist();

        _this.hide(event);
      }

      if (typeof _this.props.onKeyDown === 'function') {
        _this.props.onKeyDown(event);
      }
    };

    _this.handleMenuItemSelect = function (event, value, selected, item) {
      if (_this.props.shouldHideOnSelect) {
        _this.hide(event);
      }

      if (typeof _this.props.onSelect === 'function') {
        _this.props.onSelect(event, value, selected, item);
      }
    };

    _this.handleMenuItemFocus = function () {
      _this.setState({
        hasFocus: true
      });
    };

    _this.handleMenuItemBlur = function () {
      _this.setState({
        hasFocus: _this.focusedIndex >= 0
      });
    };

    _this.handleMenuItemMouseOver = function (event, menuItem) {
      if (_this._activeSubMenu && menuItem !== _this._activeSubMenu._trigger) {
        _this.hideActiveSubMenu(event);
      }
    };

    _this.hideActiveSubMenu = function (event) {
      if (_this._activeSubMenu) {
        _this._activeSubMenu.hide(event);

        _this._activeSubMenu = null;
      }
    };

    _this.handleSubMenuToggle = function (shown, subMenu) {
      if (shown) {
        _this._activeSubMenu = subMenu;
      }
    };

    _this.handleSubMenuDismiss = function (event, documentClick) {
      if (event && event.keyCode === _keycode.default.codes.tab || documentClick) {
        _this.hide(event);
      }
    };

    _this.hide = function (event) {
      if (_this._popover) {
        _this._popover.hide(event);
      }
    };

    _this.show = function (event) {
      if (_this._popover) {
        _this._popover.show(event);
      }
    };

    _this._id = _this.props.id || (0, _uid.uid)('Menu');
    return _this;
  }

  (0, _createClass2.default)(Menu, [{
    key: "getChildContext",
    value: function getChildContext() {
      var _this2 = this;

      // if it's a submenu it will have a context defined by its parent Menu
      var context = _MenuContext.MenuContext.getMenuContext(this.context);

      return _MenuContext.MenuContext.makeMenuContext({
        registerMenuItem: function registerMenuItem(item) {
          var type = item.props.type; // if the item is a flyout trigger
          // we only want to add it to the parent Menu items list

          if (context && context.registerMenuItem && type === 'flyout') {
            context.registerMenuItem(item);
          } else if (_this2.getMenuItemIndex(item) < 0) {
            _this2._menuItems.push(item);
          }
        },
        removeMenuItem: function removeMenuItem(item) {
          var type = item.props.type; // if the item is a flyout trigger
          // we only want to remove it from the parent Menu items list

          if (context && context.removeMenuItem && type === 'flyout') {
            context.removeMenuItem(item);
          } else {
            var index = _this2.getMenuItemIndex(item);

            /*#__PURE__*/
            ( /*#__PURE__*/0, _console.error)(index >= 0, '[Menu] Could not find registered menu item.');

            if (index >= 0) {
              _this2._menuItems.splice(index, 1);
            }
          }
        }
      });
    }
  }, {
    key: "focus",
    value: function focus() {
      if (this.shown) {
        /*#__PURE__*/
        ( /*#__PURE__*/0, _console.error)(this._menu && this._menu.focus, '[Menu] Could not focus the menu.');

        this._menu.focus();
      } else {
        /*#__PURE__*/
        ( /*#__PURE__*/0, _console.error)(this._trigger && this._trigger.focus, '[Menu] Could not focus the trigger.');

        this._trigger.focus();
      }
    }
  }, {
    key: "focused",
    value: function focused() {
      if (this.shown) {
        return (0, _containsActiveElement.containsActiveElement)(this._menu) || this.state.hasFocus;
      } else {
        return (0, _containsActiveElement.containsActiveElement)(this._trigger);
      }
    }
  }, {
    key: "moveFocus",
    value: function moveFocus(step) {
      var count = this.menuItems ? this.menuItems.length : 0;

      if (count <= 0) {
        return;
      }

      var current = this.focusedIndex < 0 && step < 0 ? 0 : this.focusedIndex;
      var nextItem = this.menuItems[(current + count + step) % count];

      /*#__PURE__*/
      ( /*#__PURE__*/0, _console.error)(nextItem && nextItem.focus, '[Menu] Could not focus next menu item.');
      nextItem.focus();
    }
  }, {
    key: "renderChildren",
    value: function renderChildren() {
      var _this3 = this;

      var _this$props = this.props,
          children = _this$props.children,
          disabled = _this$props.disabled;
      var count = 0;
      return _react.Children.map(children, function (child) {
        if (!(0, _matchComponentTypes.matchComponentTypes)(child, ['MenuItemSeparator', 'MenuItem', 'MenuItemGroup', 'Menu'])) {
          return;
        }

        count += 1;
        var isTabbable = !_this3.state.hasFocus && count === 1;

        if ((0, _matchComponentTypes.matchComponentTypes)(child, ['MenuItemSeparator'])) {
          return /*#__PURE__*/_react.default.createElement("li", {
            role: "none"
          }, child);
        }

        var controls = child.props['aria-controls'] || child.props.controls || _this3.props['aria-controls'] || // eslint-disable-line react/prop-types
        _this3.props.controls // eslint-disable-line react/prop-types
        ;

        if ((0, _matchComponentTypes.matchComponentTypes)(child, ['MenuItem'])) {
          return /*#__PURE__*/_react.default.createElement("li", {
            role: "none"
          }, (0, _safeCloneElement.safeCloneElement)(child, {
            controls: controls,
            disabled: disabled || child.props.disabled,
            onFocus: _this3.handleMenuItemFocus,
            onBlur: _this3.handleMenuItemBlur,
            onSelect: _this3.handleMenuItemSelect,
            onMouseOver: _this3.handleMenuItemMouseOver,
            tabIndex: isTabbable ? 0 : -1
          }));
        }

        if ((0, _matchComponentTypes.matchComponentTypes)(child, ['MenuItemGroup'])) {
          return /*#__PURE__*/_react.default.createElement("li", {
            role: "none"
          }, (0, _safeCloneElement.safeCloneElement)(child, {
            controls: controls,
            disabled: disabled || child.props.disabled,
            onFocus: _this3.handleMenuItemFocus,
            onBlur: _this3.handleMenuItemBlur,
            onSelect: _this3.handleMenuItemSelect,
            onMouseOver: _this3.handleMenuItemMouseOver,
            isTabbable: isTabbable
          }));
        }

        if ((0, _matchComponentTypes.matchComponentTypes)(child, ['Menu'])) {
          var submenuDisabled = disabled || child.props.disabled;
          return /*#__PURE__*/_react.default.createElement("li", {
            role: "none"
          }, (0, _safeCloneElement.safeCloneElement)(child, {
            type: 'flyout',
            controls: controls,
            disabled: submenuDisabled,
            onSelect: _this3.handleMenuItemSelect,
            placement: 'end top',
            offsetX: -5,
            offsetY: 5,
            withArrow: false,
            onToggle: _this3.handleSubMenuToggle,
            onDismiss: _this3.handleSubMenuDismiss,
            trigger: /*#__PURE__*/_react.default.createElement(_MenuItem.MenuItem, {
              onMouseOver: _this3.handleMenuItemMouseOver,
              onFocus: _this3.handleMenuItemFocus,
              onBlur: _this3.handleMenuItemBlur,
              tabIndex: isTabbable ? 0 : -1,
              type: "flyout",
              disabled: submenuDisabled
            }, child.props.title || child.props.label)
          }));
        }
      });
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this4 = this;

      var _this$props2 = this.props,
          menuRef = _this$props2.menuRef,
          disabled = _this$props2.disabled,
          label = _this$props2.label,
          trigger = _this$props2.trigger,
          onKeyUp = _this$props2.onKeyUp,
          contentRef = _this$props2.contentRef;
      var labelledBy = this.props['aria-labelledby']; // eslint-disable-line react/prop-types

      var controls = this.props['aria-controls']; // eslint-disable-line react/prop-types

      return /*#__PURE__*/_react.default.createElement("ul", {
        role: "menu",
        "aria-label": label,
        tabIndex: "0",
        className: styles.menu,
        "aria-labelledby": labelledBy || trigger && this._labelId,
        "aria-controls": controls,
        "aria-disabled": disabled ? 'true' : null,
        onKeyDown: this.handleMenuKeyDown,
        onKeyUp: onKeyUp,
        ref: function ref(el) {
          _this4._menu = el;

          if (typeof menuRef === 'function') {
            menuRef(el);
          }

          if (typeof contentRef === 'function') {
            contentRef(el);
          }
        }
      }, this.renderChildren());
    }
  }, {
    key: "render",
    value: function render() {
      var _this5 = this;

      var _this$props3 = this.props,
          show = _this$props3.show,
          defaultShow = _this$props3.defaultShow,
          placement = _this$props3.placement,
          withArrow = _this$props3.withArrow,
          trigger = _this$props3.trigger,
          mountNode = _this$props3.mountNode,
          popoverRef = _this$props3.popoverRef,
          disabled = _this$props3.disabled,
          onDismiss = _this$props3.onDismiss,
          onFocus = _this$props3.onFocus,
          onMouseOver = _this$props3.onMouseOver;
      return trigger ? /*#__PURE__*/_react.default.createElement(_Popover.Popover, {
        isShowingContent: show,
        defaultIsShowingContent: defaultShow,
        onHideContent: function onHideContent(event, _ref) {
          var documentClick = _ref.documentClick;
          onDismiss(event, documentClick);

          _this5.handleToggle(false);
        },
        onShowContent: function onShowContent() {
          return _this5.handleToggle(true);
        },
        mountNode: mountNode,
        placement: placement,
        withArrow: withArrow,
        id: this._id,
        on: ['click'],
        shouldContainFocus: true,
        shouldReturnFocus: true,
        onFocus: onFocus,
        onMouseOver: onMouseOver,
        ref: function ref(el) {
          _this5._popover = el;

          if (typeof popoverRef === 'function') {
            popoverRef(el);
          }
        },
        renderTrigger: (0, _safeCloneElement.safeCloneElement)(trigger, {
          ref: function ref(el) {
            _this5._trigger = el;
          },
          'aria-haspopup': true,
          id: this._labelId,
          onMouseOver: this.handleTriggerMouseOver,
          onKeyDown: this.handleTriggerKeyDown,
          disabled: trigger.props.disabled || disabled
        })
      }, this.renderMenu()) : this.renderMenu();
    }
  }, {
    key: "menuItems",
    get: function get() {
      return this._menuItems;
    }
  }, {
    key: "focusedIndex",
    get: function get() {
      return this.menuItems.findIndex(function (item) {
        return item && item.focused === true;
      });
    }
  }, {
    key: "shown",
    get: function get() {
      return this._popover ? this._popover.shown : true;
    }
  }]);
  Menu.displayName = "Menu";
  return Menu;
}(_react.Component), _class2.propTypes = {
  /**
   * Children of type `Menu.Item`, `Menu.Group`, `Menu.Separator`, or `Menu`
   */
  children: _Children.Children.oneOf(['MenuItem', 'MenuItemGroup', 'MenuItemSeparator', 'Menu']),

  /**
   * Description of the `<Menu />`
   */
  label: _propTypes.default.string,

  /**
   * Is the `<Menu />` disabled
   */
  disabled: _propTypes.default.bool,

  /**
   * The trigger element, if the `<Menu />` is to render as a popover
   */
  trigger: _propTypes.default.node,

  /**
   * If a trigger is supplied, where should the `<Menu />` be placed (relative to the trigger)
   */
  placement: _PositionPropTypes.PositionPropTypes.placement,

  /**
   * Should the `<Menu />` be open for the initial render
   */
  defaultShow: _propTypes.default.bool,

  /**
   * Is the `<Menu />` open (should be accompanied by `onToggle`)
   */
  show: (0, _controllable.controllable)(_propTypes.default.bool, 'onToggle', 'defaultShow'),

  /**
   * Callback fired when the `<Menu />` is toggled open/closed. When used with `show`,
   * the component will not control its own state.
   */
  onToggle: _propTypes.default.func,

  /**
   * Callback fired when an item within the `<Menu />` is selected
   */
  onSelect: _propTypes.default.func,

  /**
   * If a trigger is supplied, callback fired when the `<Menu />` is closed
   */
  onDismiss: _propTypes.default.func,

  /**
   * If a trigger is supplied, callback fired when the `<Menu />` trigger is blurred
   */
  onBlur: _propTypes.default.func,

  /**
   * If a trigger is supplied, callback fired when the `<Menu />` trigger is focused
   */
  onFocus: _propTypes.default.func,

  /**
   * If a trigger is supplied, callback fired onMouseOver for the `<Menu />` trigger
   */
  onMouseOver: _propTypes.default.func,

  /**
   * Callback fired on the onKeyDown of the `<Menu />`
   */
  onKeyDown: _propTypes.default.func,

  /**
   * Callback fired on the onKeyUp of the `<Menu />`
   */
  onKeyUp: _propTypes.default.func,

  /*
   * A function that returns a reference to the `<Menu />`
   */
  menuRef: _propTypes.default.func,

  /**
   * A function that returns a reference to the `<Popover />`
   */
  popoverRef: _propTypes.default.func,

  /**
   * If a trigger is supplied, an element or a function returning an element to use as the mount node
   * for the `<Menu />` (defaults to `document.body`)
   */
  mountNode: _PositionPropTypes.PositionPropTypes.mountNode,

  /**
   * The parent in which to constrain the menu.
   * One of: 'window', 'scroll-parent', 'parent', 'none', an element,
   * or a function returning an element
   */
  constrain: _PositionPropTypes.PositionPropTypes.constrain,

  /**
   * If a trigger is supplied, an element, function returning an element, or array of elements that will not
   * be hidden from the screen reader when the `<Menu />` is open
   */
  liveRegion: _propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.element), _propTypes.default.element, _propTypes.default.func]),

  /**
   * If a trigger is supplied, should the `<Menu />` hide when an item is selected
   */
  shouldHideOnSelect: _propTypes.default.bool,

  /**
   * If a trigger is supplied, should the `<Menu />` focus the trigger on after closing
   */
  shouldFocusTriggerOnClose: _propTypes.default.bool,

  /**
   * The type of `<Menu />`
   */
  type: _propTypes.default.oneOf(['flyout']),
  id: _propTypes.default.string,

  /**
  * Whether or not an arrow pointing to the trigger should be rendered
  */
  withArrow: _propTypes.default.bool
}, _class2.defaultProps = {
  children: null,
  label: null,
  disabled: false,
  trigger: null,
  placement: 'bottom center',
  defaultShow: false,
  onToggle: function onToggle(shown, menu) {},
  onSelect: function onSelect(event, value, selected, item) {},
  onDismiss: function onDismiss(event, documentClick) {},
  onBlur: function onBlur(event) {},
  onFocus: function onFocus(event) {},
  onMouseOver: function onMouseOver(event) {},
  onKeyDown: function onKeyDown(event) {},
  onKeyUp: function onKeyUp(event) {},
  menuRef: function menuRef(el) {},
  popoverRef: function popoverRef(el) {},
  mountNode: null,
  constrain: 'window',
  liveRegion: null,
  shouldHideOnSelect: true,
  shouldFocusTriggerOnClose: true,
  show: void 0,
  id: void 0,
  type: void 0,
  withArrow: true
}, _class2.Item = _MenuItem.MenuItem, _class2.Group = _MenuItemGroup.MenuItemGroup, _class2.Separator = _MenuItemSeparator.MenuItemSeparator, _class2.childContextTypes = _MenuContext.MenuContext.types, _class2.contextTypes = _MenuContext.MenuContext.types, _temp)) || _class) || _class);
exports.Menu = Menu;
var _default = Menu;
exports.default = _default;
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TruncateText = exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _createSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/createSuper"));

var _console = require("@instructure/console");

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _themeable = require("@instructure/ui-themeable/lib/themeable.js");

var _debounce = require("@instructure/debounce");

var _addResizeListener = require("@instructure/ui-dom-utils/lib/addResizeListener.js");

var _canUseDOM = require("@instructure/ui-dom-utils/lib/canUseDOM.js");

var _safeCloneElement = require("@instructure/ui-react-utils/lib/safeCloneElement.js");

var _ensureSingleChild = require("@instructure/ui-react-utils/lib/ensureSingleChild.js");

var _hack = require("@instructure/ui-react-utils/lib/hack.js");

var _testable = require("@instructure/ui-testable/lib/testable.js");

var _truncate2 = _interopRequireDefault(require("./utils/truncate"));

var _theme = _interopRequireDefault(require("./theme"));

var _dec, _dec2, _dec3, _class, _class2, _temp;

var styles = {
  componentId: 'bjXfh',
  template: function template(theme) {
    return "\n\n.bjXfh_daKB{display:block;font-family:".concat(theme.fontFamily || 'inherit', ";overflow:hidden;word-wrap:break-word}\n\n.bjXfh_uUeq{height:100%}\n\n.bjXfh_exvv{display:block;max-height:0;visibility:hidden}");
  },
  'truncated': 'bjXfh_daKB',
  'auto': 'bjXfh_uUeq',
  'spacer': 'bjXfh_exvv'
};

/**
---
category: components
---
**/
var TruncateText = (_dec = (0, _testable.testable)(), _dec2 = (0, _themeable.themeable)(_theme.default, styles), _dec3 = (0, _hack.hack)(['shouldTruncateWhenInvisible']), _dec(_class = _dec2(_class = _dec3(_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
  (0, _inherits2.default)(TruncateText, _Component);

  var _super = (0, _createSuper2.default)(TruncateText);

  function TruncateText(props) {
    var _this;

    (0, _classCallCheck2.default)(this, TruncateText);
    _this = _super.call(this, props);

    _this.update = function () {
      if (_this._ref) {
        _this.setState(_this.initialState);
      }
    };

    _this.state = _this.initialState;
    return _this;
  }

  (0, _createClass2.default)(TruncateText, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var children = this.props.children;

      if (children) {
        this.checkChildren();
        this._text = (0, _ensureSingleChild.ensureSingleChild)(children);
        this.truncate();

        if (this.props.debounce === 0) {
          this._resizeListener = (0, _addResizeListener.addResizeListener)(this._ref, this.update);
        } else {
          this._debounced = (0, _debounce.debounce)(this.update, this.props.debounce, {
            leading: true,
            trailing: true
          });
          this._resizeListener = (0, _addResizeListener.addResizeListener)(this._ref, this._debounced);
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this._resizeListener) {
        this._resizeListener.remove();
      }

      if (this._debounced) {
        this._debounced.cancel();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var _this$props = this.props,
          children = _this$props.children,
          onUpdate = _this$props.onUpdate;
      var _this$state = this.state,
          isTruncated = _this$state.isTruncated,
          needsSecondRender = _this$state.needsSecondRender,
          truncatedText = _this$state.truncatedText;

      if (children) {
        if (prevProps !== this.props) {
          if (prevProps.children !== this.props.children) {
            // reset internal text variable if children change
            this.checkChildren();
            this._text = (0, _ensureSingleChild.ensureSingleChild)(children);
          } // require the double render whenever props change


          this.setState(this.initialState);
          return;
        }

        if (!needsSecondRender && (isTruncated || this._wasTruncated)) {
          onUpdate(isTruncated, truncatedText);
          this._wasTruncated = isTruncated;
        } else {
          this.truncate();
        }
      }
    }
  }, {
    key: "checkChildren",
    value: function checkChildren() {
      var _this2 = this;

      /*#__PURE__*/
      ( /*#__PURE__*/0, _console.error)(! /*#__PURE__*/function () {
        var isTooDeep = false;
        var text = (0, _ensureSingleChild.ensureSingleChild)(_this2.props.children);

        _react.default.Children.forEach(text.props.children, /*#__PURE__*/function (child) {
          if (child.props) {
            _react.default.Children.forEach(child.props.children, /*#__PURE__*/function (grandChild) {
              // currently we don't support node trees deeper than 2 levels
              // truncation will still occur on their text content, but their actual node structure will be lost
              if (grandChild.props) {
                isTooDeep = true;
              }
            });
          }
        });

        return isTooDeep;
      }(), "[TruncateText] Some children are too deep in the node tree and will not render.");
    }
  }, {
    key: "truncate",
    value: function truncate() {
      if (!this.state.needsSecondRender) {
        return;
      }

      if (_canUseDOM.canUseDOM) {
        var result = (0, _truncate2.default)(this._stage, (0, _objectSpread2.default)({}, this.props, {
          parent: this._ref,
          lineHeight: this.theme.lineHeight
        }));

        if (result) {
          var element = this.renderChildren(result.isTruncated, result.data, result.constraints.width);
          this.setState({
            needsSecondRender: false,
            isTruncated: result.isTruncated,
            truncatedElement: element,
            truncatedText: result.text
          });
        }
      } else {
        // if dom isn't available, use original children
        this.setState({
          needsSecondRender: false,
          isTruncated: false,
          truncatedElement: this._text,
          truncatedText: this._ref.textContent
        });
      }
    }
  }, {
    key: "renderChildren",
    value: function renderChildren(truncated, data, width) {
      if (!truncated) {
        return this._text;
      }

      var childElements = []; // iterate over each node used in the truncated string

      for (var i = 0; i < data.length; i++) {
        var item = data[i];
        var element = this._text.props.children[i];
        var nodeText = item.join('');

        if (element && element.props) {
          // if node is an html element and not just a string
          childElements.push((0, _safeCloneElement.safeCloneElement)(element, element.props, nodeText));
        } else {
          childElements.push(nodeText);
        }
      } // this spacer element is set to the max width the full text could potentially be
      // without this, text in `width: auto` elements won't expand to accomodate more text, once truncated


      childElements.push( /*#__PURE__*/_react.default.createElement("span", {
        className: styles.spacer,
        style: {
          width: width || null
        }
      }));

      var children = _react.default.Children.map(childElements, function (child) {
        return child;
      });

      return this._text.props ? (0, _safeCloneElement.safeCloneElement)(this._text, this._text.props, children) : children;
    }
  }, {
    key: "render",
    value: function render() {
      var _classNames,
          _this3 = this;

      var truncatedElement = this.state.truncatedElement;
      var _this$props2 = this.props,
          maxLines = _this$props2.maxLines,
          children = _this$props2.children;
      return /*#__PURE__*/_react.default.createElement("span", {
        className: (0, _classnames.default)((_classNames = {}, (0, _defineProperty2.default)(_classNames, styles.truncated, true), (0, _defineProperty2.default)(_classNames, styles.auto, maxLines === 'auto'), _classNames)),
        ref: function ref(el) {
          _this3._ref = el;
        }
      }, children && (truncatedElement ? null : /*#__PURE__*/_react.default.createElement("span", {
        ref: function ref(el) {
          _this3._stage = el;
        }
      }, (0, _ensureSingleChild.ensureSingleChild)(children))), truncatedElement);
    }
  }, {
    key: "initialState",
    get: function get() {
      return {
        isTruncated: false,
        needsSecondRender: true,
        truncatedElement: null,
        truncatedText: null
      };
    }
  }]);
  TruncateText.displayName = "TruncateText";
  return TruncateText;
}(_react.Component), _class2.propTypes = {
  /**
  * The content to be truncated.
  */
  children: _propTypes.default.node.isRequired,

  /**
  * Number of lines to allow before truncating. `auto` will fit to parent
  */
  maxLines: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),

  /**
  * Where to place the ellipsis within the string
  */
  position: _propTypes.default.oneOf(['end', 'middle']),

  /**
  * Add ellipsis after words or after any character
  */
  truncate: _propTypes.default.oneOf(['character', 'word']),

  /**
  * A string to use as the ellipsis
  */
  ellipsis: _propTypes.default.string,

  /**
  * Characters to ignore at truncated end of string
  */
  ignore: _propTypes.default.arrayOf(_propTypes.default.string),

  /**
  * Debounce delay in milliseconds
  */
  debounce: _propTypes.default.number,

  /**
  * Callback when truncated text has changed
  */
  onUpdate: _propTypes.default.func,

  /**
   * Force truncation of invisible elements (hack; will be removed in favor
   * of a better fix)
   */
  // eslint-disable-next-line react/require-default-props
  shouldTruncateWhenInvisible: _propTypes.default.bool
}, _class2.defaultProps = {
  maxLines: 1,
  ellipsis: "\u2026",
  truncate: 'character',
  position: 'end',
  ignore: [' ', '.', ','],
  debounce: 0,
  onUpdate: function onUpdate(truncated, text) {}
}, _temp)) || _class) || _class) || _class);
exports.TruncateText = TruncateText;
var _default = TruncateText;
exports.default = _default;
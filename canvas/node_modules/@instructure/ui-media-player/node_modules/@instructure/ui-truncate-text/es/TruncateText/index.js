import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";
import { error as _error } from "@instructure/console";

var _dec, _dec2, _dec3, _class, _class2, _temp;

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import classNames from 'classnames';
import { themeable } from '@instructure/ui-themeable';
import { debounce } from '@instructure/debounce';
import { addResizeListener, canUseDOM } from '@instructure/ui-dom-utils';
import { safeCloneElement, ensureSingleChild, hack } from '@instructure/ui-react-utils';
import { testable } from '@instructure/ui-testable';
import _truncate from './utils/truncate';
var styles = {
  componentId: 'bjXfh',
  template: function template(theme) {
    return "\n\n.bjXfh_daKB{display:block;font-family:".concat(theme.fontFamily || 'inherit', ";overflow:hidden;word-wrap:break-word}\n\n.bjXfh_uUeq{height:100%}\n\n.bjXfh_exvv{display:block;max-height:0;visibility:hidden}");
  },
  'truncated': 'bjXfh_daKB',
  'auto': 'bjXfh_uUeq',
  'spacer': 'bjXfh_exvv'
};
import theme from './theme';
/**
---
category: components
---
**/

var TruncateText = (_dec = testable(), _dec2 = themeable(theme, styles), _dec3 = hack(['shouldTruncateWhenInvisible']), _dec(_class = _dec2(_class = _dec3(_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
  _inherits(TruncateText, _Component);

  var _super = _createSuper(TruncateText);

  function TruncateText(props) {
    var _this;

    _classCallCheck(this, TruncateText);

    _this = _super.call(this, props);

    _this.update = function () {
      if (_this._ref) {
        _this.setState(_this.initialState);
      }
    };

    _this.state = _this.initialState;
    return _this;
  }

  _createClass(TruncateText, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var children = this.props.children;

      if (children) {
        this.checkChildren();
        this._text = ensureSingleChild(children);
        this.truncate();

        if (this.props.debounce === 0) {
          this._resizeListener = addResizeListener(this._ref, this.update);
        } else {
          this._debounced = debounce(this.update, this.props.debounce, {
            leading: true,
            trailing: true
          });
          this._resizeListener = addResizeListener(this._ref, this._debounced);
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this._resizeListener) {
        this._resizeListener.remove();
      }

      if (this._debounced) {
        this._debounced.cancel();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var _this$props = this.props,
          children = _this$props.children,
          onUpdate = _this$props.onUpdate;
      var _this$state = this.state,
          isTruncated = _this$state.isTruncated,
          needsSecondRender = _this$state.needsSecondRender,
          truncatedText = _this$state.truncatedText;

      if (children) {
        if (prevProps !== this.props) {
          if (prevProps.children !== this.props.children) {
            // reset internal text variable if children change
            this.checkChildren();
            this._text = ensureSingleChild(children);
          } // require the double render whenever props change


          this.setState(this.initialState);
          return;
        }

        if (!needsSecondRender && (isTruncated || this._wasTruncated)) {
          onUpdate(isTruncated, truncatedText);
          this._wasTruncated = isTruncated;
        } else {
          this.truncate();
        }
      }
    }
  }, {
    key: "checkChildren",
    value: function checkChildren() {
      var _this2 = this;

      /*#__PURE__*/

      /*#__PURE__*/
      _error(! /*#__PURE__*/function () {
        var isTooDeep = false;
        var text = ensureSingleChild(_this2.props.children);
        React.Children.forEach(text.props.children, /*#__PURE__*/function (child) {
          if (child.props) {
            React.Children.forEach(child.props.children, /*#__PURE__*/function (grandChild) {
              // currently we don't support node trees deeper than 2 levels
              // truncation will still occur on their text content, but their actual node structure will be lost
              if (grandChild.props) {
                isTooDeep = true;
              }
            });
          }
        });
        return isTooDeep;
      }(), "[TruncateText] Some children are too deep in the node tree and will not render.");
    }
  }, {
    key: "truncate",
    value: function truncate() {
      if (!this.state.needsSecondRender) {
        return;
      }

      if (canUseDOM) {
        var result = _truncate(this._stage, _objectSpread({}, this.props, {
          parent: this._ref,
          lineHeight: this.theme.lineHeight
        }));

        if (result) {
          var element = this.renderChildren(result.isTruncated, result.data, result.constraints.width);
          this.setState({
            needsSecondRender: false,
            isTruncated: result.isTruncated,
            truncatedElement: element,
            truncatedText: result.text
          });
        }
      } else {
        // if dom isn't available, use original children
        this.setState({
          needsSecondRender: false,
          isTruncated: false,
          truncatedElement: this._text,
          truncatedText: this._ref.textContent
        });
      }
    }
  }, {
    key: "renderChildren",
    value: function renderChildren(truncated, data, width) {
      if (!truncated) {
        return this._text;
      }

      var childElements = []; // iterate over each node used in the truncated string

      for (var i = 0; i < data.length; i++) {
        var item = data[i];
        var element = this._text.props.children[i];
        var nodeText = item.join('');

        if (element && element.props) {
          // if node is an html element and not just a string
          childElements.push(safeCloneElement(element, element.props, nodeText));
        } else {
          childElements.push(nodeText);
        }
      } // this spacer element is set to the max width the full text could potentially be
      // without this, text in `width: auto` elements won't expand to accomodate more text, once truncated


      childElements.push( /*#__PURE__*/React.createElement("span", {
        className: styles.spacer,
        style: {
          width: width || null
        }
      }));
      var children = React.Children.map(childElements, function (child) {
        return child;
      });
      return this._text.props ? safeCloneElement(this._text, this._text.props, children) : children;
    }
  }, {
    key: "render",
    value: function render() {
      var _classNames,
          _this3 = this;

      var truncatedElement = this.state.truncatedElement;
      var _this$props2 = this.props,
          maxLines = _this$props2.maxLines,
          children = _this$props2.children;
      return /*#__PURE__*/React.createElement("span", {
        className: classNames((_classNames = {}, _defineProperty(_classNames, styles.truncated, true), _defineProperty(_classNames, styles.auto, maxLines === 'auto'), _classNames)),
        ref: function ref(el) {
          _this3._ref = el;
        }
      }, children && (truncatedElement ? null : /*#__PURE__*/React.createElement("span", {
        ref: function ref(el) {
          _this3._stage = el;
        }
      }, ensureSingleChild(children))), truncatedElement);
    }
  }, {
    key: "initialState",
    get: function get() {
      return {
        isTruncated: false,
        needsSecondRender: true,
        truncatedElement: null,
        truncatedText: null
      };
    }
  }]);

  TruncateText.displayName = "TruncateText";
  return TruncateText;
}(Component), _class2.propTypes = {
  /**
  * The content to be truncated.
  */
  children: PropTypes.node.isRequired,

  /**
  * Number of lines to allow before truncating. `auto` will fit to parent
  */
  maxLines: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
  * Where to place the ellipsis within the string
  */
  position: PropTypes.oneOf(['end', 'middle']),

  /**
  * Add ellipsis after words or after any character
  */
  truncate: PropTypes.oneOf(['character', 'word']),

  /**
  * A string to use as the ellipsis
  */
  ellipsis: PropTypes.string,

  /**
  * Characters to ignore at truncated end of string
  */
  ignore: PropTypes.arrayOf(PropTypes.string),

  /**
  * Debounce delay in milliseconds
  */
  debounce: PropTypes.number,

  /**
  * Callback when truncated text has changed
  */
  onUpdate: PropTypes.func,

  /**
   * Force truncation of invisible elements (hack; will be removed in favor
   * of a better fix)
   */
  // eslint-disable-next-line react/require-default-props
  shouldTruncateWhenInvisible: PropTypes.bool
}, _class2.defaultProps = {
  maxLines: 1,
  ellipsis: "\u2026",
  truncate: 'character',
  position: 'end',
  ignore: [' ', '.', ','],
  debounce: 0,
  onUpdate: function onUpdate(truncated, text) {}
}, _temp)) || _class) || _class) || _class);
export default TruncateText;
export { TruncateText };
import * as React from 'react';

export type ContextViewHeight = string | number;

export type ContextViewWidth = string | number;

export type ContextViewMaxHeight = string | number;

export type ContextViewMaxWidth = string | number;

export type ContextViewMinHeight = string | number;

export type ContextViewMinWidth = string | number;

export type ContextViewTextAlign = "start" | "center" | "end";

export type ContextViewBackground = "default" | "inverse";

export interface ContextViewProps {
    /**
     * The element to render as the component root
     */
    as?: any;
    /**
     * provides a reference to the underlying html root element
     */
    elementRef?: (...args: any[])=>any;
    /**
     * Valid values are `0`, `none`, `auto`, `xxx-small`, `xx-small`, `x-small`,
     * `small`, `medium`, `large`, `x-large`, `xx-large`. Apply these values via
     * familiar CSS-like shorthand. For example: `margin="small auto large"`.
     */
    margin?: any;
    /**
     * Valid values are `0`, `none`, `xxx-small`, `xx-small`, `x-small`,
     * `small`, `medium`, `large`, `x-large`, `xx-large`. Apply these values via
     * familiar CSS-like shorthand. For example: `padding="small x-large large"`.
     */
    padding?: any;
    height?: ContextViewHeight;
    width?: ContextViewWidth;
    maxHeight?: ContextViewMaxHeight;
    maxWidth?: ContextViewMaxWidth;
    minHeight?: ContextViewMinHeight;
    minWidth?: ContextViewMinWidth;
    /**
     * The children to render inside the `<ContextView />`
     */
    children?: React.ReactNode;
    /**
     * Designates the text alignment within the `<ContextView />`
     */
    textAlign?: ContextViewTextAlign;
    /**
     * Controls the shadow depth for the `<ContextView />`
     */
    shadow?: any;
    /**
     * Controls the z-index depth for the `<ContextView />`
     */
    stacking?: any;
    /**
     * Designates the background style of the `<ContextView />`
     */
    background?: ContextViewBackground;
    /**
     * Specifies how the arrow for `<ContextView />` will be rendered.
     * Ex. `placement="top"` will render with an arrow pointing down.
     */
    placement?: any;
    /**
     * Activate an outline around the component to make building your
     * layout easier
     */
    debug?: boolean;
}

export class ContextView extends React.Component<ContextViewProps, any> {
    render(): JSX.Element;

}




export type ViewDisplay = "auto" | "inline" | "block" | "inline-block" | "flex" | "inline-flex";

export type ViewOverflowX = "auto" | "hidden" | "visible";

export type ViewOverflowY = "auto" | "hidden" | "visible";

export type ViewHeight = string | number;

export type ViewWidth = string | number;

export type ViewMaxHeight = string | number;

export type ViewMaxWidth = string | number;

export type ViewMinHeight = string | number;

export type ViewMinWidth = string | number;

export type ViewTextAlign = "start" | "center" | "end";

export type ViewPosition = "static" | "absolute" | "relative" | "sticky" | "fixed";

export type ViewFocusPosition = "offset" | "inset";

export type ViewFocusColor = "info" | "inverse" | "success" | "danger";

export interface ViewProps {
    /**
     * The element to render as the component root, `span` by default
     */
    as?: any;
    /**
     * provides a reference to the underlying html element
     */
    elementRef?: (...args: any[])=>any;
    /**
     * By default the display prop is 'auto', meaning it takes on the
     * display rules of the html element it's rendered as (see `as` prop).
     */
    display?: ViewDisplay;
    overflowX?: ViewOverflowX;
    overflowY?: ViewOverflowY;
    /**
     * Valid values are `0`, `none`, `auto`, `xxx-small`, `xx-small`, `x-small`,
     * `small`, `medium`, `large`, `x-large`, `xx-large`. Apply these values via
     * familiar CSS-like shorthand. For example: `margin="small auto large"`.
     */
    margin?: any;
    /**
     * Valid values are `0`, `none`, `xxx-small`, `xx-small`, `x-small`,
     * `small`, `medium`, `large`, `x-large`, `xx-large`. Apply these values via
     * familiar CSS-like shorthand. For example: `padding="small x-large large"`.
     */
    padding?: any;
    height?: ViewHeight;
    width?: ViewWidth;
    maxHeight?: ViewMaxHeight;
    maxWidth?: ViewMaxWidth;
    minHeight?: ViewMinHeight;
    minWidth?: ViewMinWidth;
    /**
     * The children to render inside the `<View />`
     */
    children?: React.ReactNode;
    /**
     * Designates the text alignment within the `<View />`
     */
    textAlign?: ViewTextAlign;
    /**
     * Accepts the familiar CSS shorthand to designate border widths corresponding
     * to edges
     */
    borderWidth?: any;
    /**
     * Accepts `small`, `medium`, `large`, `circle`, and `pill`. Border radius can be
     * assigned to individual corners in CSS shorthand style (e.g., `"medium large none pill"`).
     */
    borderRadius?: any;
    /**
     * Sets the color of the View border
     */
    borderColor?: any;
    /**
     * Designates the background style of the `<View />`
     */
    background?: any;
    /**
     * Controls the shadow depth for the `<View />`
     */
    shadow?: any;
    /**
     * Controls the z-index depth for the `<View />`
     */
    stacking?: any;
    /**
     * Specify a mouse cursor to use when hovering over the `<View />`
     */
    cursor?: any;
    /**
     * Specify a value for the CSS position property. Use `relative` if `focusable` will be true.
     */
    position?: ViewPosition;
    /**
     * The `left` CSS property in left-to-right interfaces. Will not do anything if `position === "static"`.
     */
    insetInlineStart?: string;
    /**
     * The `right` CSS property in left-to-right interfaces. Will not do anything if `position === "static"`.
     */
    insetInlineEnd?: string;
    /**
     * The `top` CSS property. Will not do anything if `position === "static"`.
     */
    insetBlockStart?: string;
    /**
     * The `bottom` CSS property. Will not do anything if `position === "static"`.
     */
    insetBlockEnd?: string;
    /**
     * Manually control if the `View` should display a focus outline. When left undefined (which is the default)
     * the focus outline will display automatically if the `View` is focusable and receives focus. Note: the focus
     * outline only will display when the `position` prop is set to `relative`.
     */
    withFocusOutline?: boolean;
    /**
     * Determines whether the focus outline displays offset or inset from the focused View
     */
    focusPosition?: ViewFocusPosition;
    /**
     * Determines the color of the focus outline
     */
    focusColor?: ViewFocusColor;
    /**
     * Determines if the focus ring should animate when it appears
     */
    shouldAnimateFocus?: boolean;
    /**
     * Activate a dotted outline around the component to make building your
     * layout easier
     */
    withVisualDebug?: boolean;
    /**
     * eslint-disable react/require-default-props
     */
    focused?: boolean;
    /**
     * __Deprecated - use 'withVisualDebug'__
     */
    visualDebug?: boolean;
}

export class View extends React.Component<ViewProps, any> {
    render(): JSX.Element;

}


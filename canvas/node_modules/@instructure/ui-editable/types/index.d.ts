import * as React from 'react';

export type EditableMode = "view" | "edit";

export interface EditableProps {
    /**
     * If `'view'`: the view component is rendered,
     * if `'edit'`: the edit component is rendered
     */
    mode: EditableMode;
    /**
     * Called when the component's mode changes
     * @param {string} new_mode
     */
    onChangeMode: (...args: any[])=>any;
    /**
     * @param {Object} renderProps
     * @param {Boolean} mode
     * @param {Function} renderProps.getContainerProps - Props to be spread onto the container element
     * @param {Function} renderProps.getEditorProps - Props to be spread onto the editor element
     * @param {Function} renderProps.getEditButtonProps - Props to be spread onto the edit button element
     */
    children?: (...args: any[])=>any;
    /**
     * Identical to children
     */
    render?: (...args: any[])=>any;
    /**
     * The current value.
     * The value is managed by the consuming app, but we need to tell Editable
     * it's changed or it won't re-render
     */
    value?: any;
    /**
     * Called when Editable switches from edit to view mode and the value has changed.
     * @param {any} value
     */
    onChange?: (...args: any[])=>any;
    /**
     * The mode is fixed as 'view'
     */
    readOnly?: boolean;
}

export class Editable extends React.Component<EditableProps, any> {
    render(): JSX.Element;

}




export type InPlaceEditMode = "view" | "edit";

export type InPlaceEditEditButtonPlacement = "start" | "end";

export interface InPlaceEditProps {
    /**
     * Function to render the view mode component.
     * It is the consumer's responsibility to provide the
     * current value or children.
     * @returns {element} the viewer DOM sub-tree.
     */
    renderViewer: (...args: any[])=>any;
    /**
     * Function to render the edit mode component
     * It is the consumer's responsibility to provide the
     * current value, and to attach the appropriate onChange
     * event handler needed to capture the updated value. This
     * new value must then be forwarded to the view mode component.
     * @returns {element} the editor DOM sub-tree.
     */
    renderEditor: (...args: any[])=>any;
    /**
     * Function to render the edit button.
     * @param {Object} { isVisible, onClick, onFocus, onBlur, buttonRef }
     * @returns {element} the edit button DOM sub-tree
     * If you choose to use the default edit button, add `label` to the
     * incoming `props` parameter and call `InPlaceEdit.renderDefaultEditButton(props)`
     * If you choose to render a custom button, attach the on* event handlers
     * and set `buttonRef` as a `ref` type property on the `button` element.
     * `isVisible` is a hint as to whether the button is _typically_ shown,
     * but you're free to ignore it for your use-case.
     */
    renderEditButton: (...args: any[])=>any;
    /**
     * If `'view'`: the view component is rendered,
     * if `'edit'`: the edit component is rendered
     */
    mode: InPlaceEditMode;
    /**
     * Called when the component's mode changes
     * @param {string} newMode
     */
    onChangeMode: (...args: any[])=>any;
    /**
     * The current value.
     * The value is managed by the consuming app, but we need to tell InPlaceEdit
     * it's changed or it won't re-render
     */
    value?: any;
    /**
     * Called when Editable switches from edit to view mode and the value has changed.
     * @param {any} value
     */
    onChange?: (...args: any[])=>any;
    /**
     * The mode is fixed as 'view'
     */
    readOnly?: boolean;
    /**
     * Show a focus outline when the input is focused
     */
    showFocusRing?: boolean;
    /**
     * Put the edit button before or after the view
     */
    editButtonPlacement?: InPlaceEditEditButtonPlacement;
    /**
     * Render outermost element inline v. block
     */
    inline?: boolean;
}

export class InPlaceEdit extends React.Component<InPlaceEditProps, any> {
    render(): JSX.Element;

}


"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Editable = exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _createSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/createSuper"));

var _console = require("@instructure/console");

var _react = require("react");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _deepEqual = require("@instructure/ui-utils/lib/deepEqual.js");

var _requestAnimationFrame = require("@instructure/ui-dom-utils/lib/requestAnimationFrame.js");

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2018 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
---
category: components
experimental: true
---
**/
var Editable = /*#__PURE__*/function (_Component) {
  (0, _inherits2.default)(Editable, _Component);

  var _super = (0, _createSuper2.default)(Editable);

  function Editable(_props) {
    var _this;

    (0, _classCallCheck2.default)(this, Editable);
    _this = _super.call(this, _props);
    _this.state = {
      showModeToggle: false,
      valueOnEdit: null // the value when mode flips from view -> edit

    };
    _this._editorRef = null;
    _this._editButtonRef = null;

    _this.handleEditESC = function (event) {
      if (event.key === 'Escape') {
        _this.enterView();
      }
    };

    _this.handleViewMouseOver = function (event) {
      if (_this.props.mode === 'view') {
        // because the mouse event handlers are on the container, not the view
        event.stopPropagation();

        _this.setState({
          showModeToggle: true
        });
      }
    };

    _this.handleViewMouseOut = function (event) {
      if (_this.props.mode === 'view') {
        event.stopPropagation();

        _this.setState({
          showModeToggle: document.activeElement === _this._editButtonRef
        });
      }
    };

    _this.handleViewClick = function (event) {
      if (event.buttons === 1) {
        (0, _requestAnimationFrame.requestAnimationFrame)(function () {
          _this.enterEdit();
        });
      }
    };

    _this.handleEditBlur = function (event) {
      _this.enterView();
    };

    _this.handleEditButtonFocus = function (event) {
      _this.setState({
        showModeToggle: true
      });
    };

    _this.handleEditButtonBlur = function (event) {
      _this.setState({
        showModeToggle: false
      });
    };

    _this.handleEditButtonClick = function (event) {
      _this.enterEdit();
    };

    _this.getContainerProps = function () {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var _this$props = _this.props,
          mode = _this$props.mode,
          readOnly = _this$props.readOnly;
      return (0, _objectSpread2.default)({
        onMouseOver: _this.handleViewMouseOver,
        onMouseOut: _this.handleViewMouseOut,
        onMouseDown: mode !== 'edit' ? _this.handleViewClick : null,
        onKeyUp: mode === 'edit' ? _this.handleEditESC : null,
        readOnly: readOnly
      }, props);
    };

    _this.getViewerProps = function () {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return (0, _objectSpread2.default)({
        mode: _this.props.mode,
        readOnly: _this.props.readOnly
      }, props);
    };

    _this.getEditorProps = function (props) {
      return (0, _objectSpread2.default)({
        mode: _this.props.mode,
        onBlur: _this.handleEditBlur,
        editorRef: function editorRef(el) {
          _this._editorRef = el;
        },
        readOnly: _this.props.readOnly
      }, props);
    };

    _this.getEditButtonProps = function () {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return (0, _objectSpread2.default)({
        onClick: _this.handleEditButtonClick,
        onFocus: _this.handleEditButtonFocus,
        onBlur: _this.handleEditButtonBlur,
        isVisible: _this.state.showModeToggle,
        buttonRef: function buttonRef(el) {
          _this._editButtonRef = el;
        },
        readOnly: _this.props.readOnly
      }, props);
    };

    /*#__PURE__*/
    ( /*#__PURE__*/0, _console.warn)(_props.readOnly ? _props.mode === 'view' : true, '[Editable] When readOnly is true, mode must be "view"');
    return _this;
  }

  (0, _createClass2.default)(Editable, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.mode === 'edit') {
        this.focusEditor();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {}
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props2 = this.props,
          mode = _this$props2.mode,
          value = _this$props2.value,
          onChange = _this$props2.onChange; // on the switch from view -> edit

      if (prevProps.mode !== 'edit' && mode === 'edit') {
        this.setState({
          valueOnEdit: value
        });
        this.focusEditor();
      } // on the switch from edit to view


      if (prevProps.mode === 'edit' && mode !== 'edit') {
        this._editButtonRef && this._editButtonRef.focus();

        if (onChange && !(0, _deepEqual.deepEqual)(this.state.valueOnEdit, value)) {
          onChange(value);
        }
      }
    }
  }, {
    key: "focusEditor",
    value: function focusEditor() {
      /*#__PURE__*/
      ( /*#__PURE__*/0, _console.warn)(!!this._editorRef && !this.props.readOnly, '[Editable] Did you forget to connect editorRef to your editor component?');

      if (this._editorRef) {
        this._editorRef.focus();
      }
    }
  }, {
    key: "enterView",
    value: function enterView() {
      if (this.props.mode !== 'view') {
        this.setState({
          showModeToggle: true
        });
        this.props.onChangeMode('view');
      }
    }
  }, {
    key: "enterEdit",
    value: function enterEdit() {
      if (!this.props.readOnly) {
        this.setState({
          showModeToggle: false
        });

        if (this.props.mode !== 'edit') {
          this.props.onChangeMode('edit');
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          children = _this$props3.children,
          _this$props3$render = _this$props3.render,
          render = _this$props3$render === void 0 ? children : _this$props3$render,
          mode = _this$props3.mode;

      if (typeof render === 'function') {
        return render({
          mode: mode,
          getContainerProps: this.getContainerProps,
          getViewerProps: this.getViewerProps,
          getEditorProps: this.getEditorProps,
          getEditButtonProps: this.getEditButtonProps
        });
      } else {
        return null;
      }
    }
  }]);
  Editable.displayName = "Editable";
  return Editable;
}(_react.Component);

exports.Editable = Editable;
Editable.propTypes = {
  /**
   * If `'view'`: the view component is rendered,
   * if `'edit'`: the edit component is rendered
   */
  mode: _propTypes.default.oneOf(['view', 'edit']).isRequired,

  /**
   * Called when the component's mode changes
   * @param {string} new_mode
   */
  onChangeMode: _propTypes.default.func.isRequired,

  /**
   * @param {Object} renderProps
   * @param {Boolean} mode
   * @param {Function} renderProps.getContainerProps - Props to be spread onto the container element
   * @param {Function} renderProps.getEditorProps - Props to be spread onto the editor element
   * @param {Function} renderProps.getEditButtonProps - Props to be spread onto the edit button element
   */
  children: _propTypes.default.func,

  /**
   * Identical to children
   */
  render: _propTypes.default.func,

  /**
   * The current value.
   * The value is managed by the consuming app, but we need to tell Editable
   * it's changed or it won't re-render
   */
  value: _propTypes.default.any,

  /**
   * Called when Editable switches from edit to view mode and the value has changed.
   * @param {any} value
   */
  onChange: _propTypes.default.func,

  /**
   * The mode is fixed as 'view'
   */
  readOnly: _propTypes.default.bool
};
Editable.defaultProps = {
  readOnly: false,
  onChange: void 0,
  value: void 0,
  render: void 0,
  children: null
};
var _default = Editable;
exports.default = _default;
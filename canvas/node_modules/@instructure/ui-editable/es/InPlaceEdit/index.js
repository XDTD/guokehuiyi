import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";
import { warn as _warn } from "@instructure/console";

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2018 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Flex } from '@instructure/ui-flex';
import { FocusableView } from '@instructure/ui-focusable';
import { IconButton } from '@instructure/ui-buttons';
import { IconEditLine } from '@instructure/ui-icons';
import { createChainedFunction } from '@instructure/ui-utils';
import { Editable } from "../Editable/index.js";
/**
---
category: components
---
**/

var InPlaceEdit = /*#__PURE__*/function (_Component) {
  _inherits(InPlaceEdit, _Component);

  var _super = _createSuper(InPlaceEdit);

  function InPlaceEdit(props) {
    var _this;

    _classCallCheck(this, InPlaceEdit);

    _this = _super.call(this, props);

    _this.handleEditButtonRef = function (el) {
      _this._editButtonRef = el;
    };

    _this.renderAll = function (_ref) {
      var getContainerProps = _ref.getContainerProps,
          getViewerProps = _ref.getViewerProps,
          getEditorProps = _ref.getEditorProps,
          getEditButtonProps = _ref.getEditButtonProps;
      var flexDir = _this.props.editButtonPlacement === 'start' ? 'row-reverse' : 'row';
      var justifyItems = flexDir === 'row-reverse' ? 'end' : 'start';
      var buttonMargin = _this.props.editButtonPlacement === 'start' ? '0 xx-small 0 0' : '0 0 0 xx-small';
      return /*#__PURE__*/React.createElement(Flex, Object.assign({
        display: _this.props.inline ? 'inline-flex' : 'flex',
        direction: flexDir,
        justifyItems: justifyItems
      }, getContainerProps()), /*#__PURE__*/React.createElement(Flex.Item, {
        shouldGrow: true,
        shouldShrink: true
      }, _this.renderEditor(getEditorProps()), _this.renderViewer(getViewerProps())), /*#__PURE__*/React.createElement(Flex.Item, {
        margin: buttonMargin
      }, _this.renderEditButton(getEditButtonProps())));
    };

    /*#__PURE__*/

    /*#__PURE__*/
    _warn(props.readOnly ? props.mode === 'view' : true, '[InPlaceEdit] When readOnly is true, mode is forced to "view"');

    return _this;
  }

  _createClass(InPlaceEdit, [{
    key: "renderEditor",
    value: function renderEditor(_ref2) {
      var mode = _ref2.mode,
          onBlur = _ref2.onBlur,
          editorRef = _ref2.editorRef,
          readOnly = _ref2.readOnly;
      var _this$props = this.props,
          showFocusRing = _this$props.showFocusRing,
          renderEditor = _this$props.renderEditor;
      var isEditMode = !readOnly && mode === 'edit';
      return isEditMode ? /*#__PURE__*/React.createElement(FocusableView, {
        as: "span",
        display: "block",
        focused: showFocusRing
      }, renderEditor({
        onBlur: onBlur,
        editorRef: editorRef
      })) : null;
    }
  }, {
    key: "renderViewer",
    value: function renderViewer(_ref3) {
      var readOnly = _ref3.readOnly,
          mode = _ref3.mode;
      return readOnly || mode === 'view' ? this.props.renderViewer() : null;
    }
  }, {
    key: "renderEditButton",
    value: function renderEditButton(_ref4) {
      var buttonRef = _ref4.buttonRef,
          rest = _objectWithoutProperties(_ref4, ["buttonRef"]);

      return this.props.renderEditButton(_objectSpread({
        elementRef: createChainedFunction(this.handleEditButtonRef, buttonRef)
      }, rest));
    } // Render a default edit button, an icon button with the edit icon
    // the margin makes room for the focus ring

  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          mode = _this$props2.mode,
          value = _this$props2.value,
          onChange = _this$props2.onChange,
          onChangeMode = _this$props2.onChangeMode,
          readOnly = _this$props2.readOnly;
      return /*#__PURE__*/React.createElement(Editable, {
        mode: mode,
        onChangeMode: onChangeMode,
        render: this.renderAll,
        value: value,
        onChange: onChange,
        readOnly: readOnly
      });
    }
  }]);

  InPlaceEdit.displayName = "InPlaceEdit";
  return InPlaceEdit;
}(Component);

InPlaceEdit.propTypes = {
  /**
   * Function to render the view mode component.
   * It is the consumer's responsibility to provide the
   * current value or children.
   *
   * @returns {element} the viewer DOM sub-tree.
   */
  renderViewer: PropTypes.func.isRequired,

  /**
   * Function to render the edit mode component
   * It is the consumer's responsibility to provide the
   * current value, and to attach the appropriate onChange
   * event handler needed to capture the updated value. This
   * new value must then be forwarded to the view mode component.
   *
   * @returns {element} the editor DOM sub-tree.
   */
  renderEditor: PropTypes.func.isRequired,

  /**
   * Function to render the edit button.
   *
   * @param {Object} { isVisible, onClick, onFocus, onBlur, buttonRef }
   * @returns {element} the edit button DOM sub-tree
   *
   * If you choose to use the default edit button, add `label` to the
   * incoming `props` parameter and call `InPlaceEdit.renderDefaultEditButton(props)`
   *
   * If you choose to render a custom button, attach the on* event handlers
   * and set `buttonRef` as a `ref` type property on the `button` element.
   *
   * `isVisible` is a hint as to whether the button is _typically_ shown,
   * but you're free to ignore it for your use-case.
   */
  renderEditButton: PropTypes.func.isRequired,

  /**
   * If `'view'`: the view component is rendered,
   * if `'edit'`: the edit component is rendered
   */
  mode: PropTypes.oneOf(['view', 'edit']).isRequired,

  /**
   * Called when the component's mode changes
   * @param {string} newMode
   */
  onChangeMode: PropTypes.func.isRequired,

  /**
   * The current value.
   * The value is managed by the consuming app, but we need to tell InPlaceEdit
   * it's changed or it won't re-render
   */
  value: PropTypes.any,

  /**
   * Called when Editable switches from edit to view mode and the value has changed.
   * @param {any} value
   */
  onChange: PropTypes.func,

  /**
   * The mode is fixed as 'view'
   */
  readOnly: PropTypes.bool,

  /**
   * Show a focus outline when the input is focused
   */
  showFocusRing: PropTypes.bool,

  /**
   * Put the edit button before or after the view
   */
  editButtonPlacement: PropTypes.oneOf(['start', 'end']),

  /**
   * Render outermost element inline v. block
   */
  inline: PropTypes.bool
};
InPlaceEdit.defaultProps = {
  readOnly: false,
  showFocusRing: true,
  inline: true,
  value: void 0,
  editButtonPlacement: 'end',
  onChange: void 0
};

InPlaceEdit.renderDefaultEditButton = function (_ref5) {
  var isVisible = _ref5.isVisible,
      readOnly = _ref5.readOnly,
      label = _ref5.label,
      buttonProps = _objectWithoutProperties(_ref5, ["isVisible", "readOnly", "label"]);

  if (readOnly) {
    return null;
  }

  return /*#__PURE__*/React.createElement(IconButton, Object.assign({
    size: "small",
    screenReaderLabel: label,
    withBackground: false,
    withBorder: false
  }, buttonProps), isVisible ? IconEditLine : null);
};

export default InPlaceEdit;
export { InPlaceEdit };
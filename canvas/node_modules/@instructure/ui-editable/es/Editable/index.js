import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";
import { warn as _warn } from "@instructure/console";

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2018 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import { Component } from 'react';
import PropTypes from 'prop-types';
import { deepEqual } from '@instructure/ui-utils';
import { requestAnimationFrame } from '@instructure/ui-dom-utils';
/**
---
category: components
experimental: true
---
**/

var Editable = /*#__PURE__*/function (_Component) {
  _inherits(Editable, _Component);

  var _super = _createSuper(Editable);

  function Editable(_props) {
    var _this;

    _classCallCheck(this, Editable);

    _this = _super.call(this, _props);
    _this.state = {
      showModeToggle: false,
      valueOnEdit: null // the value when mode flips from view -> edit

    };
    _this._editorRef = null;
    _this._editButtonRef = null;

    _this.handleEditESC = function (event) {
      if (event.key === 'Escape') {
        _this.enterView();
      }
    };

    _this.handleViewMouseOver = function (event) {
      if (_this.props.mode === 'view') {
        // because the mouse event handlers are on the container, not the view
        event.stopPropagation();

        _this.setState({
          showModeToggle: true
        });
      }
    };

    _this.handleViewMouseOut = function (event) {
      if (_this.props.mode === 'view') {
        event.stopPropagation();

        _this.setState({
          showModeToggle: document.activeElement === _this._editButtonRef
        });
      }
    };

    _this.handleViewClick = function (event) {
      if (event.buttons === 1) {
        requestAnimationFrame(function () {
          _this.enterEdit();
        });
      }
    };

    _this.handleEditBlur = function (event) {
      _this.enterView();
    };

    _this.handleEditButtonFocus = function (event) {
      _this.setState({
        showModeToggle: true
      });
    };

    _this.handleEditButtonBlur = function (event) {
      _this.setState({
        showModeToggle: false
      });
    };

    _this.handleEditButtonClick = function (event) {
      _this.enterEdit();
    };

    _this.getContainerProps = function () {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var _this$props = _this.props,
          mode = _this$props.mode,
          readOnly = _this$props.readOnly;
      return _objectSpread({
        onMouseOver: _this.handleViewMouseOver,
        onMouseOut: _this.handleViewMouseOut,
        onMouseDown: mode !== 'edit' ? _this.handleViewClick : null,
        onKeyUp: mode === 'edit' ? _this.handleEditESC : null,
        readOnly: readOnly
      }, props);
    };

    _this.getViewerProps = function () {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return _objectSpread({
        mode: _this.props.mode,
        readOnly: _this.props.readOnly
      }, props);
    };

    _this.getEditorProps = function (props) {
      return _objectSpread({
        mode: _this.props.mode,
        onBlur: _this.handleEditBlur,
        editorRef: function editorRef(el) {
          _this._editorRef = el;
        },
        readOnly: _this.props.readOnly
      }, props);
    };

    _this.getEditButtonProps = function () {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return _objectSpread({
        onClick: _this.handleEditButtonClick,
        onFocus: _this.handleEditButtonFocus,
        onBlur: _this.handleEditButtonBlur,
        isVisible: _this.state.showModeToggle,
        buttonRef: function buttonRef(el) {
          _this._editButtonRef = el;
        },
        readOnly: _this.props.readOnly
      }, props);
    };

    /*#__PURE__*/

    /*#__PURE__*/
    _warn(_props.readOnly ? _props.mode === 'view' : true, '[Editable] When readOnly is true, mode must be "view"');

    return _this;
  }

  _createClass(Editable, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.mode === 'edit') {
        this.focusEditor();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {}
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props2 = this.props,
          mode = _this$props2.mode,
          value = _this$props2.value,
          onChange = _this$props2.onChange; // on the switch from view -> edit

      if (prevProps.mode !== 'edit' && mode === 'edit') {
        this.setState({
          valueOnEdit: value
        });
        this.focusEditor();
      } // on the switch from edit to view


      if (prevProps.mode === 'edit' && mode !== 'edit') {
        this._editButtonRef && this._editButtonRef.focus();

        if (onChange && !deepEqual(this.state.valueOnEdit, value)) {
          onChange(value);
        }
      }
    }
  }, {
    key: "focusEditor",
    value: function focusEditor() {
      /*#__PURE__*/

      /*#__PURE__*/
      _warn(!!this._editorRef && !this.props.readOnly, '[Editable] Did you forget to connect editorRef to your editor component?');

      if (this._editorRef) {
        this._editorRef.focus();
      }
    }
  }, {
    key: "enterView",
    value: function enterView() {
      if (this.props.mode !== 'view') {
        this.setState({
          showModeToggle: true
        });
        this.props.onChangeMode('view');
      }
    }
  }, {
    key: "enterEdit",
    value: function enterEdit() {
      if (!this.props.readOnly) {
        this.setState({
          showModeToggle: false
        });

        if (this.props.mode !== 'edit') {
          this.props.onChangeMode('edit');
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          children = _this$props3.children,
          _this$props3$render = _this$props3.render,
          render = _this$props3$render === void 0 ? children : _this$props3$render,
          mode = _this$props3.mode;

      if (typeof render === 'function') {
        return render({
          mode: mode,
          getContainerProps: this.getContainerProps,
          getViewerProps: this.getViewerProps,
          getEditorProps: this.getEditorProps,
          getEditButtonProps: this.getEditButtonProps
        });
      } else {
        return null;
      }
    }
  }]);

  Editable.displayName = "Editable";
  return Editable;
}(Component);

Editable.propTypes = {
  /**
   * If `'view'`: the view component is rendered,
   * if `'edit'`: the edit component is rendered
   */
  mode: PropTypes.oneOf(['view', 'edit']).isRequired,

  /**
   * Called when the component's mode changes
   * @param {string} new_mode
   */
  onChangeMode: PropTypes.func.isRequired,

  /**
   * @param {Object} renderProps
   * @param {Boolean} mode
   * @param {Function} renderProps.getContainerProps - Props to be spread onto the container element
   * @param {Function} renderProps.getEditorProps - Props to be spread onto the editor element
   * @param {Function} renderProps.getEditButtonProps - Props to be spread onto the edit button element
   */
  children: PropTypes.func,

  /**
   * Identical to children
   */
  render: PropTypes.func,

  /**
   * The current value.
   * The value is managed by the consuming app, but we need to tell Editable
   * it's changed or it won't re-render
   */
  value: PropTypes.any,

  /**
   * Called when Editable switches from edit to view mode and the value has changed.
   * @param {any} value
   */
  onChange: PropTypes.func,

  /**
   * The mode is fixed as 'view'
   */
  readOnly: PropTypes.bool
};
Editable.defaultProps = {
  readOnly: false,
  onChange: void 0,
  value: void 0,
  render: void 0,
  children: null
};
export default Editable;
export { Editable };
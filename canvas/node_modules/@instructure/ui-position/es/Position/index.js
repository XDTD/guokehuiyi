import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";

var _dec, _dec2, _class, _class2, _temp, _dec3, _dec4, _class3, _class4, _temp2, _dec5, _dec6, _dec7, _class5, _class6, _temp3;

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import classnames from 'classnames';
import { themeable } from '@instructure/ui-themeable';
import { element } from '@instructure/ui-prop-types';
import { ComponentIdentifier, safeCloneElement, callRenderProp, ensureSingleChild, deprecated } from '@instructure/ui-react-utils';
import { addPositionChangeListener, findDOMNode } from '@instructure/ui-dom-utils';
import { uid } from '@instructure/uid';
import { shallowEqual, deepEqual } from '@instructure/ui-utils';
import { debounce } from '@instructure/debounce';
import { testable } from '@instructure/ui-testable';
import { Portal } from '@instructure/ui-portal';
import { calculateElementPosition } from "../calculateElementPosition.js";
import { PositionPropTypes } from "../PositionPropTypes.js";
var styles = {
  componentId: 'eGKPI',
  template: function template(theme) {
    return "\n\n.eGKPI_bGBk{box-sizing:border-box;z-index:".concat(theme.zIndex || 'inherit', "}");
  },
  'root': 'eGKPI_bGBk'
};
import theme from "./theme.js";
var PositionTarget = (_dec = deprecated('8.0.0', null, "Use Position's `renderTarget` prop instead."), _dec2 = testable(), _dec(_class = _dec2(_class = (_temp = _class2 = /*#__PURE__*/function (_ComponentIdentifier) {
  _inherits(PositionTarget, _ComponentIdentifier);

  var _super = _createSuper(PositionTarget);

  function PositionTarget() {
    _classCallCheck(this, PositionTarget);

    return _super.apply(this, arguments);
  }

  return PositionTarget;
}(ComponentIdentifier), _class2.displayName = 'PositionTarget', _class2.locatorAttribute = 'data-position-target', _temp)) || _class) || _class);
var PositionContent = (_dec3 = deprecated('8.0.0', null, "Use Posiition's `children` instead."), _dec4 = testable(), _dec3(_class3 = _dec4(_class3 = (_temp2 = _class4 = /*#__PURE__*/function (_ComponentIdentifier2) {
  _inherits(PositionContent, _ComponentIdentifier2);

  var _super2 = _createSuper(PositionContent);

  function PositionContent() {
    _classCallCheck(this, PositionContent);

    return _super2.apply(this, arguments);
  }

  return PositionContent;
}(ComponentIdentifier), _class4.displayName = 'PositionContent', _class4.propTypes = {
  children: PropTypes.node,
  placement: PositionPropTypes.placement
}, _class4.locatorAttribute = 'data-position-content', _temp2)) || _class3) || _class3);
/**
---
category: components/utilities
---
**/

var Position = (_dec5 = deprecated('8.0.0', {
  trackPosition: 'shouldTrackPosition',
  over: 'shouldPositionOverTarget'
}), _dec6 = testable(), _dec7 = themeable(theme, styles), _dec5(_class5 = _dec6(_class5 = _dec7(_class5 = (_temp3 = _class6 = /*#__PURE__*/function (_Component) {
  _inherits(Position, _Component);

  var _super3 = _createSuper(Position);

  function Position(props) {
    var _this;

    _classCallCheck(this, Position);

    _this = _super3.call(this, props);
    _this._timeouts = [];

    _this.handlePortalOpen = function () {
      _this.position();

      if (_this.props.shouldTrackPosition || _this.props.trackPosition) {
        _this.startTracking();
      }

      _this._timeouts.push(setTimeout(function () {
        if (_this.state.positioned && typeof _this.props.onPositioned === 'function') {
          _this.props.onPositioned({
            top: _this.state.style.top,
            left: _this.state.style.left,
            placement: _this.state.placement
          });
        }
      }, 0));
    };

    _this.position = function () {
      _this.setState(_objectSpread({
        positioned: true
      }, _this.calculatePosition(_this.props)));
    };

    _this.state = _objectSpread({
      positioned: false
    }, _this.calculatePosition(props));
    _this.position = debounce(_this.position, 0, {
      leading: false,
      trailing: true
    });
    _this._id = _this.props.id || uid('Position');
    return _this;
  }

  _createClass(Position, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState, nextContext) {
      return !deepEqual(this.state, nextState) || !shallowEqual(this.props, nextProps) || !shallowEqual(this.context, nextContext);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.toggleLocatorAttributes(true);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      this.position();
      this.toggleLocatorAttributes(true);

      if (this.props.shouldTrackPosition !== prevProps.shouldTrackPosition) {
        this.props.shouldTrackPosition ? this.startTracking() : this.stopTracking();
      } else if (this.props.trackPosition !== prevProps.trackPosition) {
        this.props.trackPosition ? this.startTracking() : this.stopTracking();
      }

      var _this$state = this.state,
          style = _this$state.style,
          placement = _this$state.placement;

      if (style && prevState.style && (placement !== prevState.placement || style.top !== prevState.style.top || style.left !== prevState.style.left)) {
        this.props.onPositionChanged({
          top: style.top,
          left: style.left,
          placement: placement
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.position.cancel();
      this.stopTracking();

      this._timeouts.forEach(function (timeout) {
        return clearTimeout(timeout);
      });

      this.toggleLocatorAttributes(false);
    }
  }, {
    key: "toggleLocatorAttributes",
    value: function toggleLocatorAttributes(set) {
      // We have to find the actual DOM nodes and append the attributes
      // directly, as we can't be sure when safe cloning the child that
      // it will accept the data attribute as a prop
      this.toggleLocatorAttribute(findDOMNode(this._content), Position.contentLocatorAttribute, set);
      this.toggleLocatorAttribute(findDOMNode(this._target), Position.targetLocatorAttribute, set);
    }
  }, {
    key: "toggleLocatorAttribute",
    value: function toggleLocatorAttribute(node, locator, set) {
      if (node && node.hasAttribute) {
        if (set && !node.hasAttribute(locator)) {
          node.setAttribute(locator, this._id);
        }

        if (!set && node.hasAttribute(locator)) {
          node.removeAttribute(locator);
        }
      }
    }
  }, {
    key: "calculatePosition",
    value: function calculatePosition(props) {
      return calculateElementPosition(this._content, this._target, {
        placement: props.placement,
        offsetX: props.offsetX,
        offsetY: props.offsetY,
        constrain: props.constrain,
        container: props.mountNode,
        over: props.shouldPositionOverTarget || props.over
      });
    }
  }, {
    key: "startTracking",
    value: function startTracking() {
      this._listener = this._listener || addPositionChangeListener(this._target, this.position);
    }
  }, {
    key: "stopTracking",
    value: function stopTracking() {
      if (this._listener) {
        this._listener.remove();

        this._listener = null;
      }
    }
  }, {
    key: "renderContent",
    value: function renderContent() {
      var _this2 = this;

      var content = ComponentIdentifier.pick(Position.Content, this.props.children);

      if (!content) {
        content = ensureSingleChild(this.props.children);
      }

      if (content) {
        var _classnames;

        content = safeCloneElement(content, _defineProperty({
          ref: function ref(el) {
            _this2._content = el;
          },
          style: _objectSpread({}, content.props.style, {}, this.state.style),
          className: classnames((_classnames = {}, _defineProperty(_classnames, styles.root, true), _defineProperty(_classnames, content.props.className, content.props.className), _classnames))
        }, Position.contentLocatorAttribute, this._id));
        content = /*#__PURE__*/React.createElement(Portal, {
          open: true,
          onOpen: this.handlePortalOpen,
          mountNode: this.props.mountNode,
          insertAt: this.props.insertAt
        }, content);
      }

      return content;
    }
  }, {
    key: "renderTarget",
    value: function renderTarget() {
      var _this3 = this;

      var target = ComponentIdentifier.pick(Position.Target, this.props.children);

      if (!target) {
        target = callRenderProp(this.props.renderTarget);
      }

      if (target) {
        return safeCloneElement(target, _defineProperty({
          ref: function ref(el) {
            _this3._target = el;
          }
        }, Position.targetLocatorAttribute, this._id));
      } else if (this.props.target) {
        this._target = callRenderProp(this.props.target);
      } else {
        return null;
      }
    }
  }, {
    key: "render",
    value: function render() {
      var props = _defineProperty({}, Position.locatorAttribute, this._id);

      return /*#__PURE__*/React.createElement("span", props, this.renderTarget(), this.renderContent());
    }
  }]);

  Position.displayName = "Position";
  return Position;
}(Component), _class6.Target = PositionTarget, _class6.Content = PositionContent, _class6.locatorAttribute = 'data-position', _class6.targetLocatorAttribute = 'data-position-target', _class6.contentLocatorAttribute = 'data-position-content', _class6.propTypes = {
  /**
   * The node to use as the position target
   */
  renderTarget: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

  /**
   * The target to be used when not using `renderTarget`
   */
  target: PropTypes.oneOfType([element, PropTypes.func]),

  /**
   * The placement of the content in relation to the target
   */
  placement: PositionPropTypes.placement,

  /**
   * An element or a function returning an element to use as the mount node
   * for the `<Position />` (defaults to `document.body`)
   */
  mountNode: PositionPropTypes.mountNode,

  /**
   * Insert the element at the 'top' of the mountNode or at the 'bottom'
   */
  insertAt: PropTypes.oneOf(['bottom', 'top']),

  /**
   * The parent in which to constrain the placement.
   * One of: 'window', 'scroll-parent', 'parent', 'none', an element,
   * or a function returning an element
   */
  constrain: PositionPropTypes.constrain,

  /**
   * The horizontal offset for the positioned content
   */
  offsetX: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
   * The vertical offset for the positioned content
   */
  offsetY: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
   * An id will be generated if not provided
   */
  id: PropTypes.string,

  /**
   * Whether or not position of the target should be tracked or just set statically on render
   */
  shouldTrackPosition: PropTypes.bool,

  /**
   * Whether or not you want the content to position over the target
   */
  shouldPositionOverTarget: PropTypes.bool,

  /**
   * Callback fired when the position changes
   */
  onPositionChanged: PropTypes.func,

  /**
   * Callback fired when `<Position />` content has been mounted and is initially positioned
   */
  onPositioned: PropTypes.func,

  /**
   * The content to be positioned
   */
  children: PropTypes.node,

  /* eslint-disable react/require-default-props */

  /**
   * __Deprecated - use `shouldTrackPosition`__
   */
  trackPosition: PropTypes.bool,

  /**
   * __Deprecated - use `shouldPositionOverTarget`__
   */
  over: PropTypes.bool
  /* eslint-enable react/require-default-props */

}, _class6.defaultProps = {
  renderTarget: void 0,
  target: void 0,
  placement: 'bottom center',
  mountNode: null,
  insertAt: 'bottom',
  constrain: 'window',
  offsetX: 0,
  offsetY: 0,
  id: void 0,
  shouldTrackPosition: true,
  shouldPositionOverTarget: false,
  onPositioned: function onPositioned(position) {},
  onPositionChanged: function onPositionChanged(position) {},
  children: null
}, _temp3)) || _class5) || _class5) || _class5);
export default Position;
export { Position };
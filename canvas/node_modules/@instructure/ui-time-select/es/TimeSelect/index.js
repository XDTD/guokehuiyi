import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";

var _dec, _dec2, _class, _class2, _temp;

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { I18nPropTypes, DateTime, Locale } from '@instructure/ui-i18n';
import { controllable } from '@instructure/ui-prop-types';
import { deprecated, getInteraction, passthroughProps, callRenderProp } from '@instructure/ui-react-utils';
import { FormPropTypes } from '@instructure/ui-form-field';
import { PositionPropTypes } from '@instructure/ui-position';
import { testable } from '@instructure/ui-testable';
import { Select } from '@instructure/ui-select';
import { uid } from '@instructure/uid';
/**
---
category: components
---
**/

var TimeSelect = (_dec = deprecated('8.0.0', {
  label: 'renderLabel'
}), _dec2 = testable(), _dec(_class = _dec2(_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
  _inherits(TimeSelect, _Component);

  var _super = _createSuper(TimeSelect);

  function TimeSelect(props) {
    var _this;

    _classCallCheck(this, TimeSelect);

    _this = _super.call(this, props);
    _this._emptyOptionId = uid('Select-EmptyOption');

    _this.handleRef = function (node) {
      _this._select = node;
    };

    _this.handleBlur = function (event) {
      _this.setState({
        highlightedOptionId: null
      });

      _this.props.onBlur(event);
    };

    _this.handleInputChange = function (event) {
      var value = event.target.value;

      var newOptions = _this.filterOptions(value);

      _this.setState(function (state) {
        return {
          inputValue: value,
          filteredOptions: newOptions,
          highlightedOptionId: newOptions.length > 0 ? newOptions[0].id : null,
          isShowingOptions: true
        };
      });

      if (!_this.state.isShowingOptions) {
        _this.props.onShowOptions(event);
      }
    };

    _this.handleShowOptions = function (event) {
      _this.setState({
        isShowingOptions: true
      });

      _this.props.onShowOptions(event);
    };

    _this.handleHideOptions = function (event) {
      var selectedOptionId = _this.state.selectedOptionId;

      var option = _this.getOption('id', selectedOptionId);

      var prevValue = '';

      if (_this.props.defaultValue) {
        var date = DateTime.parse(_this.props.defaultValue, _this.locale(), _this.timezone());
        prevValue = date.format(_this.props.format);
      }

      _this.setState(function (_ref) {
        var inputValue = _ref.inputValue;
        return _objectSpread({
          isShowingOptions: false,
          highlightedOptionId: null,
          inputValue: selectedOptionId ? option.label : prevValue,
          filteredOptions: _this.filterOptions('')
        }, _this.matchValue());
      });

      _this.props.onHideOptions(event);
    };

    _this.handleHighlightOption = function (event, _ref2) {
      var id = _ref2.id;
      if (id === _this._emptyOptionId) return;
      var type = event.type;

      var option = _this.getOption('id', id).label;

      _this.setState(function (state) {
        return {
          highlightedOptionId: id,
          inputValue: type === 'keydown' ? option : state.inputValue
        };
      });
    };

    _this.handleSelectOption = function (event, _ref3) {
      var id = _ref3.id;

      if (id === _this._emptyOptionId) {
        _this.setState({
          isShowingOptions: false
        });

        return;
      }

      var option = _this.getOption('id', id);

      if (_this.isControlled) {
        var prev = _this.getOption('id', _this.state.selectedOptionId);

        _this.setState({
          isShowingOptions: false,
          inputValue: prev ? prev.label : '',
          filteredOptions: _this.filterOptions('')
        });
      } else {
        _this.setState({
          isShowingOptions: false,
          selectedOptionId: id,
          inputValue: option.label,
          filteredOptions: _this.filterOptions('')
        });
      }

      if (id !== _this.state.selectedOptionId) {
        _this.props.onChange(event, {
          value: option.value
        });
      }

      _this.props.onHideOptions(event);
    };

    _this.state = _this.getInitialState();
    return _this;
  }

  _createClass(TimeSelect, [{
    key: "focus",
    value: function focus() {
      this._select && this._select.focus();
    }
  }, {
    key: "locale",
    value: function locale() {
      if (this.props.locale) {
        return this.props.locale;
      } else if (this.context && this.context.locale) {
        return this.context.locale;
      }

      return Locale.browserLocale();
    }
  }, {
    key: "timezone",
    value: function timezone() {
      if (this.props.timezone) {
        return this.props.timezone;
      } else if (this.context && this.context.timezone) {
        return this.context.timezone;
      }

      return DateTime.browserTimeZone();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props.step !== prevProps.step || this.props.format !== prevProps.format) {
        // options change, reset everything
        // when controlled, selection will be preserved
        // when uncontrolled, selection will be lost
        this.setState(this.getInitialState());
      }

      if (this.props.value !== prevProps.value) {
        // value changed
        var option = this.getOption('value', this.props.value);

        if (typeof this.props.value === 'undefined') {
          // preserve current value when changing from controlled to uncontrolled
          option = this.getOption('value', prevProps.value);
        }

        this.setState({
          inputValue: option ? option.label : '',
          selectedOptionId: option ? option.id : null
        });
      }
    }
  }, {
    key: "getInitialState",
    value: function getInitialState() {
      var initialOptions = this.generateOptions();
      var initialSelection = this.getInitialOption(initialOptions);
      return {
        inputValue: initialSelection ? initialSelection.label : '',
        options: initialOptions,
        filteredOptions: initialOptions,
        isShowingOptions: false,
        highlightedOptionId: initialSelection ? initialSelection.id : null,
        selectedOptionId: initialSelection ? initialSelection.id : null
      };
    }
  }, {
    key: "getInitialOption",
    value: function getInitialOption(options) {
      var _this$props = this.props,
          value = _this$props.value,
          defaultValue = _this$props.defaultValue,
          defaultToFirstOption = _this$props.defaultToFirstOption,
          format = _this$props.format;
      var initialValue = value || defaultValue;

      if (typeof initialValue === 'string') {
        // get option based on value or defaultValue, if provided
        var option = this.getOption('value', initialValue, options);

        if (option) {
          // value matches an existing option
          return option;
        } // value does not match an existing option


        var date = DateTime.parse(initialValue, this.locale(), this.timezone());
        return {
          label: date.format(format)
        };
      } // otherwise return first option, if desired


      if (defaultToFirstOption) {
        return options[0];
      }

      return null;
    }
  }, {
    key: "getOption",
    value: function getOption(field, value) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.state.options;
      return options.find(function (option) {
        return option[field] === value;
      });
    }
  }, {
    key: "getFormattedId",
    value: function getFormattedId(date) {
      // ISO8601 strings may contain a space. Remove any spaces before using the
      // date as the id.
      var dateStr = date.toISOString();
      return dateStr ? dateStr.replace(/\s/g, '') : null;
    }
  }, {
    key: "getBaseDate",
    value: function getBaseDate() {
      var baseDate;
      var baseValue = this.props.value || this.props.defaultValue;

      if (baseValue) {
        baseDate = DateTime.parse(baseValue, this.locale(), this.timezone());
      } else {
        baseDate = DateTime.now(this.locale(), this.timezone());
      }

      return baseDate.second(0).millisecond(0);
    }
  }, {
    key: "generateOptions",
    value: function generateOptions() {
      var date = this.getBaseDate();
      var options = [];

      for (var hour = 0; hour < 24; hour++) {
        for (var minute = 0; minute < 60 / this.props.step; minute++) {
          var minutes = minute * this.props.step;
          date.hour(hour).minute(minutes); // store time options

          options.push({
            id: this.getFormattedId(date),
            // iso no spaces
            value: date.toISOString(),
            // iso
            label: date.format(this.props.format) // formatted string

          });
        }
      }

      return options;
    }
  }, {
    key: "filterOptions",
    value: function filterOptions(inputValue) {
      return this.state.options.filter(function (option) {
        return option.label.toLowerCase().startsWith(inputValue.toLowerCase());
      });
    }
  }, {
    key: "matchValue",
    value: function matchValue() {
      var _this$state = this.state,
          inputValue = _this$state.inputValue,
          filteredOptions = _this$state.filteredOptions,
          highlightedOptionId = _this$state.highlightedOptionId,
          selectedOptionId = _this$state.selectedOptionId; // an option matching user input exists

      if (filteredOptions.length === 1) {
        var onlyOption = filteredOptions[0]; // automatically select the matching option

        if (onlyOption.label.toLowerCase() === inputValue.toLowerCase()) {
          return {
            inputValue: onlyOption.label,
            selectedOptionId: onlyOption.id,
            filteredOptions: this.filterOptions('')
          };
        }
      } // no match found, return selected option label to input


      var selectedOption = this.getOption('id', selectedOptionId);

      if (selectedOption) {
        return {
          inputValue: selectedOption.label
        };
      } // input value is from highlighted option, not user input


      if (highlightedOptionId) {
        if (inputValue === this.getOption('id', highlightedOptionId).label) {
          return {
            inputValue: '',
            filteredOptions: this.filterOptions('')
          };
        }
      } // if input was completely cleared, ensure it stays clear
      // e.g. defaultValue defined, but no selection yet made


      if (inputValue === '') {
        return {
          inputValue: ''
        };
      }
    }
  }, {
    key: "renderOptions",
    value: function renderOptions() {
      var _this$state2 = this.state,
          filteredOptions = _this$state2.filteredOptions,
          highlightedOptionId = _this$state2.highlightedOptionId,
          selectedOptionId = _this$state2.selectedOptionId;

      if (filteredOptions.length < 1) {
        return this.renderEmptyOption();
      }

      return filteredOptions.map(function (option) {
        var id = option.id,
            label = option.label;
        return /*#__PURE__*/React.createElement(Select.Option, {
          id: id,
          key: id,
          isHighlighted: id === highlightedOptionId,
          isSelected: id === selectedOptionId
        }, label);
      });
    }
  }, {
    key: "renderEmptyOption",
    value: function renderEmptyOption() {
      return /*#__PURE__*/React.createElement(Select.Option, {
        id: this._emptyOptionId,
        isHighlighted: false,
        isSelected: false
      }, callRenderProp(this.props.renderEmptyOption));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          value = _this$props2.value,
          defaultValue = _this$props2.defaultValue,
          placeholder = _this$props2.placeholder,
          renderLabel = _this$props2.renderLabel,
          label = _this$props2.label,
          inputRef = _this$props2.inputRef,
          id = _this$props2.id,
          listRef = _this$props2.listRef,
          renderBeforeInput = _this$props2.renderBeforeInput,
          renderAfterInput = _this$props2.renderAfterInput,
          isRequired = _this$props2.isRequired,
          isInline = _this$props2.isInline,
          width = _this$props2.width,
          format = _this$props2.format,
          step = _this$props2.step,
          optionsMaxWidth = _this$props2.optionsMaxWidth,
          visibleOptionsCount = _this$props2.visibleOptionsCount,
          messages = _this$props2.messages,
          placement = _this$props2.placement,
          constrain = _this$props2.constrain,
          onFocus = _this$props2.onFocus,
          onShowOptions = _this$props2.onShowOptions,
          onHideOptions = _this$props2.onHideOptions,
          rest = _objectWithoutProperties(_this$props2, ["value", "defaultValue", "placeholder", "renderLabel", "label", "inputRef", "id", "listRef", "renderBeforeInput", "renderAfterInput", "isRequired", "isInline", "width", "format", "step", "optionsMaxWidth", "visibleOptionsCount", "messages", "placement", "constrain", "onFocus", "onShowOptions", "onHideOptions"]);

      var _this$state3 = this.state,
          inputValue = _this$state3.inputValue,
          isShowingOptions = _this$state3.isShowingOptions;
      return /*#__PURE__*/React.createElement(Select, Object.assign({
        renderLabel: renderLabel || label,
        inputValue: inputValue,
        interaction: this.interaction,
        placeholder: placeholder,
        id: id,
        onFocus: onFocus,
        onBlur: this.handleBlur,
        ref: this.handleRef,
        inputRef: inputRef,
        listRef: listRef,
        isRequired: isRequired,
        isInline: isInline,
        width: width,
        optionsMaxWidth: optionsMaxWidth,
        visibleOptionsCount: visibleOptionsCount,
        messages: messages,
        placement: placement,
        constrain: constrain,
        renderBeforeInput: renderBeforeInput,
        renderAfterInput: renderAfterInput,
        isShowingOptions: isShowingOptions,
        onRequestShowOptions: this.handleShowOptions,
        onRequestHideOptions: this.handleHideOptions,
        onRequestHighlightOption: this.handleHighlightOption,
        onRequestSelectOption: this.handleSelectOption,
        onInputChange: this.handleInputChange
      }, passthroughProps(rest)), isShowingOptions && this.renderOptions());
    }
  }, {
    key: "isControlled",
    get: function get() {
      return typeof this.props.value !== 'undefined';
    }
  }, {
    key: "interaction",
    get: function get() {
      return getInteraction({
        props: this.props
      });
    }
  }, {
    key: "focused",
    get: function get() {
      return this._select && this._select.focused;
    }
  }, {
    key: "id",
    get: function get() {
      return this._select && this._select.id;
    }
  }]);

  TimeSelect.displayName = "TimeSelect";
  return TimeSelect;
}(Component), _class2.propTypes = {
  /**
   * The form field label.
   */
  renderLabel: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,

  /**
   * Whether to default to the first option when `defaultValue` hasn't been specified.
   */
  defaultToFirstOption: PropTypes.bool,

  /**
   * An ISO 8601 formatted date string representing the current selected value. If defined,
   * the component will act controlled and will not manage its own state.
   */
  value: controllable(I18nPropTypes.iso8601, 'onChange'),

  /**
   * An ISO 8601 formatted date string to use if `value` isn't provided.
   */
  defaultValue: I18nPropTypes.iso8601,

  /**
   * The id of the text input. One is generated if not supplied.
   */
  id: PropTypes.string,

  /**
   * The format to use when displaying the possible and currently selected options.
   *
   * See [moment.js formats](https://momentjs.com/docs/#/displaying/format/) for the list of available formats.
   */
  format: PropTypes.string,

  /**
   * The number of minutes to increment by when generating the allowable options.
   */
  step: PropTypes.oneOf([5, 10, 15, 20, 30, 60]),

  /**
   * Specifies if interaction with the input is enabled, disabled, or readonly.
   * When "disabled", the input changes visibly to indicate that it cannot
   * receive user interactions. When "readonly" the input still cannot receive
   * user interactions but it keeps the same styles as if it were enabled.
   */
  interaction: PropTypes.oneOf(['enabled', 'disabled', 'readonly']),

  /**
   * Html placeholder text to display when the input has no value. This should
   * be hint text, not a label replacement.
   */
  placeholder: PropTypes.string,

  /**
   * Whether or not the text input is required.
   */
  isRequired: PropTypes.bool,

  /**
   * Whether the input is rendered inline with other elements or if it
   * is rendered as a block level element.
   */
  isInline: PropTypes.bool,

  /**
   * The width of the text input.
   */
  width: PropTypes.string,

  /**
   * The max width the options list can be before option text wraps. If not
   * set, the list will only display as wide as the text input.
   */
  optionsMaxWidth: PropTypes.string,

  /**
   * The number of options that should be visible before having to scroll.
   */
  visibleOptionsCount: PropTypes.number,

  /**
   * Displays messages and validation for the input. It should be an object
   * with the following shape:
   * `{
   *   text: PropTypes.string,
   *   type: PropTypes.oneOf(['error', 'hint', 'success', 'screenreader-only'])
   * }`
   */
  messages: PropTypes.arrayOf(FormPropTypes.message),

  /**
   * The placement of the options list.
   */
  placement: PositionPropTypes.placement,

  /**
   * The parent in which to constrain the placement.
   */
  constrain: PositionPropTypes.constrain,

  /**
   * Callback fired when a new option is selected.
   * @param {Object} event - the event object
   * @param {Object} data - additional data
   * @param data.value - the value of selected option
   */
  onChange: PropTypes.func,

  /**
   * Callback fired when text input receives focus.
   */
  onFocus: PropTypes.func,

  /**
   * Callback fired when text input loses focus.
   */
  onBlur: PropTypes.func,

  /**
   * Callback fired when the options list is shown.
   */
  onShowOptions: PropTypes.func,

  /**
   * Callback fired when the options list is hidden.
   */
  onHideOptions: PropTypes.func,

  /**
   * A ref to the html `input` element.
   */
  inputRef: PropTypes.func,

  /**
   * A ref to the html `ul` element.
   */
  listRef: PropTypes.func,

  /**
   * Content to display in the list when no options are available.
   */
  renderEmptyOption: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

  /**
   * Content to display before the text input. This will commonly be an icon.
   */
  renderBeforeInput: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

  /**
   * Content to display after the text input. This content will replace the
   * default arrow icons.
   */
  renderAfterInput: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

  /* eslint-disable react/require-default-props */

  /**
   * A standard language identifier.
   *
   * See [moment.js i18n](https://momentjs.com/docs/#/i18n/) for more details.
   *
   * This property can also be set via a context property and if both are set then the component property takes
   * precedence over the context property.
   *
   * The web browser's locale will be used if no value is set via a component property or a context
   * property.
   */
  locale: PropTypes.string,

  /**
   * A timezone identifier in the format: Area/Location
   *
   * See [List of tz database time zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for the list
   * of possible options.
   *
   * This property can also be set via a context property and if both are set then the component property takes
   * precedence over the context property.
   *
   * The web browser's timezone will be used if no value is set via a component property or a context
   * property.
   */
  timezone: PropTypes.string,

  /**
   * __Deprecated - use `renderLabel`__
   */
  label: PropTypes.node
  /* eslint-enable react/require-default-props */

}, _class2.defaultProps = {
  value: void 0,
  defaultValue: void 0,
  defaultToFirstOption: false,
  id: void 0,
  format: 'LT',
  step: 30,
  interaction: void 0,
  placeholder: void 0,
  isRequired: false,
  isInline: false,
  width: void 0,
  optionsMaxWidth: void 0,
  visibleOptionsCount: 8,
  messages: void 0,
  placement: 'bottom stretch',
  constrain: 'window',
  onChange: function onChange(event, data) {},
  onFocus: function onFocus(event) {},
  onBlur: function onBlur(event) {},
  onShowOptions: function onShowOptions(event) {},
  onHideOptions: function onHideOptions(event) {},
  inputRef: function inputRef(node) {},
  listRef: function listRef(node) {},
  renderEmptyOption: '---',
  renderBeforeInput: null,
  renderAfterInput: null
}, _class2.contextTypes = {
  locale: PropTypes.string,
  timezone: PropTypes.string
}, _temp)) || _class) || _class);
export { TimeSelect };
export default TimeSelect;
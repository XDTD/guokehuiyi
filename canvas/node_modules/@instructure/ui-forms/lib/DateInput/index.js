"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "DatePicker", {
  enumerable: true,
  get: function get() {
    return _DatePicker.DatePicker;
  }
});
exports.DateInput = exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _createSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/createSuper"));

var _console = require("@instructure/console");

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _keycode = _interopRequireDefault(require("keycode"));

var _controllable = require("@instructure/ui-prop-types/lib/controllable.js");

var _DateTime = require("@instructure/ui-i18n/lib/DateTime.js");

var _I18nPropTypes = require("@instructure/ui-i18n/lib/I18nPropTypes.js");

var _Locale = require("@instructure/ui-i18n/lib/Locale.js");

var _FormPropTypes = require("@instructure/ui-form-field/lib/FormPropTypes.js");

var _LayoutPropTypes = require("@instructure/ui-layout/lib/LayoutPropTypes.js");

var _Popover = require("@instructure/ui-overlays/lib/Popover");

var _createChainedFunction = require("@instructure/ui-utils/lib/createChainedFunction.js");

var _isActiveElement = require("@instructure/ui-dom-utils/lib/isActiveElement.js");

var _themeable = require("@instructure/ui-themeable/lib/themeable.js");

var _deprecated = require("@instructure/ui-react-utils/lib/deprecated.js");

var _omitProps = require("@instructure/ui-react-utils/lib/omitProps.js");

var _pickProps = require("@instructure/ui-react-utils/lib/pickProps.js");

var _testable = require("@instructure/ui-testable/lib/testable.js");

var _TextInput = require("@instructure/ui-text-input/lib/TextInput");

var _DatePicker = require("./DatePicker");

var _theme = _interopRequireDefault(require("./theme"));

var _dateHelpers = require("./utils/dateHelpers");

var _dec, _dec2, _dec3, _class, _class2, _temp;

var styles = {
  componentId: 'fabZw',
  template: function template(theme) {
    return "\n\n.fabZw_bGBk{background:".concat(theme.background || 'inherit', ";color:").concat(theme.color || 'inherit', ";font-family:").concat(theme.fontFamily || 'inherit', ";font-size:").concat(theme.fontSize || 'inherit', ";font-weight:").concat(theme.fontWeight || 'inherit', "}");
  },
  'root': 'fabZw_bGBk'
};

/**
---
category: components/deprecated
id: DeprecatedDateInput
---
**/
var DateInput = (_dec = (0, _testable.testable)(), _dec2 = (0, _deprecated.deprecated)('7.0.0', null, 'Use DateInput from ui-date-input instead.'), _dec3 = (0, _themeable.themeable)(_theme.default, styles), _dec(_class = _dec2(_class = _dec3(_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
  (0, _inherits2.default)(DateInput, _Component);

  var _super = (0, _createSuper2.default)(DateInput);

  function DateInput(props, context) {
    var _this;

    (0, _classCallCheck2.default)(this, DateInput);
    _this = _super.call(this, props, context);

    _this.textInputRef = function (node) {
      _this._input = node;

      if (node) {
        _this.props.inputRef(node);
      }
    };

    _this.handleTextInputChange = function (event) {
      // because we're controlling the TextInput
      _this.setState({
        textInputValue: event.target.value,
        showCalendar: false
      });
    };

    _this.handleTextInputKeyDown = function (event) {
      if (event.keyCode === _keycode.default.codes.enter) {
        event.preventDefault(); // prevent form submission

        _this.acceptValue(event);
      }
    };

    _this.handleTextInputClick = function (event) {
      // accept the current value first so the calendar shows the correct selected date
      _this.acceptValue(event);

      _this.showCalendar();
    };

    _this.handleTextInputBlur = function (event) {
      // when focus leaves the textInput field, replace its text with the properly formatted
      // string for the date. This is handy because once the user types "Nov", we will parse that
      // into November 1st of the current year.
      _this.acceptValue(event);
    };

    _this.handleCalendarSelect = function (event, newValue) {
      var parsedDate = _this.parseDate(newValue);

      /*#__PURE__*/
      ( /*#__PURE__*/0, _console.error)(parsedDate.isValid(), "[DateInput] Unexpected date format received from DatePicker: '".concat(newValue, "'."));

      _this.acceptValue(event, newValue);

      if (parsedDate.isValid()) {
        _this.hideCalendar();
      }
    };

    _this.handleCalendarDismiss = function () {
      _this.hideCalendar();
    };

    var initialDateValue = props.dateValue || props.defaultDateValue || void 0;

    var locale = _this._locale(props, context);

    var timezone = _this._timezone(props, context);

    var _parsedDate = _this._parseDate(initialDateValue, locale, timezone);

    /*#__PURE__*/
    ( /*#__PURE__*/0, _console.error)(!initialDateValue || _parsedDate.isValid(), "[DateInput] Unexpected date format received: '".concat(initialDateValue, "'."));
    _this.state = (0, _objectSpread2.default)({
      showCalendar: false
    }, _this.computeState(initialDateValue, _parsedDate, props));
    delete _this._input;
    return _this;
  }

  (0, _createClass2.default)(DateInput, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      var valueChanged = nextProps.dateValue !== this.props.dateValue || nextProps.defaultDateValue !== this.props.defaultDateValue;
      var isUpdated = valueChanged || nextProps.locale !== this.props.locale || nextProps.timezone !== this.props.timezone;

      if (isUpdated) {
        this.setState(function (prevState) {
          var value = valueChanged ? nextProps.dateValue != null ? nextProps.dateValue : nextProps.defaultDateValue || void 0 : prevState.acceptedValue;
          var locale = nextProps.locale || _this2.locale;
          var timezone = nextProps.timezone || _this2.timezone;

          var parsedDate = _this2._parseDate(value, locale, timezone);

          /*#__PURE__*/
          ( /*#__PURE__*/0, _console.error)(!value || parsedDate.isValid(), "[DateInput] Unexpected date format received: '".concat(value, "'."));
          return _this2.computeState(value, parsedDate, nextProps, prevState);
        });
      }
    }
    /**
    * focus the input element
    */

  }, {
    key: "focus",
    value: function focus() {
      this._input.focus();
    }
  }, {
    key: "toggleCalendar",
    value: function toggleCalendar(showCalendar) {
      this.setState({
        showCalendar: showCalendar
      });
    }
  }, {
    key: "showCalendar",
    value: function showCalendar() {
      this.toggleCalendar(true);
    }
  }, {
    key: "hideCalendar",
    value: function hideCalendar() {
      this.toggleCalendar(false);
    }
  }, {
    key: "acceptValue",
    value: function acceptValue(event, dateStr) {
      var _this3 = this;

      var rawAcceptedValue = dateStr || event.target.value;
      this.setState(function (state, props) {
        var parsedDate = _this3.parseDate(rawAcceptedValue).hour(state.hour).minute(state.minute).second(state.second).millisecond(state.millisecond);

        var newState = _this3.computeState(rawAcceptedValue, parsedDate, props, state);

        var acceptedValueChanged = newState.acceptedValue !== state.acceptedValue;
        var validOrEmptyChanged = newState.isValidOrEmpty !== state.isValidOrEmpty;
        var dateIsDisabled = parsedDate.isValid() ? (0, _dateHelpers.isDayDisabled)(parsedDate, _this3.props.disabledDaysOfWeek, _this3.props.disabledDays) : false;

        if ((acceptedValueChanged || validOrEmptyChanged) && typeof _this3.props.onDateChange === 'function') {
          _this3.props.onDateChange(event, // since the API here is ISO dates in, we should pass an ISO date back in the handler
          newState.acceptedValue, newState.textInputValue, !newState.isValidOrEmpty, dateIsDisabled);
        }

        return newState;
      });
    }
  }, {
    key: "_parseDate",
    value: function _parseDate(dateStr, locale, timezone) {
      return _DateTime.DateTime.parse(dateStr, locale, timezone);
    }
  }, {
    key: "_timezone",
    value: function _timezone(props, context) {
      return props.timezone || context.timezone || _DateTime.DateTime.browserTimeZone();
    }
  }, {
    key: "_locale",
    value: function _locale(props, context) {
      return props.locale || context.locale || _Locale.Locale.browserLocale();
    }
  }, {
    key: "parseDate",
    value: function parseDate(dateStr) {
      return this._parseDate(dateStr, this.locale, this.timezone);
    }
  }, {
    key: "computeState",
    value: function computeState(rawValue, parsedDate, props, state) {
      if (parsedDate.isValid()) {
        return {
          isValidOrEmpty: true,
          acceptedValue: parsedDate.toISOString(true),
          textInputValue: parsedDate.format(props.format),
          hour: parsedDate.hour(),
          minute: parsedDate.minute(),
          second: parsedDate.second(),
          millisecond: parsedDate.millisecond()
        };
      } else {
        var textInputValue = state ? state.textInputValue : '';

        if (rawValue === '') {
          textInputValue = '';
        }

        return {
          isValidOrEmpty: !rawValue,
          acceptedValue: void 0,
          textInputValue: textInputValue || '',
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0
        };
      }
    }
  }, {
    key: "render",
    value: function render() {
      var ignoredProps = ['type', 'messages', 'defaultValue', 'value'];
      var textInputProps = (0, _pickProps.pickProps)(this.props, (0, _omitProps.omitProps)(_TextInput.TextInput.propTypes, {}, ignoredProps));
      var _this$props = this.props,
          onChange = _this$props.onChange,
          onKeyDown = _this$props.onKeyDown,
          onClick = _this$props.onClick,
          onBlur = _this$props.onBlur; // eslint-disable-line react/prop-types

      return /*#__PURE__*/_react.default.createElement("span", null, /*#__PURE__*/_react.default.createElement(_TextInput.TextInput, Object.assign({}, textInputProps, {
        value: this.state.textInputValue,
        messages: this.messages,
        onChange: (0, _createChainedFunction.createChainedFunction)(onChange, this.handleTextInputChange),
        onKeyDown: (0, _createChainedFunction.createChainedFunction)(onKeyDown, this.handleTextInputKeyDown),
        onClick: (0, _createChainedFunction.createChainedFunction)(onClick, this.handleTextInputClick),
        onBlur: (0, _createChainedFunction.createChainedFunction)(onBlur, this.handleTextInputBlur),
        inputRef: this.textInputRef
      })), /*#__PURE__*/_react.default.createElement(_Popover.Popover, {
        placement: this.props.placement,
        show: this.state.showCalendar,
        onDismiss: this.handleCalendarDismiss,
        positionTarget: this._input
      }, /*#__PURE__*/_react.default.createElement(_Popover.Popover.Content, null, /*#__PURE__*/_react.default.createElement(_DatePicker.DatePicker, {
        todayValue: this.props.todayValue,
        previousLabel: this.props.previousLabel,
        nextLabel: this.props.nextLabel,
        selectedValue: this.calendarSelectedValue,
        locale: this.locale,
        timezone: this.timezone,
        onSelectedChange: this.handleCalendarSelect,
        disabledDaysOfWeek: this.props.disabledDaysOfWeek,
        disabledDays: this.props.disabledDays,
        ref: this.props.datePickerRef
      }))));
    }
  }, {
    key: "hasMessages",
    get: function get() {
      return this.messages && this.messages.length > 0;
    }
  }, {
    key: "invalid",
    get: function get() {
      return this.messages && this.messages.findIndex(function (message) {
        return message.type === 'error';
      }) >= 0;
    }
  }, {
    key: "focused",
    get: function get() {
      // either the input has focus, or the calendar is open, in which case
      // it has focus
      return (0, _isActiveElement.isActiveElement)(this._input) || this.state.showCalendar;
    }
  }, {
    key: "value",
    get: function get() {
      return this._input.value;
    }
  }, {
    key: "calendarSelectedValue",
    get: function get() {
      var acceptedValue = this.state.acceptedValue;
      var value = acceptedValue ? this.parseDate(acceptedValue) : void 0;

      if (!value || !value.isValid()) {
        value = _DateTime.DateTime.now(this.locale, this.timezone);
      }

      return value.toISOString(true);
    }
  }, {
    key: "locale",
    get: function get() {
      return this._locale(this.props, this.context);
    }
  }, {
    key: "timezone",
    get: function get() {
      return this._timezone(this.props, this.context);
    }
  }, {
    key: "messages",
    get: function get() {
      if (!this.props.validationFeedback || !this.state.textInputValue) {
        return this.props.messages;
      }

      var messages = [];
      var parsedDate = this.parseDate(this.state.textInputValue);
      var isValid = parsedDate.isValid();

      if (isValid && (0, _dateHelpers.isDayDisabled)(parsedDate, this.props.disabledDaysOfWeek, this.props.disabledDays)) {
        var disabledDateMessage = this.props.disabledDateMessage;

        if (typeof disabledDateMessage === 'function') {
          disabledDateMessage = disabledDateMessage(this.state.textInputValue);
        }

        messages.push({
          text: disabledDateMessage || "".concat(parsedDate.format(this.props.format), " is disabled"),
          type: 'error'
        });
      } else if (isValid) {
        messages.push({
          text: parsedDate.format(this.props.format),
          type: 'success'
        });
      } else {
        var invalidDateMessage = this.props.invalidDateMessage;

        if (typeof invalidDateMessage === 'function') {
          invalidDateMessage = invalidDateMessage(this.state.textInputValue);
        }

        messages.push({
          text: invalidDateMessage || parsedDate.format(this.props.format),
          type: 'error'
        });
      }

      return messages.concat(this.props.messages);
    }
  }]);
  DateInput.displayName = "DateInput";
  return DateInput;
}(_react.Component), _class2.propTypes = {
  /**
    The label to put on the previous month button of the calendar.
  **/
  previousLabel: _propTypes.default.string.isRequired,

  /**
    The label to put on the next month button of the calendar.
  **/
  nextLabel: _propTypes.default.string.isRequired,

  /**
   * The message that's used when the data is invalid.
   */
  invalidDateMessage: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func]).isRequired,

  /**
   * The message that's used when a date is disabled
   */
  disabledDateMessage: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func]),

  /**
   * Where the calendar popover should be placed.
   */
  placement: _LayoutPropTypes.LayoutPropTypes.placement,

  /**
    This display to show in the input when a date is selected.
    Valid formats are compatible with
    [moment.js formats](https://momentjs.com/docs/#/displaying/format/),
    including localized formats.
  **/
  format: _propTypes.default.string,
  // display format

  /**
  * object with shape: `{
  * text: PropTypes.string,
  * type: PropTypes.oneOf(['error', 'hint', 'success', 'screenreader-only'])
  *   }`
  */
  messages: _propTypes.default.arrayOf(_FormPropTypes.FormPropTypes.message),

  /**
    A standard language id
  **/
  locale: _propTypes.default.string,

  /**
    A timezone identifier in the format: Area/Location
  **/
  timezone: _propTypes.default.string,

  /**
    An ISO 8601 formatted string. The initial date value to display on render.
    It should only be used when using this component as an uncontrolled input.
  **/
  defaultDateValue: _I18nPropTypes.I18nPropTypes.iso8601,

  /**
    Called when the date value of the input has changed.
    The parameters are the triggering event, new date value in ISO 8601 format,
    the raw user input, if the conversion from raw to a date was successful, and
    if the selected date is disabled.
  **/
  onDateChange: _propTypes.default.func,

  /**
  * the selected value (must be accompanied by an `onDateChange` prop)
  */
  dateValue: (0, _controllable.controllable)(_I18nPropTypes.I18nPropTypes.iso8601, 'onDateChange', 'defaultDateValue'),

  /**
    Whether to display validation feedback while typing.
  **/
  validationFeedback: _propTypes.default.bool,
  datePickerRef: _propTypes.default.func,
  inputRef: _propTypes.default.func,

  /**
    An ISO 8601 formatted string. Defaults to the current date.
  **/
  todayValue: _I18nPropTypes.I18nPropTypes.iso8601,
  size: _propTypes.default.oneOf(['small', 'medium', 'large']),
  layout: _propTypes.default.oneOf(['stacked', 'inline']),
  width: _propTypes.default.string,
  inline: _propTypes.default.bool,

  /**
  * Html placeholder text to display when the input has no value. This should be hint text, not a label
  * replacement.
  */
  placeholder: _propTypes.default.string,

  /**
   * Whether or not to disable the input
   */
  disabled: _propTypes.default.bool,

  /**
   * Works just like disabled but keeps the same styles as if it were active
   */
  readOnly: _propTypes.default.bool,
  required: _propTypes.default.bool,

  /**
    An array of weekdays that should be unselectable. Each day should be an integer
    corresponding to the day of the week, where 0 = Sunday, 1 = Monday, 2 = Tuesday,
    3 = Wednesday, 4 = Thursday, 5 = Friday, 6 = Saturday.
  **/
  disabledDaysOfWeek: _propTypes.default.array,

  /**
    An array of Date objects that should be unselectable or a callback function
    that gets passed a date and should return a boolean indicating where it is
    unselectable.
  **/
  disabledDays: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.func])
}, _class2.defaultProps = {
  disabledDateMessage: void 0,
  placement: 'bottom center',
  messages: [],
  format: 'LL',
  validationFeedback: true,
  onDateChange: function onDateChange(e, isoValue, rawValue, rawConversionFailed, dateIsDisabled) {},
  datePickerRef: function datePickerRef(el) {},
  inputRef: function inputRef(el) {},
  invalidDateMessage: function invalidDateMessage(textInputValue) {},
  required: false,
  inline: false,
  size: 'medium',
  disabled: false,
  readOnly: false,
  layout: 'stacked',
  disabledDaysOfWeek: [],
  disabledDays: [],
  placeholder: void 0,
  width: void 0,
  todayValue: void 0,
  dateValue: void 0,
  defaultDateValue: void 0,
  timezone: void 0,
  locale: void 0
}, _class2.contextTypes = {
  locale: _propTypes.default.string,
  timezone: _propTypes.default.string
}, _temp)) || _class) || _class) || _class);
exports.DateInput = DateInput;
var _default = DateInput;
exports.default = _default;
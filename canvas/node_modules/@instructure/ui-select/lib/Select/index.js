"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Select = exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _createSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/createSuper"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames2 = _interopRequireDefault(require("classnames"));

var _Children = require("@instructure/ui-prop-types/lib/Children.js");

var _FormPropTypes = require("@instructure/ui-form-field/lib/FormPropTypes.js");

var _createChainedFunction = require("@instructure/ui-utils/lib/createChainedFunction.js");

var _themeable = require("@instructure/ui-themeable/lib/themeable.js");

var _testable = require("@instructure/ui-testable/lib/testable.js");

var _matchComponentTypes = require("@instructure/ui-react-utils/lib/matchComponentTypes.js");

var _omitProps = require("@instructure/ui-react-utils/lib/omitProps.js");

var _getInteraction = require("@instructure/ui-react-utils/lib/getInteraction.js");

var _getBoundingClientRect = require("@instructure/ui-dom-utils/lib/getBoundingClientRect.js");

var _isActiveElement = require("@instructure/ui-dom-utils/lib/isActiveElement.js");

var _PositionPropTypes = require("@instructure/ui-position/lib/PositionPropTypes.js");

var _View = require("@instructure/ui-view/lib/View");

var _Selectable = require("@instructure/ui-selectable/lib/Selectable");

var _Popover = require("@instructure/ui-popover/lib/Popover");

var _TextInput = require("@instructure/ui-text-input/lib/TextInput");

var _Options = require("@instructure/ui-options/lib/Options");

var _IconArrowOpenDownLine = require("@instructure/ui-icons/lib/IconArrowOpenDownLine.js");

var _IconArrowOpenUpLine = require("@instructure/ui-icons/lib/IconArrowOpenUpLine.js");

var _uid = require("@instructure/uid");

var _index = require("./Group/index.js");

var _index2 = require("./Option/index.js");

var _theme = _interopRequireDefault(require("./theme.js"));

var _dec, _dec2, _class, _class2, _temp;

var styles = {
  componentId: 'cCAhm',
  template: function template(theme) {
    return "\n\n.cCAhm_bGBk{color:".concat(theme.color || 'inherit', ";font-family:").concat(theme.fontFamily || 'inherit', ";font-size:").concat(theme.fontSize || 'inherit', ";font-weight:").concat(theme.fontWeight || 'inherit', "}\n\n.cCAhm_doqw .cCAhm_dnnz{font-size:").concat(theme.smallIconSize || 'inherit', "}\n\n.cCAhm_ycrn .cCAhm_dnnz{font-size:").concat(theme.mediumIconSize || 'inherit', "}\n\n.cCAhm_cMDj .cCAhm_dnnz{font-size:").concat(theme.largeIconSize || 'inherit', "}\n\n.cCAhm_dJgE{display:none}");
  },
  'root': 'cCAhm_bGBk',
  'small': 'cCAhm_doqw',
  'icon': 'cCAhm_dnnz',
  'medium': 'cCAhm_ycrn',
  'large': 'cCAhm_cMDj',
  'assistiveText': 'cCAhm_dJgE'
};

var _ref3 = /*#__PURE__*/_react.default.createElement(_Options.Options.Separator, null);

var _ref4 = /*#__PURE__*/_react.default.createElement(_Options.Options.Separator, null);

var _ref5 = /*#__PURE__*/_react.default.createElement(_IconArrowOpenUpLine.IconArrowOpenUpLine, {
  inline: false
});

var _ref6 = /*#__PURE__*/_react.default.createElement(_IconArrowOpenDownLine.IconArrowOpenDownLine, {
  inline: false
});

/**
---
category: components
tags: autocomplete, typeahead, combobox, dropdown, search, form
---
**/
var Select = (_dec = (0, _testable.testable)(), _dec2 = (0, _themeable.themeable)(_theme.default, styles), _dec(_class = _dec2(_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
  (0, _inherits2.default)(Select, _Component);

  var _super = (0, _createSuper2.default)(Select);

  function Select() {
    var _this;

    (0, _classCallCheck2.default)(this, Select);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      hasInputRef: false
    };
    _this._defaultId = (0, _uid.uid)('Select');
    _this._assistId = (0, _uid.uid)('Select-assistiveText');
    _this._input = null;
    _this._inputContainer = null;
    _this._list = null;
    _this._optionIds = [];
    _this._optionHeight = 36;

    _this.handleInputRef = function (node) {
      // ensures list is positioned with respect to input if list is open on mount
      if (!_this.state.hasInputRef) {
        _this.setState({
          hasInputRef: true
        });
      }

      _this._input = node;

      _this.props.inputRef(node);
    };

    _this.handleListRef = function (node) {
      _this._list = node;

      _this.props.listRef(node); // store option height to calculate list maxHeight


      if (node && node.querySelector('[role="option"]')) {
        _this._optionHeight = node.querySelector('[role="option"]').offsetHeight;
      }
    };

    _this.handleInputContainerRef = function (node) {
      _this._inputContainer = node;
    };

    return _this;
  }

  (0, _createClass2.default)(Select, [{
    key: "focus",
    value: function focus() {
      this._input && this._input.focus();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      // scroll option into view if needed
      this.scrollToOption(this.highlightedOptionId);
    }
  }, {
    key: "scrollToOption",
    value: function scrollToOption(id) {
      if (this._listView) {
        var option = this._listView.querySelector("[id=\"".concat(id, "\"]"));

        if (!option) return;
        var listItem = option.parentNode;
        var parentTop = (0, _getBoundingClientRect.getBoundingClientRect)(this._listView).top;
        var elemTop = (0, _getBoundingClientRect.getBoundingClientRect)(listItem).top;
        var parentBottom = parentTop + this._listView.clientHeight;
        var elemBottom = elemTop + listItem.clientHeight;

        if (elemBottom > parentBottom) {
          this._listView.scrollTop += elemBottom - parentBottom;
        } else if (elemTop < parentTop) {
          this._listView.scrollTop -= parentTop - elemTop;
        }
      }
    }
  }, {
    key: "highlightOption",
    value: function highlightOption(event, id) {
      var onRequestHighlightOption = this.props.onRequestHighlightOption;

      if (id) {
        onRequestHighlightOption(event, {
          id: id
        });
      }
    }
  }, {
    key: "getEventHandlers",
    value: function getEventHandlers() {
      var _this2 = this;

      var _this$props = this.props,
          isShowingOptions = _this$props.isShowingOptions,
          _onRequestShowOptions = _this$props.onRequestShowOptions,
          _onRequestHideOptions = _this$props.onRequestHideOptions,
          _onRequestSelectOption = _this$props.onRequestSelectOption;
      var highlightedOptionId = this.highlightedOptionId;
      var selectedOptionId = this.selectedOptionId;
      return this.interaction === 'enabled' ? {
        onRequestShowOptions: function onRequestShowOptions(event) {
          _onRequestShowOptions(event);

          if (selectedOptionId && !Array.isArray(selectedOptionId)) {
            // highlight selected option on show
            _this2.highlightOption(event, selectedOptionId);
          }
        },
        onRequestHideOptions: function onRequestHideOptions(event) {
          _onRequestHideOptions(event);
        },
        onRequestHighlightOption: function onRequestHighlightOption(event, _ref) {
          var id = _ref.id,
              direction = _ref.direction;
          if (!isShowingOptions) return; // if id exists, use that

          var highlightId = _this2._optionIds.indexOf(id) > -1 ? id : null;

          if (!highlightId) {
            if (!highlightedOptionId) {
              // nothing highlighted yet, highlight first option
              highlightId = _this2._optionIds[0];
            } else {
              // find next id based on direction
              var index = _this2._optionIds.indexOf(highlightedOptionId);

              highlightId = index > -1 ? _this2._optionIds[index + direction] : null;
            }
          }

          if (highlightId) {
            // only highlight if id exists as a valid option
            _this2.highlightOption(event, highlightId);
          }
        },
        onRequestHighlightFirstOption: function onRequestHighlightFirstOption(event) {
          _this2.highlightOption(event, _this2._optionIds[0]);
        },
        onRequestHighlightLastOption: function onRequestHighlightLastOption(event) {
          _this2.highlightOption(event, _this2._optionIds[_this2._optionIds.length - 1]);
        },
        onRequestSelectOption: function onRequestSelectOption(event, _ref2) {
          var id = _ref2.id;

          if (id && _this2._optionIds.indexOf(id) !== -1) {
            // only select if id exists as a valid option
            _onRequestSelectOption(event, {
              id: id
            });
          }
        }
      } : {};
    }
  }, {
    key: "renderOption",
    value: function renderOption(option, data) {
      var getOptionProps = data.getOptionProps,
          getDisabledOptionProps = data.getDisabledOptionProps;
      var _option$props = option.props,
          id = _option$props.id,
          isDisabled = _option$props.isDisabled,
          isHighlighted = _option$props.isHighlighted,
          isSelected = _option$props.isSelected,
          renderBeforeLabel = _option$props.renderBeforeLabel,
          renderAfterLabel = _option$props.renderAfterLabel,
          children = _option$props.children;
      var optionProps = (0, _objectSpread2.default)({}, (0, _omitProps.omitProps)(option.props, (0, _objectSpread2.default)({}, _index2.Option.propTypes, {}, _Options.Options.Item.propTypes)), {}, getOptionProps({
        id: id
      }), {
        // Options.Item props
        renderBeforeLabel: renderBeforeLabel,
        renderAfterLabel: renderAfterLabel
      }); // should option be treated as highlighted or selected

      if (isSelected) {
        optionProps.variant = 'selected';
      } else if (isHighlighted) {
        optionProps.variant = 'highlighted';
      } // should option be treated as disabled


      if (isDisabled) {
        optionProps.variant = 'disabled';
        optionProps = (0, _objectSpread2.default)({}, optionProps, {}, getDisabledOptionProps());
      } else {
        // track as valid option if not disabled
        this._optionIds.push(id);
      }

      return /*#__PURE__*/_react.default.createElement(_Options.Options.Item, optionProps, children);
    }
  }, {
    key: "renderGroup",
    value: function renderGroup(group, data) {
      var _this3 = this;

      var getOptionProps = data.getOptionProps,
          getDisabledOptionProps = data.getDisabledOptionProps,
          isFirstChild = data.isFirstChild,
          isLastChild = data.isLastChild,
          afterGroup = data.afterGroup;
      var _group$props = group.props,
          id = _group$props.id,
          renderLabel = _group$props.renderLabel,
          children = _group$props.children,
          rest = (0, _objectWithoutProperties2.default)(_group$props, ["id", "renderLabel", "children"]);
      var groupChildren = []; // add a separator above

      if (!isFirstChild && !afterGroup) {
        groupChildren.push(_ref3);
      } // create a sublist as a group
      // a wrapping listitem will be created by Options


      groupChildren.push( /*#__PURE__*/_react.default.createElement(_Options.Options, Object.assign({
        id: id,
        as: "ul",
        role: "group",
        renderLabel: renderLabel
      }, (0, _omitProps.omitProps)(rest, (0, _objectSpread2.default)({}, _Options.Options.propTypes, {}, _index.Group.propTypes))), _react.Children.map(children, function (child) {
        return _this3.renderOption(child, {
          getOptionProps: getOptionProps,
          getDisabledOptionProps: getDisabledOptionProps
        });
      }))); // add a separator below

      if (!isLastChild) {
        groupChildren.push(_ref4);
      }

      return groupChildren;
    }
  }, {
    key: "renderList",
    value: function renderList(data) {
      var _this4 = this;

      var getListProps = data.getListProps,
          getOptionProps = data.getOptionProps,
          getDisabledOptionProps = data.getDisabledOptionProps;
      var _this$props2 = this.props,
          isShowingOptions = _this$props2.isShowingOptions,
          optionsMaxWidth = _this$props2.optionsMaxWidth,
          visibleOptionsCount = _this$props2.visibleOptionsCount,
          children = _this$props2.children;
      var lastWasGroup = false;
      var viewProps = isShowingOptions ? {
        display: 'block',
        overflowY: 'auto',
        maxHeight: this._optionHeight * visibleOptionsCount,
        maxWidth: optionsMaxWidth || this.width,
        background: 'primary',
        elementRef: function elementRef(node) {
          return _this4._listView = node;
        }
      } : {
        maxHeight: 0
      };
      return /*#__PURE__*/_react.default.createElement(_View.View, viewProps, /*#__PURE__*/_react.default.createElement(_Options.Options, getListProps({
        as: 'ul',
        elementRef: this.handleListRef
      }), isShowingOptions ? _react.Children.map(children, function (child, index) {
        if (!child || !(0, _matchComponentTypes.matchComponentTypes)(child, [_index.Group, _index2.Option])) {
          return; // ignore invalid children
        }

        if ((0, _matchComponentTypes.matchComponentTypes)(child, [_index2.Option])) {
          lastWasGroup = false;
          return _this4.renderOption(child, {
            getOptionProps: getOptionProps,
            getDisabledOptionProps: getDisabledOptionProps
          });
        }

        if ((0, _matchComponentTypes.matchComponentTypes)(child, [_index.Group])) {
          var afterGroup = lastWasGroup ? true : false;
          lastWasGroup = true;
          return _this4.renderGroup(child, {
            getOptionProps: getOptionProps,
            getDisabledOptionProps: getDisabledOptionProps,
            // for rendering separators appropriately
            isFirstChild: index === 0,
            isLastChild: index === _react.Children.count(children) - 1,
            afterGroup: afterGroup
          });
        }
      }) : null));
    }
  }, {
    key: "renderIcon",
    value: function renderIcon() {
      return /*#__PURE__*/_react.default.createElement("span", {
        className: styles.icon
      }, this.props.isShowingOptions ? _ref5 : _ref6);
    }
  }, {
    key: "renderInput",
    value: function renderInput(data) {
      var getInputProps = data.getInputProps,
          getTriggerProps = data.getTriggerProps;
      var _this$props3 = this.props,
          renderLabel = _this$props3.renderLabel,
          inputValue = _this$props3.inputValue,
          placeholder = _this$props3.placeholder,
          isRequired = _this$props3.isRequired,
          shouldNotWrap = _this$props3.shouldNotWrap,
          size = _this$props3.size,
          isInline = _this$props3.isInline,
          width = _this$props3.width,
          htmlSize = _this$props3.htmlSize,
          messages = _this$props3.messages,
          renderBeforeInput = _this$props3.renderBeforeInput,
          renderAfterInput = _this$props3.renderAfterInput,
          onFocus = _this$props3.onFocus,
          onBlur = _this$props3.onBlur,
          onInputChange = _this$props3.onInputChange,
          onRequestHideOptions = _this$props3.onRequestHideOptions,
          rest = (0, _objectWithoutProperties2.default)(_this$props3, ["renderLabel", "inputValue", "placeholder", "isRequired", "shouldNotWrap", "size", "isInline", "width", "htmlSize", "messages", "renderBeforeInput", "renderAfterInput", "onFocus", "onBlur", "onInputChange", "onRequestHideOptions"]);
      var interaction = this.interaction;
      var passthroughProps = (0, _omitProps.omitProps)(rest, Select.propTypes);

      var _getTriggerProps = getTriggerProps((0, _objectSpread2.default)({}, passthroughProps)),
          ref = _getTriggerProps.ref,
          triggerProps = (0, _objectWithoutProperties2.default)(_getTriggerProps, ["ref"]);

      var isEditable = typeof onInputChange !== 'undefined'; // props to ensure screen readers treat uneditable selects as accessible
      // popup buttons rather than comboboxes.

      var overrideProps = !isEditable ? {
        role: 'button',
        title: inputValue,
        'aria-autocomplete': null
      } : {}; // backdoor to autocomplete attr to work around chrome autofill issues

      if (passthroughProps['autoComplete']) {
        overrideProps.autoComplete = passthroughProps['autoComplete'];
      }

      return /*#__PURE__*/_react.default.createElement(_TextInput.TextInput, Object.assign({}, triggerProps, getInputProps((0, _objectSpread2.default)({
        id: this.id,
        renderLabel: renderLabel,
        placeholder: placeholder,
        size: size,
        width: width,
        htmlSize: htmlSize,
        messages: messages,
        value: inputValue,
        inputRef: (0, _createChainedFunction.createChainedFunction)(ref, this.handleInputRef),
        inputContainerRef: this.handleInputContainerRef,
        interaction: interaction === 'enabled' && !isEditable ? 'readonly' // prevent keyboard cursor
        : interaction,
        isRequired: isRequired,
        shouldNotWrap: shouldNotWrap,
        display: isInline ? 'inline-block' : 'block',
        renderBeforeInput: renderBeforeInput,
        renderAfterInput: renderAfterInput || this.renderIcon(),
        onChange: onInputChange,
        onFocus: onFocus,
        onBlur: (0, _createChainedFunction.createChainedFunction)(onBlur, onRequestHideOptions)
      }, overrideProps))));
    }
  }, {
    key: "render",
    value: function render() {
      var _this5 = this;

      var _this$props4 = this.props,
          size = _this$props4.size,
          constrain = _this$props4.constrain,
          placement = _this$props4.placement,
          mountNode = _this$props4.mountNode,
          assistiveText = _this$props4.assistiveText,
          isShowingOptions = _this$props4.isShowingOptions; // clear temporary option store

      this._optionIds = [];
      var highlightedOptionId = this.highlightedOptionId;
      var selectedOptionId = this.selectedOptionId;
      var classes = (0, _classnames2.default)(styles.root, (0, _defineProperty2.default)({}, styles[size], size));
      return /*#__PURE__*/_react.default.createElement(_Selectable.Selectable, Object.assign({
        highlightedOptionId: highlightedOptionId,
        isShowingOptions: isShowingOptions,
        selectedOptionId: selectedOptionId ? selectedOptionId : null
      }, this.getEventHandlers()), function (_ref7) {
        var getRootProps = _ref7.getRootProps,
            getInputProps = _ref7.getInputProps,
            getTriggerProps = _ref7.getTriggerProps,
            getListProps = _ref7.getListProps,
            getOptionProps = _ref7.getOptionProps,
            getDisabledOptionProps = _ref7.getDisabledOptionProps,
            getDescriptionProps = _ref7.getDescriptionProps;
        return /*#__PURE__*/_react.default.createElement("span", getRootProps({
          className: classes
        }), _this5.renderInput({
          getInputProps: getInputProps,
          getTriggerProps: getTriggerProps
        }), /*#__PURE__*/_react.default.createElement("span", Object.assign({}, getDescriptionProps(), {
          className: styles.assistiveText
        }), assistiveText), /*#__PURE__*/_react.default.createElement(_Popover.Popover, {
          constrain: constrain,
          placement: placement,
          mountNode: mountNode,
          positionTarget: _this5._inputContainer,
          isShowingContent: isShowingOptions,
          shouldReturnFocus: false,
          withArrow: false
        }, _this5.renderList({
          getListProps: getListProps,
          getOptionProps: getOptionProps,
          getDisabledOptionProps: getDisabledOptionProps
        })));
      });
    }
  }, {
    key: "focused",
    get: function get() {
      return this._input && (0, _isActiveElement.isActiveElement)(this._input);
    }
  }, {
    key: "id",
    get: function get() {
      return this.props.id || this._defaultId;
    }
  }, {
    key: "width",
    get: function get() {
      return this._inputContainer && this._inputContainer.offsetWidth;
    }
  }, {
    key: "interaction",
    get: function get() {
      return (0, _getInteraction.getInteraction)({
        props: this.props
      });
    }
  }, {
    key: "highlightedOptionId",
    get: function get() {
      var highlightedOptionId = null;

      _react.Children.toArray(this.props.children).forEach(function (child) {
        if ((0, _matchComponentTypes.matchComponentTypes)(child, [_index.Group])) {
          // group found
          _react.Children.toArray(child.props.children).forEach(function (option) {
            // check options in group
            if (option.props.isHighlighted) {
              highlightedOptionId = option.props.id;
            }
          });
        } else {
          // ungrouped option found
          if (child.props.isHighlighted) {
            highlightedOptionId = child.props.id;
          }
        }
      });

      return highlightedOptionId;
    }
  }, {
    key: "selectedOptionId",
    get: function get() {
      var selectedOptionId = [];

      _react.Children.toArray(this.props.children).forEach(function (child) {
        if ((0, _matchComponentTypes.matchComponentTypes)(child, [_index.Group])) {
          // group found
          _react.Children.toArray(child.props.children).forEach(function (option) {
            // check options in group
            if (option.props.isSelected) {
              selectedOptionId.push(option.props.id);
            }
          });
        } else {
          // ungrouped option found
          if (child.props.isSelected) {
            selectedOptionId.push(child.props.id);
          }
        }
      });

      if (selectedOptionId.length === 1) return selectedOptionId[0];
      if (selectedOptionId.length === 0) return null;
      return selectedOptionId;
    }
  }]);
  Select.displayName = "Select";
  return Select;
}(_react.Component), _class2.Option = _index2.Option, _class2.Group = _index.Group, _class2.propTypes = {
  /**
   * The form field label.
   */
  renderLabel: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]).isRequired,

  /**
   * The value to display in the text input.
   */
  inputValue: _propTypes.default.string,

  /**
   * Whether or not to show the options list.
   */
  isShowingOptions: _propTypes.default.bool,

  /**
   * The id of the text input. One is generated if not supplied.
   */
  id: _propTypes.default.string,

  /**
   * The size of the text input.
   */
  size: _propTypes.default.oneOf(['small', 'medium', 'large']),

  /**
   * Additional helpful text to provide to screen readers about the operation
   * of the component.
   */
  assistiveText: _propTypes.default.string,

  /**
   * Html placeholder text to display when the input has no value. This should
   * be hint text, not a label replacement.
   */
  placeholder: _propTypes.default.string,

  /**
   * Specifies if interaction with the input is enabled, disabled, or readonly.
   * When "disabled", the input changes visibly to indicate that it cannot
   * receive user interactions. When "readonly" the input still cannot receive
   * user interactions but it keeps the same styles as if it were enabled.
   */
  interaction: _propTypes.default.oneOf(['enabled', 'disabled', 'readonly']),

  /**
   * Whether or not the text input is required.
   */
  isRequired: _propTypes.default.bool,

  /**
   * Whether the input is rendered inline with other elements or if it
   * is rendered as a block level element.
   */
  isInline: _propTypes.default.bool,

  /**
   * The width of the text input.
   */
  width: _propTypes.default.string,

  /**
   * The width of the text input, in characters, if a width is not explicitly
   * provided via the `width` prop. Only applicable if `isInline={true}`.
   */
  htmlSize: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),

  /**
   * The max width the options list can be before option text wraps. If not
   * set, the list will only display as wide as the text input.
   */
  optionsMaxWidth: _propTypes.default.string,

  /**
   * The number of options that should be visible before having to scroll.
   */
  visibleOptionsCount: _propTypes.default.number,

  /**
   * Displays messages and validation for the input. It should be an object
   * with the following shape:
   * `{
   *   text: PropTypes.string,
   *   type: PropTypes.oneOf(['error', 'hint', 'success', 'screenreader-only'])
   * }`
   */
  messages: _propTypes.default.arrayOf(_FormPropTypes.FormPropTypes.message),

  /**
   * The placement of the options list.
   */
  placement: _PositionPropTypes.PositionPropTypes.placement,

  /**
   * The parent in which to constrain the placement.
   */
  constrain: _PositionPropTypes.PositionPropTypes.constrain,

  /**
   * An element or a function returning an element to use mount the options
   * list to in the DOM (defaults to `document.body`)
   */
  mountNode: _PositionPropTypes.PositionPropTypes.mountNode,

  /**
   * Callback fired when text input receives focus.
   */
  onFocus: _propTypes.default.func,

  /**
   * Callback fired when text input loses focus.
   */
  onBlur: _propTypes.default.func,

  /**
   * Callback fired when text input value changes.
   */
  onInputChange: _propTypes.default.func,

  /**
   * Callback fired requesting that the options list be shown.
   */
  onRequestShowOptions: _propTypes.default.func,

  /**
   * Callback fired requesting that the options list be hidden.
   */
  onRequestHideOptions: _propTypes.default.func,

  /**
   * Callback fired requesting a particular option be highlighted.
   */
  onRequestHighlightOption: _propTypes.default.func,

  /**
   * Callback fired requesting a particular option be selected.
   */
  onRequestSelectOption: _propTypes.default.func,

  /**
   * A ref to the html `input` element.
   */
  inputRef: _propTypes.default.func,

  /**
   * A ref to the html `ul` element.
   */
  listRef: _propTypes.default.func,

  /**
   * Content to display before the text input. This will commonly be an icon or
   * tags to show multiple selections.
   */
  renderBeforeInput: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),

  /**
   * Content to display after the text input. This content will replace the
   * default arrow icons.
   */
  renderAfterInput: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),

  /**
   * Children of type `<Select.Option />` or `<Select.Group />`.
   */
  children: _Children.Children.oneOf([_index.Group, _index2.Option]),

  /**
   * Prevents the default behavior of wrapping the input and rendered content
   * when available space is exceeded.
   */
  shouldNotWrap: _propTypes.default.bool
}, _class2.defaultProps = {
  inputValue: '',
  isShowingOptions: false,
  id: void 0,
  size: 'medium',
  assistiveText: void 0,
  placeholder: null,
  // Leave interaction default undefined so that `disabled` and `readOnly` can also be supplied
  interaction: void 0,
  isRequired: false,
  isInline: false,
  width: void 0,
  htmlSize: void 0,
  optionsMaxWidth: void 0,
  visibleOptionsCount: 8,
  messages: void 0,
  placement: 'bottom stretch',
  constrain: 'window',
  mountNode: void 0,
  onFocus: function onFocus(event) {},
  onBlur: function onBlur(event) {},
  onInputChange: void 0,
  onRequestShowOptions: function onRequestShowOptions(event) {},
  onRequestHideOptions: function onRequestHideOptions(event) {},
  onRequestHighlightOption: function onRequestHighlightOption(event, data) {},
  onRequestSelectOption: function onRequestSelectOption(event, data) {},
  inputRef: function inputRef(node) {},
  listRef: function listRef(node) {},
  renderBeforeInput: null,
  renderAfterInput: null,
  children: null,
  shouldNotWrap: false
}, _temp)) || _class) || _class);
exports.Select = Select;
var _default = Select;
exports.default = _default;
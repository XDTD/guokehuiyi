import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";

var _dec, _dec2, _class, _class2, _temp;

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import React, { Children, Component } from 'react';
import PropTypes from 'prop-types';
import classnames from 'classnames';
import { Children as ChildrenPropTypes } from '@instructure/ui-prop-types';
import { FormPropTypes } from '@instructure/ui-form-field';
import { createChainedFunction } from '@instructure/ui-utils';
import { themeable } from '@instructure/ui-themeable';
import { testable } from '@instructure/ui-testable';
import { matchComponentTypes, omitProps, getInteraction } from '@instructure/ui-react-utils';
import { getBoundingClientRect, isActiveElement } from '@instructure/ui-dom-utils';
import { PositionPropTypes } from '@instructure/ui-position';
import { View } from '@instructure/ui-view';
import { Selectable } from '@instructure/ui-selectable';
import { Popover } from '@instructure/ui-popover';
import { TextInput } from '@instructure/ui-text-input';
import { Options } from '@instructure/ui-options';
import { IconArrowOpenDownLine, IconArrowOpenUpLine } from '@instructure/ui-icons';
import { uid } from '@instructure/uid';
import { Group } from "./Group/index.js";
import { Option } from "./Option/index.js";
var styles = {
  componentId: 'cCAhm',
  template: function template(theme) {
    return "\n\n.cCAhm_bGBk{color:".concat(theme.color || 'inherit', ";font-family:").concat(theme.fontFamily || 'inherit', ";font-size:").concat(theme.fontSize || 'inherit', ";font-weight:").concat(theme.fontWeight || 'inherit', "}\n\n.cCAhm_doqw .cCAhm_dnnz{font-size:").concat(theme.smallIconSize || 'inherit', "}\n\n.cCAhm_ycrn .cCAhm_dnnz{font-size:").concat(theme.mediumIconSize || 'inherit', "}\n\n.cCAhm_cMDj .cCAhm_dnnz{font-size:").concat(theme.largeIconSize || 'inherit', "}\n\n.cCAhm_dJgE{display:none}");
  },
  'root': 'cCAhm_bGBk',
  'small': 'cCAhm_doqw',
  'icon': 'cCAhm_dnnz',
  'medium': 'cCAhm_ycrn',
  'large': 'cCAhm_cMDj',
  'assistiveText': 'cCAhm_dJgE'
};
import theme from "./theme.js";
/**
---
category: components
tags: autocomplete, typeahead, combobox, dropdown, search, form
---
**/

var _ref3 = /*#__PURE__*/React.createElement(Options.Separator, null);

var _ref4 = /*#__PURE__*/React.createElement(Options.Separator, null);

var _ref5 = /*#__PURE__*/React.createElement(IconArrowOpenUpLine, {
  inline: false
});

var _ref6 = /*#__PURE__*/React.createElement(IconArrowOpenDownLine, {
  inline: false
});

var Select = (_dec = testable(), _dec2 = themeable(theme, styles), _dec(_class = _dec2(_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
  _inherits(Select, _Component);

  var _super = _createSuper(Select);

  function Select() {
    var _this;

    _classCallCheck(this, Select);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      hasInputRef: false
    };
    _this._defaultId = uid('Select');
    _this._assistId = uid('Select-assistiveText');
    _this._input = null;
    _this._inputContainer = null;
    _this._list = null;
    _this._optionIds = [];
    _this._optionHeight = 36;

    _this.handleInputRef = function (node) {
      // ensures list is positioned with respect to input if list is open on mount
      if (!_this.state.hasInputRef) {
        _this.setState({
          hasInputRef: true
        });
      }

      _this._input = node;

      _this.props.inputRef(node);
    };

    _this.handleListRef = function (node) {
      _this._list = node;

      _this.props.listRef(node); // store option height to calculate list maxHeight


      if (node && node.querySelector('[role="option"]')) {
        _this._optionHeight = node.querySelector('[role="option"]').offsetHeight;
      }
    };

    _this.handleInputContainerRef = function (node) {
      _this._inputContainer = node;
    };

    return _this;
  }

  _createClass(Select, [{
    key: "focus",
    value: function focus() {
      this._input && this._input.focus();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      // scroll option into view if needed
      this.scrollToOption(this.highlightedOptionId);
    }
  }, {
    key: "scrollToOption",
    value: function scrollToOption(id) {
      if (this._listView) {
        var option = this._listView.querySelector("[id=\"".concat(id, "\"]"));

        if (!option) return;
        var listItem = option.parentNode;
        var parentTop = getBoundingClientRect(this._listView).top;
        var elemTop = getBoundingClientRect(listItem).top;
        var parentBottom = parentTop + this._listView.clientHeight;
        var elemBottom = elemTop + listItem.clientHeight;

        if (elemBottom > parentBottom) {
          this._listView.scrollTop += elemBottom - parentBottom;
        } else if (elemTop < parentTop) {
          this._listView.scrollTop -= parentTop - elemTop;
        }
      }
    }
  }, {
    key: "highlightOption",
    value: function highlightOption(event, id) {
      var onRequestHighlightOption = this.props.onRequestHighlightOption;

      if (id) {
        onRequestHighlightOption(event, {
          id: id
        });
      }
    }
  }, {
    key: "getEventHandlers",
    value: function getEventHandlers() {
      var _this2 = this;

      var _this$props = this.props,
          isShowingOptions = _this$props.isShowingOptions,
          _onRequestShowOptions = _this$props.onRequestShowOptions,
          _onRequestHideOptions = _this$props.onRequestHideOptions,
          _onRequestSelectOption = _this$props.onRequestSelectOption;
      var highlightedOptionId = this.highlightedOptionId;
      var selectedOptionId = this.selectedOptionId;
      return this.interaction === 'enabled' ? {
        onRequestShowOptions: function onRequestShowOptions(event) {
          _onRequestShowOptions(event);

          if (selectedOptionId && !Array.isArray(selectedOptionId)) {
            // highlight selected option on show
            _this2.highlightOption(event, selectedOptionId);
          }
        },
        onRequestHideOptions: function onRequestHideOptions(event) {
          _onRequestHideOptions(event);
        },
        onRequestHighlightOption: function onRequestHighlightOption(event, _ref) {
          var id = _ref.id,
              direction = _ref.direction;
          if (!isShowingOptions) return; // if id exists, use that

          var highlightId = _this2._optionIds.indexOf(id) > -1 ? id : null;

          if (!highlightId) {
            if (!highlightedOptionId) {
              // nothing highlighted yet, highlight first option
              highlightId = _this2._optionIds[0];
            } else {
              // find next id based on direction
              var index = _this2._optionIds.indexOf(highlightedOptionId);

              highlightId = index > -1 ? _this2._optionIds[index + direction] : null;
            }
          }

          if (highlightId) {
            // only highlight if id exists as a valid option
            _this2.highlightOption(event, highlightId);
          }
        },
        onRequestHighlightFirstOption: function onRequestHighlightFirstOption(event) {
          _this2.highlightOption(event, _this2._optionIds[0]);
        },
        onRequestHighlightLastOption: function onRequestHighlightLastOption(event) {
          _this2.highlightOption(event, _this2._optionIds[_this2._optionIds.length - 1]);
        },
        onRequestSelectOption: function onRequestSelectOption(event, _ref2) {
          var id = _ref2.id;

          if (id && _this2._optionIds.indexOf(id) !== -1) {
            // only select if id exists as a valid option
            _onRequestSelectOption(event, {
              id: id
            });
          }
        }
      } : {};
    }
  }, {
    key: "renderOption",
    value: function renderOption(option, data) {
      var getOptionProps = data.getOptionProps,
          getDisabledOptionProps = data.getDisabledOptionProps;
      var _option$props = option.props,
          id = _option$props.id,
          isDisabled = _option$props.isDisabled,
          isHighlighted = _option$props.isHighlighted,
          isSelected = _option$props.isSelected,
          renderBeforeLabel = _option$props.renderBeforeLabel,
          renderAfterLabel = _option$props.renderAfterLabel,
          children = _option$props.children;

      var optionProps = _objectSpread({}, omitProps(option.props, _objectSpread({}, Option.propTypes, {}, Options.Item.propTypes)), {}, getOptionProps({
        id: id
      }), {
        // Options.Item props
        renderBeforeLabel: renderBeforeLabel,
        renderAfterLabel: renderAfterLabel
      }); // should option be treated as highlighted or selected


      if (isSelected) {
        optionProps.variant = 'selected';
      } else if (isHighlighted) {
        optionProps.variant = 'highlighted';
      } // should option be treated as disabled


      if (isDisabled) {
        optionProps.variant = 'disabled';
        optionProps = _objectSpread({}, optionProps, {}, getDisabledOptionProps());
      } else {
        // track as valid option if not disabled
        this._optionIds.push(id);
      }

      return /*#__PURE__*/React.createElement(Options.Item, optionProps, children);
    }
  }, {
    key: "renderGroup",
    value: function renderGroup(group, data) {
      var _this3 = this;

      var getOptionProps = data.getOptionProps,
          getDisabledOptionProps = data.getDisabledOptionProps,
          isFirstChild = data.isFirstChild,
          isLastChild = data.isLastChild,
          afterGroup = data.afterGroup;

      var _group$props = group.props,
          id = _group$props.id,
          renderLabel = _group$props.renderLabel,
          children = _group$props.children,
          rest = _objectWithoutProperties(_group$props, ["id", "renderLabel", "children"]);

      var groupChildren = []; // add a separator above

      if (!isFirstChild && !afterGroup) {
        groupChildren.push(_ref3);
      } // create a sublist as a group
      // a wrapping listitem will be created by Options


      groupChildren.push( /*#__PURE__*/React.createElement(Options, Object.assign({
        id: id,
        as: "ul",
        role: "group",
        renderLabel: renderLabel
      }, omitProps(rest, _objectSpread({}, Options.propTypes, {}, Group.propTypes))), Children.map(children, function (child) {
        return _this3.renderOption(child, {
          getOptionProps: getOptionProps,
          getDisabledOptionProps: getDisabledOptionProps
        });
      }))); // add a separator below

      if (!isLastChild) {
        groupChildren.push(_ref4);
      }

      return groupChildren;
    }
  }, {
    key: "renderList",
    value: function renderList(data) {
      var _this4 = this;

      var getListProps = data.getListProps,
          getOptionProps = data.getOptionProps,
          getDisabledOptionProps = data.getDisabledOptionProps;
      var _this$props2 = this.props,
          isShowingOptions = _this$props2.isShowingOptions,
          optionsMaxWidth = _this$props2.optionsMaxWidth,
          visibleOptionsCount = _this$props2.visibleOptionsCount,
          children = _this$props2.children;
      var lastWasGroup = false;
      var viewProps = isShowingOptions ? {
        display: 'block',
        overflowY: 'auto',
        maxHeight: this._optionHeight * visibleOptionsCount,
        maxWidth: optionsMaxWidth || this.width,
        background: 'primary',
        elementRef: function elementRef(node) {
          return _this4._listView = node;
        }
      } : {
        maxHeight: 0
      };
      return /*#__PURE__*/React.createElement(View, viewProps, /*#__PURE__*/React.createElement(Options, getListProps({
        as: 'ul',
        elementRef: this.handleListRef
      }), isShowingOptions ? Children.map(children, function (child, index) {
        if (!child || !matchComponentTypes(child, [Group, Option])) {
          return; // ignore invalid children
        }

        if (matchComponentTypes(child, [Option])) {
          lastWasGroup = false;
          return _this4.renderOption(child, {
            getOptionProps: getOptionProps,
            getDisabledOptionProps: getDisabledOptionProps
          });
        }

        if (matchComponentTypes(child, [Group])) {
          var afterGroup = lastWasGroup ? true : false;
          lastWasGroup = true;
          return _this4.renderGroup(child, {
            getOptionProps: getOptionProps,
            getDisabledOptionProps: getDisabledOptionProps,
            // for rendering separators appropriately
            isFirstChild: index === 0,
            isLastChild: index === Children.count(children) - 1,
            afterGroup: afterGroup
          });
        }
      }) : null));
    }
  }, {
    key: "renderIcon",
    value: function renderIcon() {
      return /*#__PURE__*/React.createElement("span", {
        className: styles.icon
      }, this.props.isShowingOptions ? _ref5 : _ref6);
    }
  }, {
    key: "renderInput",
    value: function renderInput(data) {
      var getInputProps = data.getInputProps,
          getTriggerProps = data.getTriggerProps;

      var _this$props3 = this.props,
          renderLabel = _this$props3.renderLabel,
          inputValue = _this$props3.inputValue,
          placeholder = _this$props3.placeholder,
          isRequired = _this$props3.isRequired,
          shouldNotWrap = _this$props3.shouldNotWrap,
          size = _this$props3.size,
          isInline = _this$props3.isInline,
          width = _this$props3.width,
          htmlSize = _this$props3.htmlSize,
          messages = _this$props3.messages,
          renderBeforeInput = _this$props3.renderBeforeInput,
          renderAfterInput = _this$props3.renderAfterInput,
          onFocus = _this$props3.onFocus,
          onBlur = _this$props3.onBlur,
          onInputChange = _this$props3.onInputChange,
          onRequestHideOptions = _this$props3.onRequestHideOptions,
          rest = _objectWithoutProperties(_this$props3, ["renderLabel", "inputValue", "placeholder", "isRequired", "shouldNotWrap", "size", "isInline", "width", "htmlSize", "messages", "renderBeforeInput", "renderAfterInput", "onFocus", "onBlur", "onInputChange", "onRequestHideOptions"]);

      var interaction = this.interaction;
      var passthroughProps = omitProps(rest, Select.propTypes);

      var _getTriggerProps = getTriggerProps(_objectSpread({}, passthroughProps)),
          ref = _getTriggerProps.ref,
          triggerProps = _objectWithoutProperties(_getTriggerProps, ["ref"]);

      var isEditable = typeof onInputChange !== 'undefined'; // props to ensure screen readers treat uneditable selects as accessible
      // popup buttons rather than comboboxes.

      var overrideProps = !isEditable ? {
        role: 'button',
        title: inputValue,
        'aria-autocomplete': null
      } : {}; // backdoor to autocomplete attr to work around chrome autofill issues

      if (passthroughProps['autoComplete']) {
        overrideProps.autoComplete = passthroughProps['autoComplete'];
      }

      return /*#__PURE__*/React.createElement(TextInput, Object.assign({}, triggerProps, getInputProps(_objectSpread({
        id: this.id,
        renderLabel: renderLabel,
        placeholder: placeholder,
        size: size,
        width: width,
        htmlSize: htmlSize,
        messages: messages,
        value: inputValue,
        inputRef: createChainedFunction(ref, this.handleInputRef),
        inputContainerRef: this.handleInputContainerRef,
        interaction: interaction === 'enabled' && !isEditable ? 'readonly' // prevent keyboard cursor
        : interaction,
        isRequired: isRequired,
        shouldNotWrap: shouldNotWrap,
        display: isInline ? 'inline-block' : 'block',
        renderBeforeInput: renderBeforeInput,
        renderAfterInput: renderAfterInput || this.renderIcon(),
        onChange: onInputChange,
        onFocus: onFocus,
        onBlur: createChainedFunction(onBlur, onRequestHideOptions)
      }, overrideProps))));
    }
  }, {
    key: "render",
    value: function render() {
      var _this5 = this;

      var _this$props4 = this.props,
          size = _this$props4.size,
          constrain = _this$props4.constrain,
          placement = _this$props4.placement,
          mountNode = _this$props4.mountNode,
          assistiveText = _this$props4.assistiveText,
          isShowingOptions = _this$props4.isShowingOptions; // clear temporary option store

      this._optionIds = [];
      var highlightedOptionId = this.highlightedOptionId;
      var selectedOptionId = this.selectedOptionId;
      var classes = classnames(styles.root, _defineProperty({}, styles[size], size));
      return /*#__PURE__*/React.createElement(Selectable, Object.assign({
        highlightedOptionId: highlightedOptionId,
        isShowingOptions: isShowingOptions,
        selectedOptionId: selectedOptionId ? selectedOptionId : null
      }, this.getEventHandlers()), function (_ref7) {
        var getRootProps = _ref7.getRootProps,
            getInputProps = _ref7.getInputProps,
            getTriggerProps = _ref7.getTriggerProps,
            getListProps = _ref7.getListProps,
            getOptionProps = _ref7.getOptionProps,
            getDisabledOptionProps = _ref7.getDisabledOptionProps,
            getDescriptionProps = _ref7.getDescriptionProps;
        return /*#__PURE__*/React.createElement("span", getRootProps({
          className: classes
        }), _this5.renderInput({
          getInputProps: getInputProps,
          getTriggerProps: getTriggerProps
        }), /*#__PURE__*/React.createElement("span", Object.assign({}, getDescriptionProps(), {
          className: styles.assistiveText
        }), assistiveText), /*#__PURE__*/React.createElement(Popover, {
          constrain: constrain,
          placement: placement,
          mountNode: mountNode,
          positionTarget: _this5._inputContainer,
          isShowingContent: isShowingOptions,
          shouldReturnFocus: false,
          withArrow: false
        }, _this5.renderList({
          getListProps: getListProps,
          getOptionProps: getOptionProps,
          getDisabledOptionProps: getDisabledOptionProps
        })));
      });
    }
  }, {
    key: "focused",
    get: function get() {
      return this._input && isActiveElement(this._input);
    }
  }, {
    key: "id",
    get: function get() {
      return this.props.id || this._defaultId;
    }
  }, {
    key: "width",
    get: function get() {
      return this._inputContainer && this._inputContainer.offsetWidth;
    }
  }, {
    key: "interaction",
    get: function get() {
      return getInteraction({
        props: this.props
      });
    }
  }, {
    key: "highlightedOptionId",
    get: function get() {
      var highlightedOptionId = null;
      Children.toArray(this.props.children).forEach(function (child) {
        if (matchComponentTypes(child, [Group])) {
          // group found
          Children.toArray(child.props.children).forEach(function (option) {
            // check options in group
            if (option.props.isHighlighted) {
              highlightedOptionId = option.props.id;
            }
          });
        } else {
          // ungrouped option found
          if (child.props.isHighlighted) {
            highlightedOptionId = child.props.id;
          }
        }
      });
      return highlightedOptionId;
    }
  }, {
    key: "selectedOptionId",
    get: function get() {
      var selectedOptionId = [];
      Children.toArray(this.props.children).forEach(function (child) {
        if (matchComponentTypes(child, [Group])) {
          // group found
          Children.toArray(child.props.children).forEach(function (option) {
            // check options in group
            if (option.props.isSelected) {
              selectedOptionId.push(option.props.id);
            }
          });
        } else {
          // ungrouped option found
          if (child.props.isSelected) {
            selectedOptionId.push(child.props.id);
          }
        }
      });
      if (selectedOptionId.length === 1) return selectedOptionId[0];
      if (selectedOptionId.length === 0) return null;
      return selectedOptionId;
    }
  }]);

  Select.displayName = "Select";
  return Select;
}(Component), _class2.Option = Option, _class2.Group = Group, _class2.propTypes = {
  /**
   * The form field label.
   */
  renderLabel: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,

  /**
   * The value to display in the text input.
   */
  inputValue: PropTypes.string,

  /**
   * Whether or not to show the options list.
   */
  isShowingOptions: PropTypes.bool,

  /**
   * The id of the text input. One is generated if not supplied.
   */
  id: PropTypes.string,

  /**
   * The size of the text input.
   */
  size: PropTypes.oneOf(['small', 'medium', 'large']),

  /**
   * Additional helpful text to provide to screen readers about the operation
   * of the component.
   */
  assistiveText: PropTypes.string,

  /**
   * Html placeholder text to display when the input has no value. This should
   * be hint text, not a label replacement.
   */
  placeholder: PropTypes.string,

  /**
   * Specifies if interaction with the input is enabled, disabled, or readonly.
   * When "disabled", the input changes visibly to indicate that it cannot
   * receive user interactions. When "readonly" the input still cannot receive
   * user interactions but it keeps the same styles as if it were enabled.
   */
  interaction: PropTypes.oneOf(['enabled', 'disabled', 'readonly']),

  /**
   * Whether or not the text input is required.
   */
  isRequired: PropTypes.bool,

  /**
   * Whether the input is rendered inline with other elements or if it
   * is rendered as a block level element.
   */
  isInline: PropTypes.bool,

  /**
   * The width of the text input.
   */
  width: PropTypes.string,

  /**
   * The width of the text input, in characters, if a width is not explicitly
   * provided via the `width` prop. Only applicable if `isInline={true}`.
   */
  htmlSize: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
   * The max width the options list can be before option text wraps. If not
   * set, the list will only display as wide as the text input.
   */
  optionsMaxWidth: PropTypes.string,

  /**
   * The number of options that should be visible before having to scroll.
   */
  visibleOptionsCount: PropTypes.number,

  /**
   * Displays messages and validation for the input. It should be an object
   * with the following shape:
   * `{
   *   text: PropTypes.string,
   *   type: PropTypes.oneOf(['error', 'hint', 'success', 'screenreader-only'])
   * }`
   */
  messages: PropTypes.arrayOf(FormPropTypes.message),

  /**
   * The placement of the options list.
   */
  placement: PositionPropTypes.placement,

  /**
   * The parent in which to constrain the placement.
   */
  constrain: PositionPropTypes.constrain,

  /**
   * An element or a function returning an element to use mount the options
   * list to in the DOM (defaults to `document.body`)
   */
  mountNode: PositionPropTypes.mountNode,

  /**
   * Callback fired when text input receives focus.
   */
  onFocus: PropTypes.func,

  /**
   * Callback fired when text input loses focus.
   */
  onBlur: PropTypes.func,

  /**
   * Callback fired when text input value changes.
   */
  onInputChange: PropTypes.func,

  /**
   * Callback fired requesting that the options list be shown.
   */
  onRequestShowOptions: PropTypes.func,

  /**
   * Callback fired requesting that the options list be hidden.
   */
  onRequestHideOptions: PropTypes.func,

  /**
   * Callback fired requesting a particular option be highlighted.
   */
  onRequestHighlightOption: PropTypes.func,

  /**
   * Callback fired requesting a particular option be selected.
   */
  onRequestSelectOption: PropTypes.func,

  /**
   * A ref to the html `input` element.
   */
  inputRef: PropTypes.func,

  /**
   * A ref to the html `ul` element.
   */
  listRef: PropTypes.func,

  /**
   * Content to display before the text input. This will commonly be an icon or
   * tags to show multiple selections.
   */
  renderBeforeInput: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

  /**
   * Content to display after the text input. This content will replace the
   * default arrow icons.
   */
  renderAfterInput: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

  /**
   * Children of type `<Select.Option />` or `<Select.Group />`.
   */
  children: ChildrenPropTypes.oneOf([Group, Option]),

  /**
   * Prevents the default behavior of wrapping the input and rendered content
   * when available space is exceeded.
   */
  shouldNotWrap: PropTypes.bool
}, _class2.defaultProps = {
  inputValue: '',
  isShowingOptions: false,
  id: void 0,
  size: 'medium',
  assistiveText: void 0,
  placeholder: null,
  // Leave interaction default undefined so that `disabled` and `readOnly` can also be supplied
  interaction: void 0,
  isRequired: false,
  isInline: false,
  width: void 0,
  htmlSize: void 0,
  optionsMaxWidth: void 0,
  visibleOptionsCount: 8,
  messages: void 0,
  placement: 'bottom stretch',
  constrain: 'window',
  mountNode: void 0,
  onFocus: function onFocus(event) {},
  onBlur: function onBlur(event) {},
  onInputChange: void 0,
  onRequestShowOptions: function onRequestShowOptions(event) {},
  onRequestHideOptions: function onRequestHideOptions(event) {},
  onRequestHighlightOption: function onRequestHighlightOption(event, data) {},
  onRequestSelectOption: function onRequestSelectOption(event, data) {},
  inputRef: function inputRef(node) {},
  listRef: function listRef(node) {},
  renderBeforeInput: null,
  renderAfterInput: null,
  children: null,
  shouldNotWrap: false
}, _temp)) || _class) || _class);
export default Select;
export { Select };
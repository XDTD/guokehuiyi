import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";

var _dec, _dec2, _class, _class2, _temp;

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import keycode from 'keycode';
import { IconFolderLine, IconDocumentLine } from '@instructure/ui-icons';
import { themeable } from '@instructure/ui-themeable';
import { pickProps } from '@instructure/ui-react-utils';
import { controllable } from '@instructure/ui-prop-types';
import { testable } from '@instructure/ui-testable';
import { TreeCollection } from "./TreeCollection/index.js";
import { TreeNode } from "./TreeNode/index.js";
var styles = {
  componentId: 'DBzxS',
  template: function template(theme) {
    return "\n\n.DBzxS_cBsQ{margin-top:".concat(theme.controlsTopMargin || 'inherit', "}\n\n.DBzxS_cpmC{list-style-type:none;margin:0;outline:none;padding:0;position:relative}\n\n.DBzxS_cpmC,.DBzxS_cpmC:before{box-sizing:border-box}\n\n.DBzxS_cpmC:before{border:").concat(theme.focusOutlineWidth || 'inherit', " ").concat(theme.focusOutlineStyle || 'inherit', " ").concat(theme.focusOutlineColor || 'inherit', ";border-radius:calc(").concat(theme.borderRadius || 'inherit', "*1.5);bottom:-0.25rem;content:\"\";display:block;left:-0.25rem;opacity:0;pointer-events:none;position:absolute;right:-0.25rem;top:-0.25rem;transform:scale(0.95);transition:all 0.2s}\n\n.DBzxS_cpmC:focus:before{opacity:1;transform:scale(1)}");
  },
  'controls': 'DBzxS_cBsQ',
  'list': 'DBzxS_cpmC'
};
import theme from "./theme.js";
/**
---
category: components
---
**/

var TreeBrowser = (_dec = testable(), _dec2 = themeable(theme, styles), _dec(_class = _dec2(_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
  _inherits(TreeBrowser, _Component);

  var _super = _createSuper(TreeBrowser);

  function TreeBrowser(props) {
    var _this;

    _classCallCheck(this, TreeBrowser);

    _this = _super.call(this, props);

    _this.handleCollectionClick = function (e, collection) {
      var expand = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      e.stopPropagation();
      var onCollectionClick = _this.props.onCollectionClick;
      if (expand) _this.expandOrCollapseNode(collection);
      onCollectionClick(collection.id, collection); // TODO: this should pass the event as the first arg

      _this.handleSelection(collection.id, 'collection');
    };

    _this.handleItemClick = function (e, item) {
      e.stopPropagation();
      var onItemClick = _this.props.onItemClick;
      onItemClick(item);

      _this.handleSelection(item.id, 'item'); // TODO: this should pass the event as the first arg

    };

    _this.handleKeyDown = function (event, node) {
      event.stopPropagation();

      switch (event.keyCode) {
        case keycode.codes.down:
        case keycode.codes.j:
          _this.moveFocus(1);

          break;

        case keycode.codes.up:
        case keycode.codes.k:
          _this.moveFocus(-1);

          break;

        case keycode.codes.home:
        case keycode.codes.end:
          _this.homeOrEnd(event.keyCode);

          break;

        case keycode.codes.left:
        case keycode.codes.right:
          _this.handleLeftOrRightArrow(event.keyCode, node);

          break;

        case keycode.codes.enter:
        case keycode.codes.space:
          _this.handleActivation(event, node);

          break;

        default:
          return;
      }

      event.preventDefault();
    };

    _this.getIsFlattened = function (collection) {
      var _this$props = _this.props,
          rootId = _this$props.rootId,
          showRootCollection = _this$props.showRootCollection;
      return !showRootCollection && typeof rootId !== 'undefined' && collection.id === rootId;
    };

    _this.state = {
      selection: ''
    };

    if (typeof _this.props.expanded === 'undefined') {
      _this.state.expanded = props.defaultExpanded;
    }

    return _this;
  }

  _createClass(TreeBrowser, [{
    key: "getExpanded",
    value: function getExpanded(state, props) {
      return typeof props.expanded === 'undefined' ? state.expanded : props.expanded;
    }
  }, {
    key: "expandOrCollapseNode",
    value: function expandOrCollapseNode(collection) {
      var _this2 = this;

      this.props.onCollectionToggle(collection);

      if (typeof this.props.expanded === 'undefined') {
        this.setState(function (state, props) {
          var expanded = [].concat(_this2.getExpanded(state, props));

          var expandedIndex = _this2.getExpandedIndex(expanded, collection.id);

          if (collection.expanded && expandedIndex < 0) {
            expanded.push(collection.id);
          } else if (expandedIndex >= 0) {
            expanded.splice(expandedIndex, 1);
          }

          return {
            expanded: expanded
          };
        });
      }
    }
  }, {
    key: "handleSelection",
    value: function handleSelection(id, type) {
      var selectionType = this.props.selectionType;
      selectionType === 'single' && this.setState(function (state) {
        var selection = "".concat(type, "_").concat(id);

        if (state.selection !== selection) {
          return {
            selection: selection
          };
        } else {
          return state;
        }
      });
    }
  }, {
    key: "getNavigableNodes",
    value: function getNavigableNodes() {
      return Array.from(this._root.querySelectorAll('[role="treeitem"]'));
    }
  }, {
    key: "moveFocus",
    value: function moveFocus(delta) {
      var nodes = this.getNavigableNodes();
      var closest = window.document.activeElement.closest('[role="treeitem"]');
      var active = nodes.indexOf(closest);
      var next = active + delta;

      if (next < 0) {
        next = 0;
      } else if (next >= nodes.length) {
        next = nodes.length - 1;
      }

      nodes.forEach(function (n) {
        n.setAttribute('tabindex', '-1');
      });
      nodes[next].setAttribute('tabindex', '0');
      nodes[next].focus();
    }
  }, {
    key: "homeOrEnd",
    value: function homeOrEnd(keyCode) {
      var length = this.getNavigableNodes().length;

      if (keyCode === keycode.codes.home) {
        this.moveFocus(1 - length);
      } else {
        this.moveFocus(length - 1);
      }
    }
  }, {
    key: "handleLeftOrRightArrow",
    value: function handleLeftOrRightArrow(keyCode, node) {
      var ltr = !(this._root.parentElement.dir === 'rtl' || document.dir === 'rtl');

      if (ltr && keyCode === keycode.codes.left || !ltr && keyCode == keycode.codes.right) {
        this.handleCloseOrPrevious(node);
      } else {
        this.handleOpenOrNext(node);
      }
    }
  }, {
    key: "handleOpenOrNext",
    value: function handleOpenOrNext(node) {
      if (node && !this.expanded.includes(node.id) && node.type === 'collection') {
        this.expandOrCollapseNode(node);
      } else {
        this.moveFocus(1);
      }
    }
  }, {
    key: "handleCloseOrPrevious",
    value: function handleCloseOrPrevious(node) {
      if (node && this.expanded.includes(node.id) && node.type === 'collection') {
        this.expandOrCollapseNode(node);
      } else {
        this.moveFocus(-1);
      }
    }
  }, {
    key: "handleActivation",
    value: function handleActivation(event, node) {
      if (node == null) return;

      if (node.type === 'collection') {
        this.handleCollectionClick(event, node, this.props.selectionType === 'none');
      } else {
        this.handleItemClick(event, node);
      }
    }
  }, {
    key: "getSubCollections",
    value: function getSubCollections(collection) {
      var _this3 = this;

      var collections = [].concat(collection.collections || []);
      return collections.map(function (id) {
        return _this3.getCollectionProps(_this3.props.collections[id]);
      }).filter(function (collection) {
        return collection != null;
      });
    }
  }, {
    key: "getItems",
    value: function getItems(collection) {
      var _this4 = this;

      if (collection.items) {
        var items = [].concat(collection.items);
        return items.map(function (id) {
          return _objectSpread({}, _this4.props.items[id]);
        }).filter(function (item) {
          return item != null;
        });
      } else {
        return [];
      }
    }
  }, {
    key: "getCollectionProps",
    value: function getCollectionProps(collection) {
      return {
        id: collection.id,
        name: collection.name,
        descriptor: collection.descriptor,
        expanded: this.getExpandedIndex(this.expanded, collection.id) >= 0,
        items: this.getItems(collection),
        collections: this.getSubCollections(collection),
        renderBeforeItems: collection.renderBeforeItems,
        renderAfterItems: collection.renderAfterItems,
        containerRef: collection.containerRef,
        isCollectionFlattened: this.getIsFlattened(collection)
      };
    }
  }, {
    key: "getExpandedIndex",
    value: function getExpandedIndex(expanded, id) {
      return expanded.findIndex(function (expanded) {
        return String(expanded) === String(id);
      });
    }
  }, {
    key: "renderRoot",
    value: function renderRoot() {
      var _this5 = this;

      return this.collections.map(function (collection, i) {
        return /*#__PURE__*/React.createElement(TreeCollection, Object.assign({
          key: i
        }, pickProps(_this5.props, TreeCollection.propTypes), _this5.getCollectionProps(collection), {
          selection: _this5.state.selection,
          onItemClick: _this5.handleItemClick,
          onCollectionClick: _this5.handleCollectionClick,
          onKeyDown: _this5.handleKeyDown,
          numChildren: _this5.collections.length,
          level: 1,
          position: 1
        }));
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this6 = this;

      return /*#__PURE__*/React.createElement("ul", {
        className: styles.list,
        tabIndex: 0,
        role: "tree",
        onKeyDown: this.handleKeyDown,
        ref: function ref(el) {
          _this6._root = el;
        },
        "aria-label": this.props.treeLabel
      }, this.renderRoot());
    }
  }, {
    key: "collections",
    get: function get() {
      var _this$props2 = this.props,
          collections = _this$props2.collections,
          rootId = _this$props2.rootId;

      if (typeof rootId !== 'undefined') {
        return [collections[rootId]];
      } else {
        return Object.keys(collections).map(function (id) {
          return collections[id];
        }).filter(function (collection) {
          return collection != null;
        });
      }
    }
  }, {
    key: "expanded",
    get: function get() {
      return this.getExpanded(this.state, this.props);
    }
  }]);

  TreeBrowser.displayName = "TreeBrowser";
  return TreeBrowser;
}(Component), _class2.propTypes = {
  /**
   * a normalized hash of collections, keyed by id, that contain an
   * :id, :name, :items (an array of item ids), :collections (an array of
   * collection ids), optional :descriptor text, optional :containerRef function,
   * an optional :renderBeforeItems TreeNode, and an optional :renderAfterItems TreeNode.
   * Each collection must have a unique id.
   */
  collections: PropTypes.object.isRequired,

  /**
   * a hash of items, keyed by id, that contain an :id, :name,
   * optional :descriptor text, and optional :thumbnail url
   */
  items: PropTypes.object.isRequired,

  /**
   * specifies the id of the root level collection, if present.
   * if no root is specified, all collections will be rendered
   * at the top level
   **/
  rootId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
   * an array of expanded collection ids, must be accompanied by an 'onCollectionToggle' prop
   */
  expanded: controllable(PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])), 'onCollectionToggle'),

  /**
   * an array of collection ids to expand by default
   */
  defaultExpanded: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])),
  // There are 2 types of tree selection:  single and multi.
  // This is set up to allow for "multi" in the future without having to deprecate the old API.
  selectionType: PropTypes.oneOf(['none', 'single']),
  size: PropTypes.oneOf(['small', 'medium', 'large']),
  variant: PropTypes.oneOf(['folderTree', 'indent']),
  collectionIcon: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
  collectionIconExpanded: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
  itemIcon: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

  /**
   * A function called with each item's props as an argument. The return value of this function is a
   * props object which will be passed to the item when it is rendered. This is useful for situations where
   * you need to render the item differently depending on it's props. For example, if you would like to
   * display a different icon for items with a certain name.
   */
  getItemProps: PropTypes.func,

  /**
   * whether or not to show the root collection specified in rootId prop or
   * to begin with its immediate subcollections and items instead
   */
  showRootCollection: PropTypes.bool,
  onCollectionClick: PropTypes.func,
  onCollectionToggle: PropTypes.func,
  onItemClick: PropTypes.func,

  /**
   * An optional label to assist visually impaired users
   */
  treeLabel: PropTypes.string
}, _class2.defaultProps = {
  size: 'medium',
  variant: 'folderTree',
  showRootCollection: true,
  collectionIcon: IconFolderLine,
  collectionIconExpanded: IconFolderLine,
  itemIcon: IconDocumentLine,
  getItemProps: function getItemProps(props) {
    return props;
  },
  defaultExpanded: [],
  selectionType: 'none',
  onItemClick: function onItemClick(item) {},
  onCollectionClick: function onCollectionClick(id, collection) {},
  onCollectionToggle: function onCollectionToggle(collection) {},
  rootId: void 0,
  expanded: void 0,
  treeLabel: void 0
}, _class2.Node = TreeNode, _temp)) || _class) || _class);
export default TreeBrowser;
export { TreeBrowser };
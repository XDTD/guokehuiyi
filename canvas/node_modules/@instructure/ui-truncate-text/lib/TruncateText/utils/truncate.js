"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _console = require("@instructure/console");

var _escapeHtml = _interopRequireDefault(require("escape-html"));

var _cloneArray = require("@instructure/ui-utils/lib/cloneArray.js");

var _getComputedStyle = require("@instructure/ui-dom-utils/lib/getComputedStyle.js");

var _getBoundingClientRect = require("@instructure/ui-dom-utils/lib/getBoundingClientRect.js");

var _isVisible = require("@instructure/ui-dom-utils/lib/isVisible.js");

var _measureText = _interopRequireDefault(require("./measureText.js"));

var _cleanString = _interopRequireDefault(require("./cleanString.js"));

var _cleanData = _interopRequireDefault(require("./cleanData.js"));

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * ---
 * parent: TruncateText
 * private: true
 * ---
 * Truncate the text content of an HTML element and its children.
 *
 * @param {DOMNode} element A single element containing the content to be truncated.
 * @param {Object} options={} The options object.
 * @param {DOMNode} options.parent An optional parent element to use for calculations.
 * @param {number|string} options.maxLines Number of lines to allow before truncating.
 * @param {string} options.position=end Where to place the ellipsis within the string.
 * @param {string} options.truncate=character Add ellipsis after words or after any character.
 * @param {string} options.ellipsis=\u2026 Where to place the ellipsis within the string.
 * @param {string[]} options.ignore Characters to ignore at truncated end of string.
 * @param {number} options.lineHeight=1.2 Unitless multiplier to use in case element can have
 * 'normal' lineHeight. Adjust this to better match your font if needed.
 */
function truncate(element, options) {
  var truncator = new Truncator(element, options);

  if (truncator) {
    return truncator.truncate();
  }
}

var Truncator = /*#__PURE__*/function () {
  function Truncator(element) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Truncator);
    this._options = {
      parent: options.parent || element.parentElement,
      maxLines: options.maxLines || 1,
      position: options.position || 'end',
      truncate: options.truncate || 'character',
      ellipsis: options.ellipsis || "\u2026",
      ignore: options.ignore || [' ', '.', ','],
      lineHeight: options.lineHeight || 1.2,
      shouldTruncateWhenInvisible: options.shouldTruncateWhenInvisible
    };

    if (!element) {
      /*#__PURE__*/
      ( /*#__PURE__*/0, _console.error)(false, '[Truncator] No element to truncate.');
      return;
    }

    this._stage = element;

    if (options.parent) {
      this._parent = this._options.parent;
    } else {
      this._parent = this._options.maxLines === 'auto' ? this._stage.parentElement : this._stage;
    }

    this._truncatedText = this._parent.textContent;
    this._isTruncated = false;
    this.setup();
  }

  (0, _createClass2.default)(Truncator, [{
    key: "setup",
    value: function setup() {
      if (!this._stage) {
        return;
      }

      var _this$_options = this._options,
          maxLines = _this$_options.maxLines,
          truncate = _this$_options.truncate,
          lineHeight = _this$_options.lineHeight;
      var style = (0, _getComputedStyle.getComputedStyle)(this._parent); // if no explicit lineHeight is inherited, use lineHeight multiplier for calculations

      var actualLineHeight = style.lineHeight === 'normal' ? lineHeight * parseFloat(style.fontSize) : parseFloat(style.lineHeight);
      var node = this._stage.firstChild.children ? this._stage.firstChild : this._stage;
      var nodeDataIndexes = [];
      var stringData = [];
      this._nodeMap = this.getNodeMap(node);

      for (var i = 0; i < this._nodeMap.length; i++) {
        var item = this._nodeMap[i];

        if (truncate === 'word' && item.data[item.data.length - 1] === ' ') {
          // remove random whitespace data between nodes
          item.data.length -= 1;
        }

        stringData[i] = item.data;

        for (var j = 0; j < item.data.length; j++) {
          // map each word or character datum index to its corresponding node
          nodeDataIndexes.push(i);
        }
      }

      this._defaultStringData = (0, _cloneArray.cloneArray)(stringData);
      this._nodeDataIndexes = (0, _cloneArray.cloneArray)(nodeDataIndexes);
      this._maxHeight = maxLines === 'auto' ? (0, _getBoundingClientRect.getBoundingClientRect)(this._parent).height : maxLines * actualLineHeight;
      this._maxWidth = (0, _measureText.default)(this._nodeMap.map(function (item) {
        return item.node;
      }), this._parent);
      this._maxLines = maxLines === 'auto' ? Math.round(this._maxHeight / actualLineHeight) : maxLines;
    }
  }, {
    key: "getNodeMap",
    value: function getNodeMap(rootNode) {
      var _this$_options2 = this._options,
          shouldTruncateWhenInvisible = _this$_options2.shouldTruncateWhenInvisible,
          truncate = _this$_options2.truncate;
      var nodes = Array.from(rootNode.childNodes);
      var map = []; // parse child nodes and build a data map to associate each node with its data

      nodes.forEach(function (node) {
        if (node.nodeType === 1 || node.nodeType === 3) {
          var shouldTruncate = shouldTruncateWhenInvisible ? true : (0, _isVisible.isVisible)(node, false);
          var textContent = node.textContent + ' ';
          map.push({
            node: node,
            data: truncate === 'word' ? shouldTruncate ? // eslint-disable-next-line no-useless-escape
            textContent.match(/.*?[\.\s\/]+?/g) : '' : shouldTruncate ? node.textContent.split('') : []
          });
        }
      });
      return map;
    }
  }, {
    key: "getNodeIndexes",
    value: function getNodeIndexes(data) {
      var nodeDataIndexes = [];

      for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
          nodeDataIndexes.push([i, j]);
        }
      }

      return nodeDataIndexes;
    }
  }, {
    key: "domString",
    value: function domString(data) {
      var keys = Object.keys(data);
      var html = '';

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var mapItem = this._nodeMap[key];
        var text = data[key].join('');
        var safeText = (0, _escapeHtml.default)(text);

        if (mapItem.node.nodeType === 1) {
          var name = mapItem.node.nodeName;
          var attr = mapItem.node.attributes;
          var attributes = '';

          for (var j = 0; j < attr.length; j++) {
            var att = attr[j];
            attributes += " ".concat(att.nodeName, "=\"").concat(att.nodeValue, "\"");
          }

          html += "<".concat(name).concat(attributes, ">").concat(safeText, "</").concat(name, ">");
        } else if (mapItem.node.nodeType === 3) {
          html += safeText;
        }
      }

      return html;
    }
  }, {
    key: "checkFit",
    value: function checkFit(data) {
      var html = this.domString(data);
      var node = this._options.maxLines === 'auto' ? this._stage : this._parent;
      var fits = true;
      this._stage.innerHTML = html; // allow a 0.5 px margin of error for browser calculation discrepancies

      if ((0, _getBoundingClientRect.getBoundingClientRect)(node).height - this._maxHeight > 0.5) {
        fits = false;
      }

      return fits;
    }
  }, {
    key: "truncate",
    value: function truncate() {
      var _this$_options3 = this._options,
          ellipsis = _this$_options3.ellipsis,
          ignore = _this$_options3.ignore,
          position = _this$_options3.position;
      var middle = position === 'middle';
      var truncated = false;
      var fits = false;
      var nodeIndex = 0;
      var dataIndex = 0;
      var truncatedText = '';
      var stringData = null;
      var remove = null;

      if (!this._stage) {
        return;
      }

      stringData = (0, _cloneArray.cloneArray)(this._defaultStringData);
      dataIndex = middle ? 0 : this._nodeDataIndexes.length - 1;

      while (!fits) {
        if (dataIndex < 0) {
          break;
        }

        if (middle) {
          // as data is removed from the middle of our set, the node order could
          // change each iteration, so we need to keep updating a node index matrix
          // based on the current string data
          var matrix = this.getNodeIndexes(stringData);
          var center = Math.floor(matrix.length / 2); // the node index and word index to remove

          remove = matrix[center];

          if (dataIndex > 0) {
            // remove word/character currently in the center
            stringData[remove[0]].splice(remove[1], 1, ellipsis);
          }
        } else {
          nodeIndex = this._nodeDataIndexes[dataIndex];

          if (dataIndex < this._nodeDataIndexes.length - 1) {
            stringData[nodeIndex] = stringData[nodeIndex].slice(0, -1);
            stringData[nodeIndex].push(ellipsis);
          }
        } // test new data


        fits = this.checkFit(stringData);

        if (fits) {
          for (var i = 0; i < stringData.length; i++) {
            var data = stringData[i];
            truncatedText += data.join('');
          }

          break;
        } else {
          truncated = true;

          if (middle) {
            // remove ellipsis before re-testing
            stringData[remove[0]].splice(remove[1], 1);
            dataIndex++;
          } else {
            stringData[nodeIndex] = stringData[nodeIndex].slice(0, -1);
            dataIndex--;
          }
        }
      }

      stringData = (0, _cleanData.default)(stringData, this._options, true);

      if (truncated && !middle) {
        truncatedText = (0, _cleanString.default)(truncatedText.split(ellipsis)[0], ignore, false, true, true);
        truncatedText += ellipsis;
      } else if (truncated && middle) {
        var halves = truncatedText.split(ellipsis);
        truncatedText = (0, _cleanString.default)(halves[0], ignore, false, true, true) + ellipsis + (0, _cleanString.default)(halves[1], ignore, true, false, true);
      }

      return {
        isTruncated: truncated,
        text: truncatedText,
        data: stringData,
        constraints: {
          width: this._maxWidth,
          height: this._maxHeight,
          lines: this._maxLines
        }
      };
    }
  }]);
  return Truncator;
}();

var _default = truncate;
exports.default = _default;
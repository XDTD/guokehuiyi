import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _createSuper from "@babel/runtime/helpers/esm/createSuper";

var _dec, _dec2, _class, _class2, _temp;

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { View } from '@instructure/ui-view';
import { themeable, ThemeablePropTypes } from '@instructure/ui-themeable';
import { testable } from '@instructure/ui-testable';
import { omitProps } from '@instructure/ui-react-utils';
import { uid } from '@instructure/uid';
import { Children } from '@instructure/ui-prop-types';
import { hasVisibleChildren } from '@instructure/ui-a11y-utils';
import { findTabbable, getActiveElement } from '@instructure/ui-dom-utils';
import { PaginationButton } from "./PaginationButton/index.js";
import { PaginationArrowButton } from "./PaginationArrowButton/index.js";
import theme from "./theme.js";
var styles = {
  componentId: 'dRtXI',
  template: function template(theme) {
    return "\n\n.dRtXI_bGBk,[dir=ltr] .dRtXI_bGBk,[dir=rtl] .dRtXI_bGBk{text-align:center}\n\n.dRtXI_dcvv{align-items:center;display:inline-flex}";
  },
  'root': 'dRtXI_bGBk',
  'pages': 'dRtXI_dcvv'
};
/** This is an [].findIndex optimized to work on really big, but sparse, arrays */

var fastFindIndex = function fastFindIndex(arr, fn) {
  return Number(Object.keys(arr).find(function (k) {
    return fn(arr[Number(k)]);
  }));
};

function propsHaveCompactView(props) {
  return props.variant === 'compact' && props.children.length > 5;
}

function shouldShowPrevButton(props, currentPageIndex) {
  return propsHaveCompactView(props) && currentPageIndex > 0;
}

function shouldShowNextButton(props, currentPageIndex) {
  return propsHaveCompactView(props) && currentPageIndex < props.children.length - 1;
}
/**
---
category: components
---
**/


var _ref2 = /*#__PURE__*/React.createElement("span", {
  key: "first",
  "aria-hidden": "true"
}, "\u2026");

var _ref3 = /*#__PURE__*/React.createElement("span", {
  key: "last",
  "aria-hidden": "true"
}, "\u2026");

var Pagination = (_dec = testable(), _dec2 = themeable(theme, styles), _dec(_class = _dec2(_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
  _inherits(Pagination, _Component);

  var _super = _createSuper(Pagination);

  function Pagination() {
    var _this;

    _classCallCheck(this, Pagination);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _this.handleElementRef = function (el) {
      if (el) {
        _this._root = el;

        if (typeof _this.props.elementRef === 'function') {
          _this.props.elementRef(el);
        }
      }
    };

    _this._labelId = uid('Pagination');
    _this._prevButton = null;
    _this._nextButton = null;
    return _this;
  }

  _createClass(Pagination, [{
    key: "getSnapshotBeforeUpdate",
    value: function getSnapshotBeforeUpdate() {
      var activeElement = getActiveElement();
      return {
        prevButtonFocused: this._prevButton === activeElement,
        nextButtonFocused: this._nextButton === activeElement
      };
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState, snapshot) {
      if (!this.props.shouldHandleFocus || !propsHaveCompactView(prevProps) && !propsHaveCompactView(this.props)) {
        return;
      }

      var _ref = snapshot || {},
          prevButtonFocused = _ref.prevButtonFocused,
          nextButtonFocused = _ref.nextButtonFocused;

      if (prevButtonFocused || nextButtonFocused) {
        var focusable = findTabbable(this._root);
        var focusIndex = prevButtonFocused ? 0 : focusable.length - 1;
        focusable[focusIndex].focus();
      }
    }
  }, {
    key: "transferDisabledPropToChildren",
    value: function transferDisabledPropToChildren(children) {
      var _this2 = this;

      return this.props.disabled ? React.Children.map(children, function (page) {
        return React.cloneElement(page, {
          disabled: _this2.props.disabled
        });
      }) : children;
    }
  }, {
    key: "renderLabel",
    value: function renderLabel() {
      var display = this.props.variant === 'compact' ? 'block' : 'inline-block';
      var visibleLabel = hasVisibleChildren(this.props.label);
      return /*#__PURE__*/React.createElement(View, {
        as: "span",
        padding: visibleLabel ? 'small' : '0',
        display: visibleLabel ? display : 'auto',
        id: this._labelId
      }, this.props.label);
    }
  }, {
    key: "renderPages",
    value: function renderPages(currentPageIndex) {
      var allPages = this.props.children;
      var visiblePages = allPages;

      if (this.compactView) {
        var firstIndex = 0;
        var lastIndex = allPages.length - 1;
        var sliceStart = Math.min(lastIndex - 3, Math.max(currentPageIndex - 1, firstIndex));
        var sliceEnd = Math.min(currentPageIndex + 4, lastIndex);
        visiblePages = allPages.slice(sliceStart, sliceEnd);
        var firstPage = allPages[firstIndex];
        var lastPage = allPages[lastIndex];
        if (sliceStart - firstIndex > 1) visiblePages.unshift(_ref2);
        if (sliceStart - firstIndex > 0) visiblePages.unshift(firstPage);
        if (lastIndex - sliceEnd + 1 > 1) visiblePages.push(_ref3);
        if (lastIndex - sliceEnd + 1 > 0) visiblePages.push(lastPage);
      }

      return /*#__PURE__*/React.createElement(View, {
        display: "inline-block"
      }, this.transferDisabledPropToChildren(visiblePages));
    }
  }, {
    key: "renderArrowButton",
    value: function renderArrowButton(label, direction, currentPageIndex) {
      var _this3 = this;

      // eslint-disable-next-line react/prop-types
      var _this$props$children$ = this.props.children[currentPageIndex + direction].props,
          onClick = _this$props$children$.onClick,
          disabled = _this$props$children$.disabled;

      var handleButtonRef = function handleButtonRef(el) {
        if (direction < 0) {
          _this3._prevButton = el;
        } else {
          _this3._nextButton = el;
        }
      };

      return /*#__PURE__*/React.createElement(PaginationArrowButton, {
        direction: direction === -1 ? 'prev' : 'next',
        label: label,
        onClick: onClick,
        disabled: disabled,
        buttonRef: handleButtonRef
      });
    }
  }, {
    key: "render",
    value: function render() {
      if (!this.props.children) return null;
      var currentPageIndex = fastFindIndex(this.props.children, function (p) {
        return p && p.props && p.props.current;
      });
      var passthroughProps = View.omitViewProps(omitProps(this.props, Pagination.propTypes), Pagination);
      return /*#__PURE__*/React.createElement(View, Object.assign({}, passthroughProps, {
        role: "navigation",
        as: this.props.as,
        elementRef: this.handleElementRef,
        margin: this.props.margin,
        className: styles.root,
        "aria-labelledby": this.props.label && this._labelId
      }), this.props.label && this.renderLabel(), /*#__PURE__*/React.createElement(View, {
        display: "inline-block",
        className: styles.pages
      }, shouldShowPrevButton(this.props, currentPageIndex) && this.renderArrowButton(this.props.labelPrev, -1, currentPageIndex), this.renderPages(currentPageIndex), shouldShowNextButton(this.props, currentPageIndex) && this.renderArrowButton(this.props.labelNext, 1, currentPageIndex)));
    }
  }, {
    key: "compactView",
    get: function get() {
      return propsHaveCompactView(this.props);
    }
  }]);

  Pagination.displayName = "Pagination";
  return Pagination;
}(Component), _class2.propTypes = {
  /**
   * children of type Pagination.Page
   */
  children: Children.oneOf([PaginationButton]),

  /**
   * Disables interaction with all pages
   */
  disabled: PropTypes.bool,

  /**
   * Visible label for component
   */
  label: PropTypes.node,

  /**
   * Accessible label for next button
   */
  labelNext: PropTypes.string,

  /**
   * Accessible label for previous button
   */
  labelPrev: PropTypes.string,

  /**
   * The compact variant truncates the page navigation to show only the first,
   * last, and pages immediately surrounding the current page. Fewer than 5 pages,
   * no next/previous arrow buttons will be shown, and all pages will be listed
   */
  variant: PropTypes.oneOf(['full', 'compact']),

  /**
   * Valid values are `0`, `none`, `auto`, `xxx-small`, `xx-small`, `x-small`,
   * `small`, `medium`, `large`, `x-large`, `xx-large`. Apply these values via
   * familiar CSS-like shorthand. For example: `margin="small auto large"`.
   */
  margin: ThemeablePropTypes.spacing,

  /**
   * the element type to render as
   */
  as: PropTypes.elementType,

  /**
   * provides a reference to the underlying html root element
   */
  elementRef: PropTypes.func,

  /**
   * For accessibility, Pagination sets focus on the first or last Pagination.Pages,
   * respectively, when the Previous or Next arrow buttons are removed from the DOM.
   * Set this property to `false` to prevent this behavior.
   */
  shouldHandleFocus: PropTypes.bool
}, _class2.defaultProps = {
  children: null,
  label: void 0,
  labelNext: void 0,
  labelPrev: void 0,
  margin: void 0,
  disabled: false,
  variant: 'full',
  as: 'div',
  elementRef: function elementRef(el) {},
  shouldHandleFocus: true
}, _class2.Page = PaginationButton, _class2.Navigation = PaginationArrowButton, _temp)) || _class) || _class);
export default Pagination;
export { Pagination, PaginationButton };
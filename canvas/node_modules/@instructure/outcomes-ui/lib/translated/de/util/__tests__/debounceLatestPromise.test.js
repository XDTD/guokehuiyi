"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _chai = require("chai");

var _sinon = _interopRequireDefault(require("sinon"));

var _debouceLatestPromise = _interopRequireDefault(require("../debouceLatestPromise"));

describe('debounceLatestPromise', function () {
  var dispatch = _sinon.default.stub().resolves(function () {
    return 'resolved';
  });

  var clock = null;
  beforeEach(function () {
    clock = _sinon.default.useFakeTimers();
  });
  afterEach(function () {
    clock.restore();
    dispatch.resetHistory();
  });
  it('correctly debounces', function () {
    var debounced = (0, _debouceLatestPromise.default)(function () {
      return dispatch.apply(void 0, arguments);
    }, 500);
    debounced('search #1');
    clock.tick(400);
    (0, _chai.expect)(dispatch).to.not.be.called;
    clock.tick(100);
    (0, _chai.expect)(dispatch).to.be.called.once;
    (0, _chai.expect)(dispatch).to.be.calledWith('search #1');
  });
  it('correctly debounces the latest promise', function () {
    var debounced = (0, _debouceLatestPromise.default)(function () {
      return dispatch.apply(void 0, arguments);
    }, 500);
    debounced('search #1');
    debounced('search #2');
    clock.tick(500);
    (0, _chai.expect)(dispatch).to.be.called.once;
    (0, _chai.expect)(dispatch).to.be.calledWith('search #2');
  });
  it('calls the function again after the timeout passes', function () {
    var debounced = (0, _debouceLatestPromise.default)(function () {
      return dispatch.apply(void 0, arguments);
    }, 500);
    debounced('search #1');
    clock.tick(500);
    debounced('search #2');
    clock.tick(500);
    (0, _chai.expect)(dispatch).to.be.called.calledTwice;
    (0, _chai.expect)(dispatch).to.be.calledWith('search #1');
    (0, _chai.expect)(dispatch).to.be.calledWith('search #2');
  });
});
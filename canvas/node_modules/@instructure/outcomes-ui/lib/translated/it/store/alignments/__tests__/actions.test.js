"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _immutable = require("immutable");

var _chai = require("chai");

var _sinon = _interopRequireDefault(require("sinon"));

var _constants = require("../../../constants");

var _createMockStore = _interopRequireWildcard(require("../../../test/createMockStore"));

var actions = _interopRequireWildcard(require("../actions"));

var _actions2 = require("../../../store/context/actions");

var _arguments = arguments;
var scopedActions = (0, _createMockStore.scopeActions)((0, _objectSpread2.default)({}, actions, {
  setError: _actions2.setError
}));
describe('alignments/actions', function () {
  describe('setAlignments', function () {
    it('creates an action', function () {
      var action = actions.setAlignments([]);
      (0, _chai.expect)(action.type).to.equal(_constants.SET_ALIGNMENTS);
      (0, _chai.expect)(action.payload).to.deep.equal([]);
    });
  });
  describe('viewAlignment', function () {
    it('creates an action', function () {
      var action = actions.viewAlignmentAction(12);
      (0, _chai.expect)(action.type).to.equal(_constants.VIEW_ALIGNMENT);
      (0, _chai.expect)(action.payload).to.deep.equal(12);
    });
    it('dispatches viewAlignmentAction', function () {
      var service = {
        viewAlignmentAction: _sinon.default.stub().returns(Promise.resolve())
      };
      var state = (0, _immutable.fromJS)({
        scopeForTest: {
          alignments: {
            alignedOutcomes: [{
              id: 1,
              scoring_method: 'boom'
            }],
            alignmentSetId: 'badong'
          }
        }
      });
      var store = (0, _createMockStore.default)(state, service);
      return store.dispatch(actions.viewAlignment(1)).then(function () {
        (0, _chai.expect)(store.getActions()).to.have.length(1);
        (0, _chai.expect)(store.getActions()[0]).to.deep.equal(scopedActions.viewAlignmentAction(1));
        return null;
      });
    });
    it('fetches an outcome and dispatches updateAlignment', function () {
      var full = {
        id: 1,
        scoring_method: 'boom'
      };
      var service = {
        getOutcome: _sinon.default.stub().returns(Promise.resolve(full))
      };
      var state = (0, _immutable.fromJS)({
        scopeForTest: {
          alignments: {
            alignedOutcomes: [{
              id: 1
            }],
            alignmentSetId: 'badong'
          }
        }
      });
      var store = (0, _createMockStore.default)(state, service);
      return store.dispatch(actions.viewAlignment(1)).then(function () {
        (0, _chai.expect)(store.getActions()).to.have.length(3);
        (0, _chai.expect)(store.getActions()[0]).to.deep.equal(scopedActions.viewAlignmentAction(1));
        (0, _chai.expect)(store.getActions()[2]).to.deep.equal(scopedActions.updateAlignment({
          outcome: full
        }));
        return null;
      });
    });
  });
  describe('updateAlignment', function () {
    it('creates an action', function () {
      var action = actions.updateAlignment(12);
      (0, _chai.expect)(action.type).to.equal(_constants.UPDATE_ALIGNMENT);
      (0, _chai.expect)(action.payload).to.deep.equal(12);
    });
  });
  describe('closeAlignment', function () {
    it('creates an action', function () {
      var action = actions.closeAlignment();
      (0, _chai.expect)(action.type).to.equal(_constants.CLOSE_ALIGNMENT);
    });
  });
  describe('updateAlignments', function () {
    it('dispatches setAlignments when called', function () {
      var alignments = [{
        id: '1'
      }, {
        id: '2'
      }];
      var service = {
        getAlignments: _sinon.default.stub().returns(Promise.resolve(alignments))
      };
      var store = (0, _createMockStore.default)((0, _immutable.Map)(), service);
      return store.dispatch(actions.updateAlignments('hexadecimal', alignments)).then(function () {
        (0, _chai.expect)(store.getActions()).to.have.length(1);
        (0, _chai.expect)(store.getActions()[0]).to.deep.equal(scopedActions.setAlignments({
          guid: 'hexadecimal',
          outcomes: alignments
        }));
        return null;
      });
    });
    it('fires an updateCallback function if provided', function () {
      var alignments = [{
        id: '1'
      }, {
        id: '2'
      }];

      var callback = _sinon.default.stub().returns(_arguments);

      var service = {
        getAlignments: _sinon.default.stub().returns(Promise.resolve(alignments))
      };
      var store = (0, _createMockStore.default)((0, _immutable.Map)(), service);
      return store.dispatch(actions.updateAlignments('hexadecimal', alignments, callback)).then(function () {
        (0, _chai.expect)(callback.calledOnce).to.be.true;
        (0, _chai.expect)(callback.calledWith({
          guid: 'hexadecimal',
          outcomes: alignments
        })).to.be.true;
        return null;
      });
    });
  });
  describe('loadAlignments', function () {
    it('responds with a null guid and empty outcome array if the alignmentSetId does not match the scope', function () {
      var store = (0, _createMockStore.default)((0, _immutable.fromJS)({
        scopeForTest: {
          alignments: {
            alignedOutcomes: [{
              id: '1'
            }],
            alignmentSetId: 'badong'
          }
        }
      }));
      return store.dispatch(actions.loadAlignments('gnodab')).then(function () {
        (0, _chai.expect)(store.getActions()[0]).to.deep.equal(scopedActions.setAlignments({
          guid: null,
          outcomes: []
        }));
        return null;
      });
    });
    it('responds with a null guid and empty outcome array if there is no alignment set id', function () {
      var service = {
        clearAlignmentSet: _sinon.default.stub().returns(Promise.resolve()),
        getAlignments: _sinon.default.stub().returns(Promise.resolve())
      };
      var store = (0, _createMockStore.default)((0, _immutable.fromJS)({
        scopeForTest: {
          alignments: {
            alignedOutcomes: [{
              id: '1'
            }]
          }
        }
      }), service);
      return store.dispatch(actions.loadAlignments(null)).then(function () {
        (0, _chai.expect)(store.getActions()[0]).to.deep.equal(scopedActions.setAlignments({
          guid: null,
          outcomes: []
        }));
        return null;
      });
    });
    it('calls outcome service to load alignments', function () {
      var service = {
        getAlignments: _sinon.default.stub().returns(Promise.resolve())
      };
      var store = (0, _createMockStore.default)((0, _immutable.Map)(), service);
      return store.dispatch(actions.loadAlignments('hexadecimal')).then(function () {
        (0, _chai.expect)(service.getAlignments.calledOnce).to.be.true;
        return null;
      });
    });
    it('dispatches setError on outcome service failure', function () {
      var error = {
        message: 'foo bar baz'
      };
      var service = {
        getAlignments: _sinon.default.stub().returns(Promise.reject(error))
      };
      var store = (0, _createMockStore.default)((0, _immutable.Map)(), service);
      return store.dispatch(actions.loadAlignments('hexadecimal')).then(function () {
        (0, _chai.expect)(store.getActions()).to.have.length(3);
        (0, _chai.expect)(store.getActions()[2]).to.deep.equal(scopedActions.setError(error));
        return null;
      });
    });
  });
  describe('loadArtifact', function () {
    it('calls outcome service to load artfiact', function () {
      var response = {
        guid: 'guid',
        outcomes: [{
          id: '1'
        }]
      };
      var service = {
        getArtifact: _sinon.default.stub().returns(Promise.resolve(response))
      };
      var store = (0, _createMockStore.default)((0, _immutable.Map)(), service);
      return store.dispatch(actions.loadArtifact({
        artifactType: 'type',
        artifactId: '1'
      })).then(function () {
        (0, _chai.expect)(store.getActions()).to.have.length(3);
        (0, _chai.expect)(service.getArtifact.calledOnce).to.be.true;
        (0, _chai.expect)(store.getActions()[2]).to.deep.equal(scopedActions.setAlignments(response));
        return null;
      });
    });
    it('dispatches setError on outcome service failure', function () {
      var error = {
        message: 'foo bar baz'
      };
      var service = {
        getArtifact: _sinon.default.stub().returns(Promise.reject(error))
      };
      var store = (0, _createMockStore.default)((0, _immutable.Map)(), service);
      return store.dispatch(actions.loadArtifact({
        artifactType: '',
        artifactId: ''
      })).then(function () {
        (0, _chai.expect)(store.getActions()).to.have.length(3);
        (0, _chai.expect)(store.getActions()[2]).to.deep.equal(scopedActions.setError(error));
        return null;
      });
    });
  });
  describe('removeAlignment', function () {
    it('calls outcomes service to create new alignment set', function () {
      var service = {
        createAlignmentSet: _sinon.default.stub().returns(Promise.resolve())
      };
      var store = (0, _createMockStore.default)((0, _immutable.fromJS)({
        scopeForTest: {
          alignments: {
            alignedOutcomes: [{
              id: '1'
            }, {
              id: '12'
            }]
          }
        }
      }), service);
      return store.dispatch(actions.removeAlignment('12')).then(function () {
        (0, _chai.expect)(service.createAlignmentSet.calledOnce).to.be.true;
        (0, _chai.expect)(service.createAlignmentSet.calledWith([]));
        return null;
      });
    });
    it('responds with a null guid and empty outcome array if no alignments remain', function () {
      var service = {
        clearAlignmentSet: _sinon.default.stub().returns(Promise.resolve())
      };
      var store = (0, _createMockStore.default)((0, _immutable.fromJS)({
        scopeForTest: {
          alignments: {
            alignedOutcomes: [{
              id: '1'
            }]
          }
        }
      }), service);
      return store.dispatch(actions.removeAlignment('1')).then(function () {
        (0, _chai.expect)(store.getActions()[0]).to.deep.equal(scopedActions.setAlignments({
          guid: null,
          outcomes: []
        }));
        return null;
      });
    });
    it('dispatches setError on outcome service failure', function () {
      var error = {
        message: 'baz bar foo'
      };
      var service = {
        createAlignmentSet: _sinon.default.stub().returns(Promise.reject(error))
      };
      var store = (0, _createMockStore.default)((0, _immutable.fromJS)({
        scopeForTest: {
          alignments: {
            alignedOutcomes: [{
              id: '12'
            }]
          }
        }
      }), service);
      return store.dispatch(actions.removeAlignment('1')).then(function () {
        (0, _chai.expect)(store.getActions()).to.have.length(2);
        (0, _chai.expect)(store.getActions()[1]).to.deep.equal(scopedActions.setError(error));
        return null;
      });
    });
    it('calls upsertArtifact if shouldUpdateArtifact is true', function () {
      var response = {
        guid: 'my-guid-1',
        outcomes: [{
          id: '1'
        }]
      };
      var service = {
        upsertArtifact: _sinon.default.stub().returns(Promise.resolve(response))
      };
      var store = (0, _createMockStore.default)((0, _immutable.fromJS)({
        scopeForTest: {
          alignments: {
            alignedOutcomes: [{
              id: '1'
            }, {
              id: '12'
            }]
          }
        }
      }), service);
      return store.dispatch(actions.removeAlignment('12', null, true)).then(function () {
        (0, _chai.expect)(service.upsertArtifact.calledOnce).to.be.true;
        (0, _chai.expect)(store.getActions()[0].payload.args.slice(-1)).to.deep.equal([['1']]);
        (0, _chai.expect)(store.getActions()).to.deep.include(scopedActions.setAlignments(response));
        return null;
      });
    });
  });
});
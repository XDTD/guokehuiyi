"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _chai = require("chai");

var _react = _interopRequireDefault(require("react"));

var _enzyme = require("enzyme");

var _sinon = _interopRequireDefault(require("sinon"));

var _index = _interopRequireDefault(require("../index"));

var _checkA11y = _interopRequireDefault(require("../../../test/checkA11y"));

describe('AlignmentButton', function () {
  function makeProps() {
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Object.assign({
      alignedOutcomes: [{
        id: '1',
        label: 'A1',
        title: 'tA1'
      }, {
        id: '2',
        label: 'B2',
        title: 'tB2'
      }, {
        id: '3',
        label: 'C3',
        title: 'tC3'
      }],
      tray: function tray() {
        return _react.default.createElement("div", {
          className: "outcomeTray"
        });
      },
      // eslint-disable-line react/display-name
      scope: 'scopeForTest',
      openOutcomePicker: _sinon.default.spy(),
      removeAlignment: _sinon.default.spy(),
      onUpdate: _sinon.default.spy(),
      screenreaderNotification: _sinon.default.spy()
    }, props);
  }

  it('renders a button with a11y components', function () {
    var wrapper = (0, _enzyme.shallow)(_react.default.createElement(_index.default, makeProps()), {
      disableLifecycleMethods: true
    });
    (0, _chai.expect)(wrapper.find('Button')).to.have.length(1);
    (0, _chai.expect)(wrapper.find('AccessibleContent')).to.have.length(1);
  });
  it('does not render an alignment button if readOnly is true', function () {
    var wrapper = (0, _enzyme.shallow)(_react.default.createElement(_index.default, makeProps({
      readOnly: true
    })), {
      disableLifecycleMethods: true
    });
    (0, _chai.expect)(wrapper.find('Button')).to.have.length(0);
  });
  it('does not render header if readOnly is true and no outcomes are aligned', function () {
    var wrapper = (0, _enzyme.shallow)(_react.default.createElement(_index.default, makeProps({
      readOnly: true,
      alignedOutcomes: []
    })), {
      disableLifecycleMethods: true
    });
    (0, _chai.expect)(wrapper.find('Text')).to.have.length(0);
    (0, _chai.expect)(wrapper.find('IconOutcomesLine')).to.have.length(0);
    (0, _chai.expect)(wrapper.find('AlignmentCount')).to.have.length(0);
  });
  it('calls openOutcomePicker when the button is pressed', function () {
    var props = makeProps();
    var wrapper = (0, _enzyme.shallow)(_react.default.createElement(_index.default, props), {
      disableLifecycleMethods: true
    });
    wrapper.find('Button').simulate('click');
    (0, _chai.expect)(props.openOutcomePicker.calledOnce).to.be.true;
  });
  it('renders AlignmentItems for each aligned outcome', function () {
    var wrapper = (0, _enzyme.mount)(_react.default.createElement(_index.default, makeProps()));
    (0, _chai.expect)(wrapper.find('AlignmentItem')).to.have.length(3);
  });
  it('renders an AlignmentCount object', function () {
    var wrapper = (0, _enzyme.mount)(_react.default.createElement(_index.default, makeProps()));
    (0, _chai.expect)(wrapper.find('AlignmentCount')).to.have.length(1);
  });
  it('meets a11y standards', function () {
    return (0, _checkA11y.default)(_react.default.createElement(_index.default, makeProps()));
  });
  describe('when an alignment is removed', function () {
    it('calls the removeAlignment action with shouldUpdateArtifact equal to true', function () {
      var props = makeProps();
      var wrapper = (0, _enzyme.mount)(_react.default.createElement(_index.default, props));
      var first = wrapper.find('AlignmentItem').at(0);
      var remove = first.prop('removeAlignment');
      var outcome = first.prop('outcome');
      remove();
      (0, _chai.expect)(props.removeAlignment.getCall(0).args).to.include(outcome.id, true);
    });
    it('focuses on the previous alignment when the second alignment deleted', function () {
      var wrapper = (0, _enzyme.mount)(_react.default.createElement(_index.default, makeProps()));
      var first = wrapper.find('AlignmentItem').at(0);
      var next = wrapper.find('AlignmentItem').at(1);

      var focus = _sinon.default.spy(first.instance(), 'focus');

      var remove = next.prop('removeAlignment');
      remove();
      (0, _chai.expect)(focus.calledOnce).to.be.true;
      (0, _chai.expect)(focus.calledWith()).to.be.true;
    });
    it('focuses on the next alignment when first alignment deleted', function () {
      var wrapper = (0, _enzyme.mount)(_react.default.createElement(_index.default, makeProps()));
      var first = wrapper.find('AlignmentItem').at(0);
      var next = wrapper.find('AlignmentItem').at(1);
      var remove = first.prop('removeAlignment');

      var focus = _sinon.default.spy(next.instance(), 'focus');

      remove();
      (0, _chai.expect)(focus.calledOnce).to.be.true;
      (0, _chai.expect)(focus.calledWith()).to.be.true;
    });
  });
  describe('componentDidUpdate', function () {
    it('shifts focus to the |+Outcome| Button when alignments are removed', function (done) {
      var outcomes = {
        alignedOutcomes: [{
          id: '1',
          label: 'A1',
          title: 'tA1'
        }]
      };
      var wrapper = (0, _enzyme.mount)(_react.default.createElement(_index.default, makeProps(outcomes)));
      var trigger = wrapper.find('button').last();

      var focus = _sinon.default.spy(trigger.instance(), 'focus');

      wrapper.setProps({
        alignedOutcomes: []
      }, function () {
        (0, _chai.expect)(wrapper.find('button')).to.have.length(1);
        (0, _chai.expect)(focus.calledOnce).to.be.true;
        (0, _chai.expect)(focus.calledWith()).to.be.true;
        done();
      });
    });
  });
});
import { expect } from 'chai';
import React from 'react';
import sinon from 'sinon';
import { shallow, mount } from 'enzyme';
import AlignmentList from '../index';
import checkA11y from '../../../test/checkA11y';
describe('AlignmentList', function () {
  var triggerButtonSelector = 'Button[variant="circle-primary"]';

  function makeProps() {
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Object.assign({
      alignedOutcomes: [{
        id: '1',
        label: 'A1',
        title: 'tA1'
      }, {
        id: '2',
        label: 'B2',
        title: 'tB2'
      }, {
        id: '3',
        label: 'C3',
        title: 'tC3'
      }],
      emptySetHeading: 'Foo',
      scope: 'scopeForTest',
      viewAlignment: sinon.spy(),
      closeAlignment: sinon.spy(),
      removeAlignment: sinon.spy(),
      onUpdate: sinon.spy(),
      isOpen: sinon.stub().returns(false),
      setOutcomePickerState: sinon.spy(),
      openOutcomePicker: sinon.spy(),
      screenreaderNotification: sinon.spy(),
      addModal: function addModal() {
        return null;
      },
      outcomePicker: function outcomePicker() {
        return null;
      },
      readOnly: false
    }, props);
  }

  describe('no alignments present', function () {
    var props = makeProps({
      alignedOutcomes: []
    });
    it('shows billboard when no alignments present', function () {
      var wrapper = shallow(React.createElement(AlignmentList, props), {
        disableLifecycleMethods: true
      });
      expect(wrapper.find('Billboard')).to.have.length(1);
    });
    it('does not show the billboard when readOnly is true', function () {
      var props = makeProps({
        alignedOutcomes: [],
        readOnly: true
      });
      var wrapper = shallow(React.createElement(AlignmentList, props), {
        disableLifecycleMethods: true
      });
      expect(wrapper.find('Billboard')).to.have.length(0);
    });
    it('includes the right heading', function () {
      var wrapper = shallow(React.createElement(AlignmentList, props), {
        disableLifecycleMethods: true
      });
      expect(wrapper.find('Billboard').prop('heading')).to.equal('Foo');
    });
    it('launches modal when billboard clicked', function () {
      var wrapper = shallow(React.createElement(AlignmentList, props), {
        disableLifecycleMethods: true
      });
      wrapper.find('Billboard').simulate('click');
      expect(props.openOutcomePicker.calledOnce).to.be.true;
    });
    it('focuses the billboard button when focus called', function (done) {
      var wrapper = mount(React.createElement(AlignmentList, props));
      setTimeout(function () {
        var trigger = wrapper.find('button').last();
        var focus = sinon.spy(trigger.instance(), 'focus');
        wrapper.instance().focus();
        setTimeout(function () {
          expect(focus.calledOnce).to.be.true;
          expect(focus.calledWith()).to.be.true;
          done();
        }, 1);
      }, 1);
    });
    it('meets a11y standards', function () {
      return checkA11y(React.createElement(AlignmentList, props));
    });
  });
  describe('alignments present', function () {
    it('shows list', function () {
      var wrapper = shallow(React.createElement(AlignmentList, makeProps()), {
        disableLifecycleMethods: true
      });
      expect(wrapper.find('ul')).to.have.length(1);
    });
    it('adds one alignment row per alignment', function () {
      var wrapper = shallow(React.createElement(AlignmentList, makeProps()), {
        disableLifecycleMethods: true
      });
      expect(wrapper.find('Alignment')).to.have.length(3);
    });
    it('gives correct outcome to alignment rows', function () {
      var wrapper = shallow(React.createElement(AlignmentList, makeProps()), {
        disableLifecycleMethods: true
      });
      expect(wrapper.find('Alignment').last().prop('outcome')).to.have.property('label', 'C3');
    });
    it('gives correct callbacks to alignment rows', function () {
      var props = makeProps();
      var wrapper = mount(React.createElement(AlignmentList, props));
      var first = wrapper.find('Alignment').at(0);
      var remove = first.prop('removeAlignment');
      remove();
      expect(props.removeAlignment.calledWith('1', props.onUpdate)).to.be.true;
      var view = first.prop('viewAlignment');
      view();
      expect(props.viewAlignment.calledWith('1')).to.be.true;
      var close = first.prop('closeAlignment');
      close();
      expect(props.closeAlignment.calledWith()).to.be.true;
    });
    it('renders a trigger button when readOnly is false', function () {
      var wrapper = shallow(React.createElement(AlignmentList, makeProps()), {
        disableLifecycleMethods: true
      });
      expect(wrapper.find(triggerButtonSelector)).to.have.length(1);
    });
    it('does not render a trigger button when readOnly is true', function () {
      var wrapper = shallow(React.createElement(AlignmentList, makeProps({
        readOnly: true
      })), {
        disableLifecycleMethods: true
      });
      expect(wrapper.find(triggerButtonSelector)).to.have.length(0);
    });
    it('launches modal when trigger button clicked', function () {
      var props = makeProps();
      var wrapper = shallow(React.createElement(AlignmentList, props), {
        disableLifecycleMethods: true
      });
      wrapper.find(triggerButtonSelector).simulate('click');
      expect(props.openOutcomePicker.calledOnce).to.be.true;
    });
    it('focuses the add button when modal dismissed', function (done) {
      var wrapper = mount(React.createElement(AlignmentList, makeProps()));
      setTimeout(function () {
        var trigger = wrapper.find('button').last();
        var focus = sinon.spy(trigger.instance(), 'focus');
        wrapper.instance().focus();
        setTimeout(function () {
          expect(focus.calledOnce).to.be.true;
          expect(focus.calledWith()).to.be.true;
          done();
        }, 1);
      }, 1);
    });
    it('generates screenreader notification when removing an alignment', function (done) {
      var props = makeProps();
      var wrapper = mount(React.createElement(AlignmentList, props));
      var first = wrapper.find('Alignment').at(0);
      var label = first.instance().props.outcome.label;
      var remove = first.prop('removeAlignment');
      remove();
      setTimeout(function () {
        expect(props.screenreaderNotification.getCall(0).args[0]).to.include(label);
        done();
      }, 1);
    });
    it('focuses on the prior alignment when current alignment deleted', function (done) {
      var wrapper = mount(React.createElement(AlignmentList, makeProps()));
      setTimeout(function () {
        var last = wrapper.find('Alignment').at(2);
        var previous = wrapper.find('Alignment').at(1);
        var focus = sinon.spy(previous.instance(), 'focus');
        var remove = last.prop('removeAlignment');
        remove();
        setTimeout(function () {
          expect(focus.calledOnce).to.be.true;
          expect(focus.calledWith()).to.be.true;
          done();
        }, 1);
      }, 1);
    });
    it('focuses on the next alignment when first alignment deleted', function (done) {
      var wrapper = mount(React.createElement(AlignmentList, makeProps()));
      setTimeout(function () {
        var first = wrapper.find('Alignment').at(0);
        var next = wrapper.find('Alignment').at(1);
        var focus = sinon.spy(next.instance(), 'focus');
        var remove = first.prop('removeAlignment');
        remove();
        setTimeout(function () {
          expect(focus.calledOnce).to.be.true;
          expect(focus.calledWith()).to.be.true;
          done();
        }, 1);
      }, 1);
    });
    it('meets a11y standards', function () {
      return checkA11y(React.createElement(AlignmentList, makeProps()));
    });
  });
});
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/esm/inherits";

var _dec, _class, _class2, _temp;

import React from 'react';
import PropTypes from 'prop-types';
import { Button, CloseButton } from '@instructure/ui-buttons';
import { Heading } from '@instructure/ui-heading';
import { Flex } from '@instructure/ui-flex';
import { Modal } from '@instructure/ui-modal';
import { themeable } from '@instructure/ui-themeable';
import { View } from '@instructure/ui-view';
import { Tray } from '@instructure/ui-tray';
import { Spinner } from '@instructure/ui-spinner';
import OutcomeList from './OutcomeList';
import OutcomeViewModal from '../OutcomeViewModal';
import SearchInput from '../SearchInput';
import SearchResults from '../SearchResults';
import theme from '../theme';
var styles = {
  componentId: 'fPfsV',
  template: function template(theme) {
    return "\n\n.outcomes-ui__OutcomeTray--outcomeTray {\n  display: flex;\n  flex-direction: column;\n  flex-grow: 1;\n  min-height: 0;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n\n.outcomes-ui__OutcomeTray--trayContainer {\n  padding: 1rem;\n  flex-grow: 1;\n  overflow: auto;\n  min-height: 0;\n}\n\n.outcomes-ui__OutcomeTray--footerContainer {\n  bottom: 0;\n  position: -webkit-sticky;\n  position: sticky;\n}\n";
  },
  'outcomeTray': 'outcomes-ui__OutcomeTray--outcomeTray',
  'trayContainer': 'outcomes-ui__OutcomeTray--trayContainer',
  'footerContainer': 'outcomes-ui__OutcomeTray--footerContainer'
};
import { outcomeShape } from '../../store/shapes';
var ModalFooter = Modal.Footer;
var OutcomeTray = (_dec = themeable(theme, styles), _dec(_class = (_temp = _class2 = /*#__PURE__*/function (_React$Component) {
  _inherits(OutcomeTray, _React$Component);

  function OutcomeTray() {
    _classCallCheck(this, OutcomeTray);

    return _possibleConstructorReturn(this, _getPrototypeOf(OutcomeTray).apply(this, arguments));
  }

  _createClass(OutcomeTray, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props = this.props,
          getOutcomesList = _this$props.getOutcomesList,
          isOpen = _this$props.isOpen,
          updateSearchText = _this$props.updateSearchText,
          setInitialSelectedOutcomes = _this$props.setInitialSelectedOutcomes;

      if (!prevProps.isOpen && isOpen) {
        getOutcomesList({
          page: 1
        });
        updateSearchText('');
        setInitialSelectedOutcomes();
      }
    }
  }, {
    key: "renderList",
    value: function renderList() {
      var _this$props2 = this.props,
          outcomes = _this$props2.outcomes,
          setFocusedOutcome = _this$props2.setFocusedOutcome,
          isOutcomeSelected = _this$props2.isOutcomeSelected,
          selectOutcomeIds = _this$props2.selectOutcomeIds,
          deselectOutcomeIds = _this$props2.deselectOutcomeIds,
          isFetching = _this$props2.isFetching,
          listPage = _this$props2.listPage,
          listTotal = _this$props2.listTotal,
          getOutcomesList = _this$props2.getOutcomesList;
      return React.createElement(View, {
        display: "block",
        padding: "small none none none"
      }, React.createElement(OutcomeList, {
        outcomes: outcomes,
        setFocusedOutcome: setFocusedOutcome,
        isOutcomeSelected: isOutcomeSelected,
        selectOutcomeIds: selectOutcomeIds,
        deselectOutcomeIds: deselectOutcomeIds,
        isLoading: isFetching,
        listPage: listPage,
        listTotal: listTotal,
        getOutcomesList: getOutcomesList
      }));
    }
  }, {
    key: "renderViewModal",
    value: function renderViewModal() {
      var _this$props3 = this.props,
          focusedOutcome = _this$props3.focusedOutcome,
          setFocusedOutcome = _this$props3.setFocusedOutcome,
          artifactTypeName = _this$props3.artifactTypeName,
          displayMasteryDescription = _this$props3.displayMasteryDescription,
          displayMasteryPercentText = _this$props3.displayMasteryPercentText,
          scope = _this$props3.scope;
      return focusedOutcome && React.createElement(OutcomeViewModal, {
        artifactTypeName: artifactTypeName,
        displayMasteryDescription: displayMasteryDescription,
        displayMasteryPercentText: displayMasteryPercentText,
        outcome: focusedOutcome,
        scope: scope,
        closeAlignment: function closeAlignment() {
          return setFocusedOutcome(null);
        },
        isOpen: true
      });
    }
  }, {
    key: "renderSearchMode",
    value: function renderSearchMode() {
      var _this$props4 = this.props,
          screenreaderNotification = _this$props4.screenreaderNotification,
          setSearchLoading = _this$props4.setSearchLoading,
          setSearchEntries = _this$props4.setSearchEntries,
          searchText = _this$props4.searchText,
          updateSearchPage = _this$props4.updateSearchPage,
          isSearchLoading = _this$props4.isSearchLoading,
          isOutcomeSelected = _this$props4.isOutcomeSelected,
          searchEntries = _this$props4.searchEntries,
          searchPage = _this$props4.searchPage,
          searchTotal = _this$props4.searchTotal,
          selectOutcomeIds = _this$props4.selectOutcomeIds,
          deselectOutcomeIds = _this$props4.deselectOutcomeIds,
          setFocusedOutcome = _this$props4.setFocusedOutcome;
      return React.createElement(SearchResults, {
        screenreaderNotification: screenreaderNotification,
        setSearchLoading: setSearchLoading,
        setSearchEntries: setSearchEntries,
        searchText: searchText,
        updateSearchPage: updateSearchPage,
        isSearchLoading: isSearchLoading,
        isOutcomeSelected: isOutcomeSelected,
        searchEntries: searchEntries,
        searchPage: searchPage,
        searchTotal: searchTotal,
        selectOutcomeIds: selectOutcomeIds,
        deselectOutcomeIds: deselectOutcomeIds,
        setFocusedOutcome: setFocusedOutcome
      });
    }
  }, {
    key: "renderBody",
    value: function renderBody() {
      var _this$props5 = this.props,
          searchText = _this$props5.searchText,
          isFetching = _this$props5.isFetching;

      if (isFetching) {
        return React.createElement(Flex, {
          justifyItems: "center"
        }, React.createElement(Flex.Item, {
          padding: "small"
        }, React.createElement(Spinner, {
          renderTitle: "Loading"
        })));
      }

      return searchText ? this.renderSearchMode() : this.renderList();
    }
  }, {
    key: "handleSubmit",
    value: function handleSubmit() {
      var _this$props6 = this.props,
          saveOutcomePickerAlignments = _this$props6.saveOutcomePickerAlignments,
          onUpdate = _this$props6.onUpdate,
          closeOutcomePicker = _this$props6.closeOutcomePicker,
          shouldModifyArtifact = _this$props6.shouldModifyArtifact;
      return saveOutcomePickerAlignments(onUpdate, shouldModifyArtifact).then(function () {
        return closeOutcomePicker();
      });
    }
  }, {
    key: "renderActions",
    value: function renderActions() {
      var _this = this;

      var closeOutcomePicker = this.props.closeOutcomePicker;
      return React.createElement("div", {
        className: styles.footerContainer
      }, React.createElement(ModalFooter, null, React.createElement(Button, {
        margin: "xxx-small",
        variant: "default",
        onClick: closeOutcomePicker
      }, "Cancel"), React.createElement(Button, {
        margin: "xxx-small",
        variant: "primary",
        onClick: function onClick() {
          return _this.handleSubmit();
        }
      }, "Confirm Alignments")));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props7 = this.props,
          liveRegion = _this$props7.liveRegion,
          mountNode = _this$props7.mountNode,
          searchText = _this$props7.searchText,
          placement = _this$props7.placement,
          size = _this$props7.size,
          updateSearchText = _this$props7.updateSearchText,
          closeOutcomePicker = _this$props7.closeOutcomePicker,
          isOpen = _this$props7.isOpen,
          resetOutcomePicker = _this$props7.resetOutcomePicker;
      var trayProps = {
        placement: placement,
        size: size
      };
      return React.createElement(Tray, Object.assign({
        "data-automation": "outcomeTrayPicker__view",
        liveRegion: liveRegion,
        mountNode: mountNode,
        open: isOpen,
        onExiting: resetOutcomePicker,
        label: "Align Outcomes"
      }, trayProps), React.createElement("div", {
        className: styles.outcomeTray
      }, React.createElement("div", {
        className: styles.trayContainer
      }, React.createElement(Flex, {
        margin: "none none small none"
      }, React.createElement(Flex.Item, {
        shouldGrow: true,
        shouldShrink: true
      }, React.createElement(Heading, {
        level: "h3",
        margin: "0 0 x-small"
      }, "Align Outcomes")), React.createElement(Flex.Item, null, React.createElement(CloseButton, {
        onClick: closeOutcomePicker
      }, "Cancel"))), React.createElement(SearchInput, {
        onChange: function onChange(_, value) {
          return updateSearchText(value);
        },
        onClear: function onClear() {
          return updateSearchText('');
        },
        searchText: searchText
      }), this.renderBody()), this.renderActions(), this.renderViewModal()));
    }
  }]);

  OutcomeTray.displayName = "OutcomeTray";
  return OutcomeTray;
}(React.Component), _class2.propTypes = {
  searchText: PropTypes.string.isRequired,
  updateSearchText: PropTypes.func.isRequired,
  setSearchLoading: PropTypes.func.isRequired,
  setSearchEntries: PropTypes.func.isRequired,
  isSearchLoading: PropTypes.bool.isRequired,
  searchEntries: PropTypes.array.isRequired,
  setFocusedOutcome: PropTypes.func.isRequired,
  isOutcomeSelected: PropTypes.func.isRequired,
  selectOutcomeIds: PropTypes.func.isRequired,
  deselectOutcomeIds: PropTypes.func.isRequired,
  saveOutcomePickerAlignments: PropTypes.func.isRequired,
  screenreaderNotification: PropTypes.func,
  liveRegion: Tray.propTypes.liveRegion,
  mountNode: Tray.propTypes.mountNode,
  size: PropTypes.string,
  placement: PropTypes.string,
  searchTotal: PropTypes.number,
  searchPage: PropTypes.number.isRequired,
  outcomes: PropTypes.array.isRequired,
  getOutcomesList: PropTypes.func.isRequired,
  updateSearchPage: PropTypes.func.isRequired,
  listPage: PropTypes.number.isRequired,
  listTotal: PropTypes.number,
  isFetching: PropTypes.bool.isRequired,
  isOpen: PropTypes.bool.isRequired,
  closeOutcomePicker: PropTypes.func.isRequired,
  resetOutcomePicker: PropTypes.func.isRequired,
  setInitialSelectedOutcomes: PropTypes.func.isRequired,
  onUpdate: PropTypes.func,
  focusedOutcome: outcomeShape,
  artifactTypeName: PropTypes.string,
  displayMasteryDescription: PropTypes.bool,
  displayMasteryPercentText: PropTypes.bool,
  shouldModifyArtifact: PropTypes.bool,
  scope: PropTypes.string.isRequired
}, _class2.defaultProps = {
  screenreaderNotification: null,
  liveRegion: null,
  mountNode: null,
  size: 'regular',
  placement: 'end',
  onUpdate: null,
  focusedOutcome: null,
  artifactTypeName: null,
  displayMasteryDescription: false,
  displayMasteryPercentText: false,
  shouldModifyArtifact: false,
  searchTotal: null,
  listTotal: null
}, _temp)) || _class);
export { OutcomeTray as default };
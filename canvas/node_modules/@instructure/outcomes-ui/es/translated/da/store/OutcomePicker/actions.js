import { createAction } from 'redux-actions';
import { CALL_SERVICE } from '@instructure/redux-service-middleware';
import { getConfig } from '../config/selectors';
import { SELECT_OUTCOME_IDS, UNSELECT_OUTCOME_IDS, SET_SELECTED_OUTCOME_IDS, SET_OUTCOME_PICKER_STATE, SET_FOCUSED_OUTCOME, SET_ACTIVE_COLLECTION_ID, TOGGLE_EXPANDED_IDS, RESET_OUTCOME_PICKER } from '../../constants';
import { loadRootOutcomes, loadMoreOutcomes, setError, setScoringMethod } from '../context/actions';
import { getAlignedOutcomeIds, getAnyOutcome } from '../alignments/selectors';
import { getSelectedOutcomeIds, getOutcomePickerState } from './selectors';
import { createAlignmentSet, updateAlignments, upsertArtifact } from '../alignments/actions';
import { setScope } from '../activePicker/actions';
export var selectOutcomeIds = createAction(SELECT_OUTCOME_IDS);
export var deselectOutcomeIds = createAction(UNSELECT_OUTCOME_IDS);
export var setSelectedOutcomeIds = createAction(SET_SELECTED_OUTCOME_IDS);
export var setOutcomePickerState = createAction(SET_OUTCOME_PICKER_STATE);
export var setActiveCollectionFrd = createAction(SET_ACTIVE_COLLECTION_ID);
export var setFocusedOutcomeAction = createAction(SET_FOCUSED_OUTCOME);
export var toggleExpandedIds = createAction(TOGGLE_EXPANDED_IDS);
export var resetOutcomePicker = createAction(RESET_OUTCOME_PICKER);
export var loadOutcomePicker = function loadOutcomePicker() {
  return function (dispatch, getState, _arg, scope) {
    dispatch(setOutcomePickerState('loading'));
    return dispatch(loadRootOutcomes()).then(function () {
      return dispatch(setSelectedOutcomeIds(getAlignedOutcomeIds(getState(), scope)));
    }).then(function () {
      return dispatch(setOutcomePickerState('choosing'));
    }).then(function () {
      return Promise.resolve();
    }); // allows chaining other thunks
  };
};
export var setActiveCollection = function setActiveCollection(id) {
  return function (dispatch, getState, _arg, scope) {
    dispatch(setActiveCollectionFrd(id));
    return dispatch(loadMoreOutcomes(id));
  };
};
export var setFocusedOutcome = function setFocusedOutcome(outcome) {
  return function (dispatch, getState, _arg, scope) {
    if (!outcome || outcome.scoring_method) {
      dispatch(setFocusedOutcomeAction(outcome));
      return Promise.resolve();
    }

    var _getConfig = getConfig(getState(), scope),
        host = _getConfig.host,
        jwt = _getConfig.jwt,
        contextUuid = _getConfig.contextUuid; // First dispatch brings up the outcome view,
    // second dispatch provides the scoring method


    dispatch(setFocusedOutcomeAction(outcome));
    return dispatch({
      type: CALL_SERVICE,
      payload: {
        service: 'outcomes',
        method: 'getOutcome',
        args: [host, jwt, outcome.id]
      }
    }).then(function (json) {
      dispatch(setScoringMethod({
        context_uuid: contextUuid,
        id: outcome.id,
        scoring_method: json.scoring_method
      }));
      return dispatch(setFocusedOutcomeAction(json));
    });
  };
};
export var saveOutcomePickerAlignments = function saveOutcomePickerAlignments(updateCallback) {
  var shouldUpdateArtifact = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  return function (dispatch, getState, _arg, scope) {
    dispatch(setOutcomePickerState('saving'));
    var state = getState();
    var outcomeIds = getSelectedOutcomeIds(state, scope);
    var outcomes = outcomeIds.map(function (id) {
      return getAnyOutcome(state, scope, id);
    });
    var updateAlignmentFunc = shouldUpdateArtifact ? upsertArtifact : createAlignmentSet;
    return dispatch(updateAlignmentFunc(outcomeIds)).then(function (response) {
      return dispatch(updateAlignments(response.guid, outcomes, updateCallback));
    }).then(function () {
      return dispatch(setOutcomePickerState('complete'));
    }).catch(function (err) {
      return dispatch(setError(err));
    });
  };
};
export var openOutcomePicker = function openOutcomePicker() {
  return function (dispatch, getState, _arg, scope) {
    var pickerState = getOutcomePickerState(getState(), scope);

    if (pickerState !== 'choosing') {
      dispatch(setScope(scope));
      dispatch(setOutcomePickerState('loading'));
    }
  };
};
export var closeOutcomePicker = function closeOutcomePicker() {
  return function (dispatch, getState, _arg, _scope) {
    dispatch(setScope(''));
    dispatch(setOutcomePickerState('closed'));
  };
};
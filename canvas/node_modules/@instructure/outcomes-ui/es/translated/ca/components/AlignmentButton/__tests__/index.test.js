import { expect } from 'chai';
import React from 'react';
import { shallow, mount } from 'enzyme';
import sinon from 'sinon';
import AlignmentButton from '../index';
import checkA11y from '../../../test/checkA11y';
describe('AlignmentButton', function () {
  function makeProps() {
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Object.assign({
      alignedOutcomes: [{
        id: '1',
        label: 'A1',
        title: 'tA1'
      }, {
        id: '2',
        label: 'B2',
        title: 'tB2'
      }, {
        id: '3',
        label: 'C3',
        title: 'tC3'
      }],
      tray: function tray() {
        return React.createElement("div", {
          className: "outcomeTray"
        });
      },
      // eslint-disable-line react/display-name
      scope: 'scopeForTest',
      openOutcomePicker: sinon.spy(),
      removeAlignment: sinon.spy(),
      onUpdate: sinon.spy(),
      screenreaderNotification: sinon.spy()
    }, props);
  }

  it('renders a button with a11y components', function () {
    var wrapper = shallow(React.createElement(AlignmentButton, makeProps()), {
      disableLifecycleMethods: true
    });
    expect(wrapper.find('Button')).to.have.length(1);
    expect(wrapper.find('AccessibleContent')).to.have.length(1);
  });
  it('does not render an alignment button if readOnly is true', function () {
    var wrapper = shallow(React.createElement(AlignmentButton, makeProps({
      readOnly: true
    })), {
      disableLifecycleMethods: true
    });
    expect(wrapper.find('Button')).to.have.length(0);
  });
  it('does not render header if readOnly is true and no outcomes are aligned', function () {
    var wrapper = shallow(React.createElement(AlignmentButton, makeProps({
      readOnly: true,
      alignedOutcomes: []
    })), {
      disableLifecycleMethods: true
    });
    expect(wrapper.find('Text')).to.have.length(0);
    expect(wrapper.find('IconOutcomesLine')).to.have.length(0);
    expect(wrapper.find('AlignmentCount')).to.have.length(0);
  });
  it('calls openOutcomePicker when the button is pressed', function () {
    var props = makeProps();
    var wrapper = shallow(React.createElement(AlignmentButton, props), {
      disableLifecycleMethods: true
    });
    wrapper.find('Button').simulate('click');
    expect(props.openOutcomePicker.calledOnce).to.be.true;
  });
  it('renders AlignmentItems for each aligned outcome', function () {
    var wrapper = mount(React.createElement(AlignmentButton, makeProps()));
    expect(wrapper.find('AlignmentItem')).to.have.length(3);
  });
  it('renders an AlignmentCount object', function () {
    var wrapper = mount(React.createElement(AlignmentButton, makeProps()));
    expect(wrapper.find('AlignmentCount')).to.have.length(1);
  });
  it('meets a11y standards', function () {
    return checkA11y(React.createElement(AlignmentButton, makeProps()));
  });
  describe('when an alignment is removed', function () {
    it('calls the removeAlignment action with shouldUpdateArtifact equal to true', function () {
      var props = makeProps();
      var wrapper = mount(React.createElement(AlignmentButton, props));
      var first = wrapper.find('AlignmentItem').at(0);
      var remove = first.prop('removeAlignment');
      var outcome = first.prop('outcome');
      remove();
      expect(props.removeAlignment.getCall(0).args).to.include(outcome.id, true);
    });
    it('focuses on the previous alignment when the second alignment deleted', function () {
      var wrapper = mount(React.createElement(AlignmentButton, makeProps()));
      var first = wrapper.find('AlignmentItem').at(0);
      var next = wrapper.find('AlignmentItem').at(1);
      var focus = sinon.spy(first.instance(), 'focus');
      var remove = next.prop('removeAlignment');
      remove();
      expect(focus.calledOnce).to.be.true;
      expect(focus.calledWith()).to.be.true;
    });
    it('focuses on the next alignment when first alignment deleted', function () {
      var wrapper = mount(React.createElement(AlignmentButton, makeProps()));
      var first = wrapper.find('AlignmentItem').at(0);
      var next = wrapper.find('AlignmentItem').at(1);
      var remove = first.prop('removeAlignment');
      var focus = sinon.spy(next.instance(), 'focus');
      remove();
      expect(focus.calledOnce).to.be.true;
      expect(focus.calledWith()).to.be.true;
    });
  });
  describe('componentDidUpdate', function () {
    it('shifts focus to the |+Outcome| Button when alignments are removed', function (done) {
      var outcomes = {
        alignedOutcomes: [{
          id: '1',
          label: 'A1',
          title: 'tA1'
        }]
      };
      var wrapper = mount(React.createElement(AlignmentButton, makeProps(outcomes)));
      var trigger = wrapper.find('button').last();
      var focus = sinon.spy(trigger.instance(), 'focus');
      wrapper.setProps({
        alignedOutcomes: []
      }, function () {
        expect(wrapper.find('button')).to.have.length(1);
        expect(focus.calledOnce).to.be.true;
        expect(focus.calledWith()).to.be.true;
        done();
      });
    });
  });
});
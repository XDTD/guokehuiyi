import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import { createStore as reduxCreateStore, applyMiddleware, compose as reduxCompose } from 'redux';
import { combineReducers } from 'redux-immutable';
import thunkMiddleware from 'redux-thunk';
import { createLogger } from 'redux-logger';
import serviceMiddleware from '@instructure/redux-service-middleware';
import multireducer from 'multireducer/immutable';
import OutcomesService from '../services/OutcomesService';
import context from './context/reducers';
import config from './config/reducers';
import { loadFeatures } from './features/actions';
import { loadContext } from './context/actions';
import features from './features/reducers';
import OutcomePicker from './OutcomePicker/reducers';
import alignments from './alignments/reducers';
import report from './report/reducers';
import activePicker from './activePicker/reducers';
/**
 * The outcomes redux store is shared between components on a page.
 * The shape has the form:
 *    OutcomePicker:
 *    context:
 *    quiz:::99:
 *      alignments
 *    question:::100:
 *      alignments
 *    ...
 *
 * When a new component retrieves the store using getStore,
 * its scope (artifactType:::artifactId) is added to the
 * store's shape via `dynamicReducers` if necessary.
 */

export function makeScope(artifactType, artifactId) {
  return "".concat(artifactType, ":::").concat(artifactId);
}
export function makeUserScope(artifactType, artifactId, userUuid) {
  if (userUuid === null) {
    return null;
  }

  return "user::".concat(artifactType, ":").concat(artifactId, ":").concat(userUuid);
}
var dynamicReducers = {};

function createRootReducer() {
  return combineReducers(_objectSpread({
    context: context,
    features: features,
    activePicker: activePicker
  }, dynamicReducers));
}

function createStore() {
  var loggerMiddleware = createLogger({
    stateTransformer: function stateTransformer(state) {
      return state.toJS();
    }
  });
  var services = serviceMiddleware({
    outcomes: new OutcomesService()
  });
  var compose = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || reduxCompose;
  var dev = process.env.NODE_ENV === 'development';
  var devMiddleware = applyMiddleware(thunkMiddleware, loggerMiddleware, services);
  var prodMiddleware = applyMiddleware(thunkMiddleware, services);
  var middleware = dev ? devMiddleware : prodMiddleware;
  return reduxCreateStore(createRootReducer(), void 0, compose(middleware));
}

function addScopeToStore(store, key, host, jwt, contextUuid, artifactType, artifactId) {
  if (!dynamicReducers[key]) {
    dynamicReducers[key] = multireducer(combineReducers({
      // eslint-disable-line immutable/no-mutation
      config: config({
        host: host,
        jwt: jwt,
        contextUuid: contextUuid,
        artifactType: artifactType,
        artifactId: artifactId
      }),
      alignments: alignments,
      report: report,
      OutcomePicker: OutcomePicker
    }), key);
    store.replaceReducer(createRootReducer());
  }

  return store;
}

function initializeStore(store, _ref) {
  var host = _ref.host,
      jwt = _ref.jwt;
  store.dispatch(loadFeatures(host, jwt));
}

var store = null;
export function getStore(host, jwt, key, contextUuid, artifactType, artifactId) {
  if (!store) {
    store = createStore();
    initializeStore(store, {
      host: host,
      jwt: jwt
    });
  }

  store.dispatch(loadContext(host, jwt, contextUuid));
  addScopeToStore(store, key, host, jwt, contextUuid, artifactType, artifactId);
  return store;
}
import { expect } from 'chai';
import sinon from 'sinon';
import debounceLatestPromise from '../debouceLatestPromise';
describe('debounceLatestPromise', function () {
  var dispatch = sinon.stub().resolves(function () {
    return 'resolved';
  });
  var clock = null;
  beforeEach(function () {
    clock = sinon.useFakeTimers();
  });
  afterEach(function () {
    clock.restore();
    dispatch.resetHistory();
  });
  it('correctly debounces', function () {
    var debounced = debounceLatestPromise(function () {
      return dispatch.apply(void 0, arguments);
    }, 500);
    debounced('search #1');
    clock.tick(400);
    expect(dispatch).to.not.be.called;
    clock.tick(100);
    expect(dispatch).to.be.called.once;
    expect(dispatch).to.be.calledWith('search #1');
  });
  it('correctly debounces the latest promise', function () {
    var debounced = debounceLatestPromise(function () {
      return dispatch.apply(void 0, arguments);
    }, 500);
    debounced('search #1');
    debounced('search #2');
    clock.tick(500);
    expect(dispatch).to.be.called.once;
    expect(dispatch).to.be.calledWith('search #2');
  });
  it('calls the function again after the timeout passes', function () {
    var debounced = debounceLatestPromise(function () {
      return dispatch.apply(void 0, arguments);
    }, 500);
    debounced('search #1');
    clock.tick(500);
    debounced('search #2');
    clock.tick(500);
    expect(dispatch).to.be.called.calledTwice;
    expect(dispatch).to.be.calledWith('search #1');
    expect(dispatch).to.be.calledWith('search #2');
  });
});
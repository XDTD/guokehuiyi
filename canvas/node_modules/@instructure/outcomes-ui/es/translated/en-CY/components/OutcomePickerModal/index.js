import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import React from 'react';
import PropTypes from 'prop-types';
import { Button, CloseButton } from '@instructure/ui-buttons';
import { Text } from '@instructure/ui-text';
import { Heading } from '@instructure/ui-heading';
import { Modal } from '@instructure/ui-modal';
import OutcomePickerLoader from '../OutcomePickerLoader';
var ModalHeader = Modal.Header,
    ModalBody = Modal.Body,
    ModalFooter = Modal.Footer;

var OutcomePickerModal = /*#__PURE__*/function (_React$Component) {
  _inherits(OutcomePickerModal, _React$Component);

  function OutcomePickerModal() {
    _classCallCheck(this, OutcomePickerModal);

    return _possibleConstructorReturn(this, _getPrototypeOf(OutcomePickerModal).apply(this, arguments));
  }

  _createClass(OutcomePickerModal, [{
    key: "handleModalReady",
    value: function handleModalReady() {
      if (this.props.onModalOpen) {
        this.props.onModalOpen();
      }
    }
  }, {
    key: "handleModalClose",
    value: function handleModalClose() {
      if (this.props.trigger) {
        // can be null during testing
        this.props.trigger.focus();
      }

      if (this.props.onModalClose) {
        this.props.onModalClose();
      }
    }
  }, {
    key: "handleModalRequestClose",
    value: function handleModalRequestClose() {
      this.props.closeOutcomePicker();
    }
  }, {
    key: "handleModalExited",
    value: function handleModalExited() {
      this.props.resetOutcomePicker();
    }
  }, {
    key: "handleSubmit",
    value: function handleSubmit() {
      var _this = this;

      var _this$props = this.props,
          saveOutcomePickerAlignments = _this$props.saveOutcomePickerAlignments,
          onUpdate = _this$props.onUpdate;
      return saveOutcomePickerAlignments(onUpdate).then(function () {
        return _this.handleModalRequestClose();
      });
    }
  }, {
    key: "submitText",
    value: function submitText() {
      switch (this.props.outcomePickerState) {
        case 'loading':
        case 'choosing':
          if (this.props.anyOutcomeSelected) {
            return "Confirm Alignments";
          } else {
            return "Done";
          }

        case 'saving':
        case 'complete':
        default:
          return "OK";
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var disabled = this.props.outcomePickerState !== 'choosing';
      var open = this.props.outcomePickerState !== 'closed';
      var _this$props2 = this.props,
          outcomePickerState = _this$props2.outcomePickerState,
          outcomePicker = _this$props2.outcomePicker,
          loadOutcomePicker = _this$props2.loadOutcomePicker,
          setFocusedOutcome = _this$props2.setFocusedOutcome,
          scope = _this$props2.scope,
          artifactTypeName = _this$props2.artifactTypeName,
          displayMasteryDescription = _this$props2.displayMasteryDescription,
          displayMasteryPercentText = _this$props2.displayMasteryPercentText,
          screenreaderNotification = _this$props2.screenreaderNotification,
          liveRegion = _this$props2.liveRegion,
          mountNode = _this$props2.mountNode;
      return React.createElement("span", null, React.createElement(Modal, {
        open: open,
        shouldCloseOnDocumentClick: false,
        onOpen: function onOpen() {
          return _this2.handleModalReady();
        },
        onClose: function onClose() {
          return _this2.handleModalClose();
        },
        onDismiss: function onDismiss() {
          return _this2.handleModalRequestClose();
        },
        onExited: function onExited() {
          return _this2.handleModalExited();
        },
        transition: "fade",
        size: "fullscreen",
        label: "Align outcomes",
        zIndex: "9998",
        liveRegion: liveRegion,
        mountNode: mountNode,
        overflow: "fit",
        "data-automation": "outcomePicker__modal"
      }, React.createElement(ModalHeader, {
        "data-automation": "outcomePicker__modalHeader"
      }, React.createElement(CloseButton, {
        offset: "medium",
        onClick: function onClick() {
          return _this2.handleModalRequestClose();
        },
        placement: "end",
        variant: "icon"
      }, "Cancel"), React.createElement(Heading, null, React.createElement(Text, {
        size: "large"
      }, "Attached Outcomes"))), React.createElement(ModalBody, {
        padding: "0",
        "data-automation": "outcomePicker__modalBody"
      }, // We need to conditionally render OutcomePickerLoader here to
      // work around an instui bug:
      // https://instructure.atlassian.net/browse/INSTUI-1437. The bug
      // causes the OutcomePickerLoader to unmount, re-mount, and
      // unmount again when the modal is closed. When this happens,
      // OutcomePickerLoader triggers the loadOutcomePicker action,
      // which resets the modal state to 'open'.
      // TODO: remove `open && ` when INSTUI-1437 is fixed
      open && React.createElement(OutcomePickerLoader, {
        outcomePickerState: outcomePickerState,
        outcomePicker: outcomePicker,
        loadOutcomePicker: loadOutcomePicker,
        setFocusedOutcome: setFocusedOutcome,
        scope: scope,
        artifactTypeName: artifactTypeName,
        displayMasteryDescription: displayMasteryDescription,
        displayMasteryPercentText: displayMasteryPercentText,
        screenreaderNotification: screenreaderNotification
      })), React.createElement(ModalFooter, null, React.createElement(Button, {
        margin: "xxx-small",
        onClick: function onClick() {
          return _this2.handleModalRequestClose();
        },
        variant: "default",
        disabled: disabled,
        "data-automation": "outcomePicker__cancelButton"
      }, "Cancel"), React.createElement(Button, {
        margin: "xxx-small",
        onClick: function onClick() {
          return _this2.handleSubmit();
        },
        variant: "primary",
        disabled: disabled,
        "data-automation": "outcomePicker__submitButton"
      }, this.submitText()))));
    }
  }]);

  OutcomePickerModal.displayName = "OutcomePickerModal";
  return OutcomePickerModal;
}(React.Component);

OutcomePickerModal.propTypes = {
  outcomePickerState: PropTypes.string.isRequired,
  resetOutcomePicker: PropTypes.func.isRequired,
  closeOutcomePicker: PropTypes.func.isRequired,
  loadOutcomePicker: PropTypes.func.isRequired,
  setFocusedOutcome: PropTypes.func.isRequired,
  saveOutcomePickerAlignments: PropTypes.func.isRequired,
  outcomePicker: PropTypes.func.isRequired,
  onModalClose: PropTypes.func,
  onModalOpen: PropTypes.func,
  onUpdate: PropTypes.func,
  anyOutcomeSelected: PropTypes.bool.isRequired,
  trigger: PropTypes.object,
  scope: PropTypes.string.isRequired,
  artifactTypeName: PropTypes.string,
  displayMasteryDescription: PropTypes.bool,
  displayMasteryPercentText: PropTypes.bool,
  setSearchText: PropTypes.func.isRequired,
  screenreaderNotification: PropTypes.func,
  liveRegion: Modal.propTypes.liveRegion,
  mountNode: Modal.propTypes.mountNode
};
OutcomePickerModal.defaultProps = {
  onModalClose: null,
  onModalOpen: null,
  onUpdate: null,
  trigger: null,
  artifactTypeName: null,
  displayMasteryDescription: false,
  displayMasteryPercentText: false,
  screenreaderNotification: null,
  liveRegion: null,
  mountNode: null
};
export { OutcomePickerModal as default };
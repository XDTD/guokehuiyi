import { expect } from 'chai';
import sinon from 'sinon';
import { Map, fromJS } from 'immutable';
import { SET_OUTCOMES, SET_ROOT_OUTCOME_IDS, SET_ERROR, SET_SCORING_METHOD } from '../../../constants';
import createMockStore, { scopeActions } from '../../../test/createMockStore';
import * as actions from '../actions';
var scopedActions = scopeActions(actions);
var response = {
  outcomes: [{
    id: 1
  }, {
    id: 2
  }],
  root_ids: [1, 2]
};
var stateWithoutOutcomes = fromJS({
  scopeForTest: {
    config: {
      contextUuid: 'course_100'
    }
  }
});
var stateWithOutcomes = fromJS({
  context: {
    outcomes: {
      course_100: [{
        id: 1
      }]
    },
    rootOutcomeIds: {
      course_100: [1]
    }
  },
  scopeForTest: {
    config: {
      contextUuid: 'course_100'
    }
  }
});
describe('context/actions', function () {
  describe('setOutcomes', function () {
    it('creates an action', function () {
      var action = actions.setOutcomes([]);
      expect(action.type).to.equal(SET_OUTCOMES);
      expect(action.payload).to.deep.equal([]);
    });
  });
  describe('setRootOutcomeIds', function () {
    it('creates an action', function () {
      var action = actions.setRootOutcomeIds([]);
      expect(action.type).to.equal(SET_ROOT_OUTCOME_IDS);
      expect(action.payload).to.deep.equal([]);
    });
  });
  describe('setError', function () {
    it('creates an action', function () {
      var action = actions.setError('foo');
      expect(action.type).to.equal(SET_ERROR);
      expect(action.payload).to.deep.equal('foo');
    });
  });
  describe('setScoringMethod', function () {
    it('creates an action', function () {
      var payload = {
        id: 1,
        context_uuid: '',
        scoring_method: {}
      };
      var action = actions.setScoringMethod(payload);
      expect(action.type).to.equal(SET_SCORING_METHOD);
      expect(action.payload).to.deep.equal(payload);
    });
  });
  describe('loadOutcomes', function () {
    it('does not call any actions when outcomes already loaded', function () {
      var store = createMockStore(stateWithOutcomes);
      return store.dispatch(actions.loadRootOutcomes()).then(function () {
        expect(store.getActions()).to.have.length(0);
        return null;
      });
    });
    it('calls outcome service to load outcomes', function () {
      var service = {
        loadOutcomes: sinon.stub().returns(Promise.resolve(response))
      };
      var store = createMockStore(Map(), service);
      return store.dispatch(actions.loadRootOutcomes()).then(function () {
        expect(service.loadOutcomes.calledOnce).to.be.true;
        return null;
      });
    });
    it('dispatches setOutcomes on outcome service success', function () {
      var service = {
        loadOutcomes: sinon.stub().returns(Promise.resolve(response))
      };
      var store = createMockStore(stateWithoutOutcomes, service);
      return store.dispatch(actions.loadRootOutcomes()).then(function () {
        expect(store.getActions()).to.deep.include(scopedActions.setOutcomes({
          course_100: response.outcomes
        }));
        expect(store.getActions()[0].payload.root).to.be.present;
        return null;
      });
    });
    it('creates a root level outcome to store roots if root ids are present', function () {
      var service = {
        loadOutcomes: sinon.stub().returns(Promise.resolve(response))
      };
      var store = createMockStore(Map(), service);
      return store.dispatch(actions.loadRootOutcomes()).then(function () {
        expect(store.getActions()[0].payload.root).to.be.present;
        return null;
      });
    });
    it('does not create a root level outcome if root ids are not present', function () {
      var service = {
        loadOutcomes: sinon.stub().returns(Promise.resolve({
          outcomes: [{
            id: 1
          }, {
            id: 2
          }],
          root_ids: []
        }))
      };
      var store = createMockStore(Map(), service);
      return store.dispatch(actions.loadRootOutcomes()).then(function () {
        expect(store.getActions()[0].payload.root).not.to.be.present;
        return null;
      });
    });
    it('dispatches setRootOutcomeIds on outcome service success', function () {
      var service = {
        loadOutcomes: sinon.stub().returns(Promise.resolve(response))
      };
      var store = createMockStore(stateWithoutOutcomes, service);
      return store.dispatch(actions.loadRootOutcomes()).then(function () {
        expect(store.getActions()).to.deep.include(scopedActions.setRootOutcomeIds({
          course_100: response.root_ids
        }));
        return null;
      });
    });
    it('dispatches setError on outcome service failure', function () {
      var error = {
        message: 'foo bar baz'
      };
      var service = {
        loadOutcomes: sinon.stub().returns(Promise.reject(error))
      };
      var store = createMockStore(Map(), service);
      return store.dispatch(actions.loadRootOutcomes()).then(function () {
        expect(store.getActions()).to.have.length(2);
        expect(store.getActions()[1]).to.deep.equal(scopedActions.setError(error));
        return null;
      });
    });
  });
  describe('loadMoreOutcomes', function () {
    it('calls loadOutcomes for unloaded children', function () {
      var service = {
        loadOutcomes: sinon.stub().returns(Promise.resolve(response))
      };
      var store = createMockStore(stateWithOutcomes, service);
      return store.dispatch(actions.loadMoreOutcomes('1')).then(function () {
        expect(service.loadOutcomes.calledOnce).to.be.true;
        expect(service.loadOutcomes.args[0][3]).to.deep.equal(['1']);
        return null;
      });
    });
    it('adds its outcomes to the state', function () {
      var service = {
        loadOutcomes: sinon.stub().returns(Promise.resolve(response))
      };
      var store = createMockStore(stateWithOutcomes, service);
      return store.dispatch(actions.loadMoreOutcomes('1')).then(function () {
        expect(store.getActions()).to.deep.include(scopedActions.setOutcomes({
          course_100: response.outcomes
        }));
        return null;
      });
    });
    it('does not add its root ids to the state', function () {
      var service = {
        loadOutcomes: sinon.stub().returns(Promise.resolve(response))
      };
      var store = createMockStore(stateWithoutOutcomes, service);
      return store.dispatch(actions.loadMoreOutcomes('1')).then(function () {
        expect(store.getActions()).not.to.deep.include(scopedActions.setRootOutcomeIds({
          course_100: response.root_ids
        }));
        return null;
      });
    });
    it('dispatches setError on outcome service failure', function () {
      var error = {
        message: 'foo bar baz'
      };
      var service = {
        loadOutcomes: sinon.stub().returns(Promise.reject(error))
      };
      var store = createMockStore(Map(), service);
      return store.dispatch(actions.loadMoreOutcomes('12')).then(function () {
        expect(store.getActions()).to.have.length(2);
        expect(store.getActions()[1]).to.deep.equal(scopedActions.setError(error));
        return null;
      });
    });
  });
  describe('loadContext', function () {
    var response = {
      id: 1
    };
    var stateWithoutContext = fromJS({
      context: {
        contexts: {}
      }
    });
    var stateWithContext = fromJS({
      context: {
        contexts: {
          '1': {
            loading: false,
            data: {
              id: 1
            }
          }
        }
      }
    });
    var stateWithContextLoading = fromJS({
      context: {
        contexts: {
          '1': {
            loading: true
          }
        }
      }
    });
    it('calls getContext for unloaded children', function () {
      var service = {
        getContext: sinon.stub().returns(Promise.resolve(response))
      };
      var store = createMockStore(stateWithoutContext, service);
      return store.dispatch(actions.loadContext('host', 'jwt', '1')).then(function () {
        expect(service.getContext.calledOnce).to.be.true;
        expect(service.getContext.args[0][2]).to.equal('1');
        return null;
      });
    });
    it('adds its context to the state', function () {
      var service = {
        getContext: sinon.stub().returns(Promise.resolve(response))
      };
      var store = createMockStore(stateWithoutContext, service);
      return store.dispatch(actions.loadContext('host', 'jwt', '1')).then(function () {
        expect(store.getActions()).to.deep.include(scopedActions.setContext({
          '1': {
            loading: false,
            data: response
          }
        }));
        return null;
      });
    });
    it('does not calls service when its already loaded', function () {
      var service = {
        getContext: sinon.stub().returns(Promise.resolve(response))
      };
      var store = createMockStore(stateWithContext, service);
      return store.dispatch(actions.loadContext('host', 'jwt', '1')).then(function () {
        expect(store.getActions().length).to.be.equal(0);
        return null;
      });
    });
    it('does not calls service when its loading', function () {
      var service = {
        getContext: sinon.stub().returns(Promise.resolve(response))
      };
      var store = createMockStore(stateWithContextLoading, service);
      return store.dispatch(actions.loadContext('host', 'jwt', '1')).then(function () {
        expect(store.getActions().length).to.be.equal(0);
        return null;
      });
    });
    it('dispatches setError on service failure', function () {
      var error = {
        message: 'foo bar baz'
      };
      var service = {
        getContext: sinon.stub().returns(Promise.reject(error))
      };
      var store = createMockStore(Map(), service);
      return store.dispatch(actions.loadContext('host', 'jwt', '12')).then(function () {
        expect(store.getActions()).to.have.length(3);
        expect(store.getActions()[2]).to.deep.equal(scopedActions.setError(error));
        return null;
      });
    });
  });
});
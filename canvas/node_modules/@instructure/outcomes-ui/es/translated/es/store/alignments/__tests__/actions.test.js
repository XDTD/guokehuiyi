import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
var _arguments = arguments;
import { Map, fromJS } from 'immutable';
import { expect } from 'chai';
import sinon from 'sinon';
import { SET_ALIGNMENTS, VIEW_ALIGNMENT, CLOSE_ALIGNMENT, UPDATE_ALIGNMENT } from '../../../constants';
import createMockStore, { scopeActions } from '../../../test/createMockStore';
import * as actions from '../actions';
import { setError } from '../../../store/context/actions';
var scopedActions = scopeActions(_objectSpread({}, actions, {
  setError: setError
}));
describe('alignments/actions', function () {
  describe('setAlignments', function () {
    it('creates an action', function () {
      var action = actions.setAlignments([]);
      expect(action.type).to.equal(SET_ALIGNMENTS);
      expect(action.payload).to.deep.equal([]);
    });
  });
  describe('viewAlignment', function () {
    it('creates an action', function () {
      var action = actions.viewAlignmentAction(12);
      expect(action.type).to.equal(VIEW_ALIGNMENT);
      expect(action.payload).to.deep.equal(12);
    });
    it('dispatches viewAlignmentAction', function () {
      var service = {
        viewAlignmentAction: sinon.stub().returns(Promise.resolve())
      };
      var state = fromJS({
        scopeForTest: {
          alignments: {
            alignedOutcomes: [{
              id: 1,
              scoring_method: 'boom'
            }],
            alignmentSetId: 'badong'
          }
        }
      });
      var store = createMockStore(state, service);
      return store.dispatch(actions.viewAlignment(1)).then(function () {
        expect(store.getActions()).to.have.length(1);
        expect(store.getActions()[0]).to.deep.equal(scopedActions.viewAlignmentAction(1));
        return null;
      });
    });
    it('fetches an outcome and dispatches updateAlignment', function () {
      var full = {
        id: 1,
        scoring_method: 'boom'
      };
      var service = {
        getOutcome: sinon.stub().returns(Promise.resolve(full))
      };
      var state = fromJS({
        scopeForTest: {
          alignments: {
            alignedOutcomes: [{
              id: 1
            }],
            alignmentSetId: 'badong'
          }
        }
      });
      var store = createMockStore(state, service);
      return store.dispatch(actions.viewAlignment(1)).then(function () {
        expect(store.getActions()).to.have.length(3);
        expect(store.getActions()[0]).to.deep.equal(scopedActions.viewAlignmentAction(1));
        expect(store.getActions()[2]).to.deep.equal(scopedActions.updateAlignment({
          outcome: full
        }));
        return null;
      });
    });
  });
  describe('updateAlignment', function () {
    it('creates an action', function () {
      var action = actions.updateAlignment(12);
      expect(action.type).to.equal(UPDATE_ALIGNMENT);
      expect(action.payload).to.deep.equal(12);
    });
  });
  describe('closeAlignment', function () {
    it('creates an action', function () {
      var action = actions.closeAlignment();
      expect(action.type).to.equal(CLOSE_ALIGNMENT);
    });
  });
  describe('updateAlignments', function () {
    it('dispatches setAlignments when called', function () {
      var alignments = [{
        id: '1'
      }, {
        id: '2'
      }];
      var service = {
        getAlignments: sinon.stub().returns(Promise.resolve(alignments))
      };
      var store = createMockStore(Map(), service);
      return store.dispatch(actions.updateAlignments('hexadecimal', alignments)).then(function () {
        expect(store.getActions()).to.have.length(1);
        expect(store.getActions()[0]).to.deep.equal(scopedActions.setAlignments({
          guid: 'hexadecimal',
          outcomes: alignments
        }));
        return null;
      });
    });
    it('fires an updateCallback function if provided', function () {
      var alignments = [{
        id: '1'
      }, {
        id: '2'
      }];
      var callback = sinon.stub().returns(_arguments);
      var service = {
        getAlignments: sinon.stub().returns(Promise.resolve(alignments))
      };
      var store = createMockStore(Map(), service);
      return store.dispatch(actions.updateAlignments('hexadecimal', alignments, callback)).then(function () {
        expect(callback.calledOnce).to.be.true;
        expect(callback.calledWith({
          guid: 'hexadecimal',
          outcomes: alignments
        })).to.be.true;
        return null;
      });
    });
  });
  describe('loadAlignments', function () {
    it('responds with a null guid and empty outcome array if the alignmentSetId does not match the scope', function () {
      var store = createMockStore(fromJS({
        scopeForTest: {
          alignments: {
            alignedOutcomes: [{
              id: '1'
            }],
            alignmentSetId: 'badong'
          }
        }
      }));
      return store.dispatch(actions.loadAlignments('gnodab')).then(function () {
        expect(store.getActions()[0]).to.deep.equal(scopedActions.setAlignments({
          guid: null,
          outcomes: []
        }));
        return null;
      });
    });
    it('responds with a null guid and empty outcome array if there is no alignment set id', function () {
      var service = {
        clearAlignmentSet: sinon.stub().returns(Promise.resolve()),
        getAlignments: sinon.stub().returns(Promise.resolve())
      };
      var store = createMockStore(fromJS({
        scopeForTest: {
          alignments: {
            alignedOutcomes: [{
              id: '1'
            }]
          }
        }
      }), service);
      return store.dispatch(actions.loadAlignments(null)).then(function () {
        expect(store.getActions()[0]).to.deep.equal(scopedActions.setAlignments({
          guid: null,
          outcomes: []
        }));
        return null;
      });
    });
    it('calls outcome service to load alignments', function () {
      var service = {
        getAlignments: sinon.stub().returns(Promise.resolve())
      };
      var store = createMockStore(Map(), service);
      return store.dispatch(actions.loadAlignments('hexadecimal')).then(function () {
        expect(service.getAlignments.calledOnce).to.be.true;
        return null;
      });
    });
    it('dispatches setError on outcome service failure', function () {
      var error = {
        message: 'foo bar baz'
      };
      var service = {
        getAlignments: sinon.stub().returns(Promise.reject(error))
      };
      var store = createMockStore(Map(), service);
      return store.dispatch(actions.loadAlignments('hexadecimal')).then(function () {
        expect(store.getActions()).to.have.length(3);
        expect(store.getActions()[2]).to.deep.equal(scopedActions.setError(error));
        return null;
      });
    });
  });
  describe('loadArtifact', function () {
    it('calls outcome service to load artfiact', function () {
      var response = {
        guid: 'guid',
        outcomes: [{
          id: '1'
        }]
      };
      var service = {
        getArtifact: sinon.stub().returns(Promise.resolve(response))
      };
      var store = createMockStore(Map(), service);
      return store.dispatch(actions.loadArtifact({
        artifactType: 'type',
        artifactId: '1'
      })).then(function () {
        expect(store.getActions()).to.have.length(3);
        expect(service.getArtifact.calledOnce).to.be.true;
        expect(store.getActions()[2]).to.deep.equal(scopedActions.setAlignments(response));
        return null;
      });
    });
    it('dispatches setError on outcome service failure', function () {
      var error = {
        message: 'foo bar baz'
      };
      var service = {
        getArtifact: sinon.stub().returns(Promise.reject(error))
      };
      var store = createMockStore(Map(), service);
      return store.dispatch(actions.loadArtifact({
        artifactType: '',
        artifactId: ''
      })).then(function () {
        expect(store.getActions()).to.have.length(3);
        expect(store.getActions()[2]).to.deep.equal(scopedActions.setError(error));
        return null;
      });
    });
  });
  describe('removeAlignment', function () {
    it('calls outcomes service to create new alignment set', function () {
      var service = {
        createAlignmentSet: sinon.stub().returns(Promise.resolve())
      };
      var store = createMockStore(fromJS({
        scopeForTest: {
          alignments: {
            alignedOutcomes: [{
              id: '1'
            }, {
              id: '12'
            }]
          }
        }
      }), service);
      return store.dispatch(actions.removeAlignment('12')).then(function () {
        expect(service.createAlignmentSet.calledOnce).to.be.true;
        expect(service.createAlignmentSet.calledWith([]));
        return null;
      });
    });
    it('responds with a null guid and empty outcome array if no alignments remain', function () {
      var service = {
        clearAlignmentSet: sinon.stub().returns(Promise.resolve())
      };
      var store = createMockStore(fromJS({
        scopeForTest: {
          alignments: {
            alignedOutcomes: [{
              id: '1'
            }]
          }
        }
      }), service);
      return store.dispatch(actions.removeAlignment('1')).then(function () {
        expect(store.getActions()[0]).to.deep.equal(scopedActions.setAlignments({
          guid: null,
          outcomes: []
        }));
        return null;
      });
    });
    it('dispatches setError on outcome service failure', function () {
      var error = {
        message: 'baz bar foo'
      };
      var service = {
        createAlignmentSet: sinon.stub().returns(Promise.reject(error))
      };
      var store = createMockStore(fromJS({
        scopeForTest: {
          alignments: {
            alignedOutcomes: [{
              id: '12'
            }]
          }
        }
      }), service);
      return store.dispatch(actions.removeAlignment('1')).then(function () {
        expect(store.getActions()).to.have.length(2);
        expect(store.getActions()[1]).to.deep.equal(scopedActions.setError(error));
        return null;
      });
    });
    it('calls upsertArtifact if shouldUpdateArtifact is true', function () {
      var response = {
        guid: 'my-guid-1',
        outcomes: [{
          id: '1'
        }]
      };
      var service = {
        upsertArtifact: sinon.stub().returns(Promise.resolve(response))
      };
      var store = createMockStore(fromJS({
        scopeForTest: {
          alignments: {
            alignedOutcomes: [{
              id: '1'
            }, {
              id: '12'
            }]
          }
        }
      }), service);
      return store.dispatch(actions.removeAlignment('12', null, true)).then(function () {
        expect(service.upsertArtifact.calledOnce).to.be.true;
        expect(store.getActions()[0].payload.args.slice(-1)).to.deep.equal([['1']]);
        expect(store.getActions()).to.deep.include(scopedActions.setAlignments(response));
        return null;
      });
    });
  });
});
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import { expect } from 'chai';
import React from 'react';
import sinon from 'sinon';
import { shallow, mount } from 'enzyme';
import OutcomePicker from '../index';
import OutcomeViewModal from '../../OutcomeViewModal';
import OutcomeTree from '../../OutcomeTree';
import checkA11y from '../../../test/checkA11y';
describe('OutcomePicker', function () {
  function makeProps() {
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Object.assign({
      focusedOutcome: null,
      selectedOutcomes: [{
        id: '2'
      }, {
        id: '3'
      }],
      hasOutcomes: true,
      isOutcomeSelected: sinon.stub().returns(false),
      deselectOutcomeIds: sinon.spy(),
      setFocusedOutcome: sinon.spy(),
      setActiveCollection: sinon.spy(),
      setSearchLoading: sinon.spy(),
      setSearchEntries: sinon.spy(),
      updateSearchText: sinon.spy(),
      updateSearchPage: sinon.spy(),
      searchText: '',
      searchPage: 1,
      searchTotal: 0,
      searchEntries: [],
      treeView: OutcomeTree,
      scope: 'scopeForTest',
      artifactTypeName: '',
      isSearchLoading: false
    }, props);
  }

  it('passes correct params to OutcomeTags component', function () {
    var wrapper = shallow(React.createElement(OutcomePicker, makeProps()), {
      disableLifecycleMethods: true
    });
    expect(wrapper.find('OutcomeTags').prop('outcomes')).to.deep.equal([{
      id: '2'
    }, {
      id: '3'
    }]);
  });
  it('has a screen reader content for selected outcomes', function () {
    var wrapper = shallow(React.createElement(OutcomePicker, makeProps()), {
      disableLifecycleMethods: true
    });
    expect(wrapper.find('ScreenReaderContent')).to.have.length(1);
  });
  it('shows an outcome when focused', function () {
    var focusedOutcome = {
      id: 'TEST-1',
      guid: 'GUID',
      label: 'Test outcome',
      title: 'Testing'
    };
    var wrapper = shallow(React.createElement(OutcomePicker, makeProps({
      focusedOutcome: focusedOutcome
    })), {
      disableLifecycleMethods: true
    });
    expect(wrapper.find(OutcomeViewModal)).to.have.length(1);
  });
  it('calls setFocusedOutcome when closeAlignment is called', function () {
    var focusedOutcome = {
      id: 'TEST-1',
      guid: 'GUID',
      label: 'Test outcome',
      title: 'Testing'
    };
    var props = makeProps({
      focusedOutcome: focusedOutcome
    });
    var wrapper = shallow(React.createElement(OutcomePicker, props), {
      disableLifecycleMethods: true
    });
    wrapper.find(OutcomeViewModal).prop('closeAlignment')();
    expect(props.setFocusedOutcome.calledOnce).to.be.true;
  });
  it('shows the proper billboard when there are no outcomes present', function () {
    var props = makeProps({
      hasOutcomes: false
    });
    var wrapper = shallow(React.createElement(OutcomePicker, props), {
      disableLifecycleMethods: true
    });
    expect(wrapper.find('Billboard')).to.have.length(1);
    expect(wrapper.find('Billboard').prop('heading')).to.equal('There are no outcomes');
  });
  it('renders search bar', function () {
    var wrapper = shallow(React.createElement(OutcomePicker, makeProps()), {
      disableLifecycleMethods: true
    });
    expect(wrapper.find('SearchInput')).to.have.length(1);
  });
  it('renders OutcomeTree when no search text is present', function () {
    var props = makeProps();
    var wrapper = shallow(React.createElement(OutcomePicker, props), {
      disableLifecycleMethods: true
    });
    var tree = wrapper.find('OutcomeTree');
    expect(tree).to.have.length(1);
    expect(tree.prop('scope')).to.equal(props.scope);
  });
  it('shows only search results when searchText is present', function () {
    var props = makeProps({
      searchText: 'out'
    });
    var wrapper = shallow(React.createElement(OutcomePicker, props), {
      disableLifecycleMethods: true
    });
    expect(wrapper.find('SearchResults')).to.have.length(1);
    expect(wrapper.find('OutcomeTree')).to.have.length(0);
  });
  it('resets focus on update', function () {
    var wrapper = mount(React.createElement(OutcomePicker, makeProps()));
    wrapper.setProps(_objectSpread({}, makeProps({
      activeCollection: {
        id: '101'
      }
    })));
    expect(wrapper.getDOMNode().contains(document.activeElement));
  });
  it('meets a11y standards', function () {
    return checkA11y(React.createElement(OutcomePicker, makeProps()));
  });
  it('correctly calls updateSearchText when search text is changed', function () {
    var props = makeProps();
    var wrapper = mount(React.createElement(OutcomePicker, props));
    var onChange = wrapper.find('TextInput').prop('onChange');
    onChange('', 'abc');
    expect(props.updateSearchText).to.be.called.once;
    expect(props.updateSearchText).to.be.calledWith('abc');
  });
});
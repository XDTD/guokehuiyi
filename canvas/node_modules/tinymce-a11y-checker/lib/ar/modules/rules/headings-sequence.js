import formatMessage from "../format-message";
import { changeTag } from "../utils/dom";
/* Headings Sequence rule
 * this rule is ensuring that heading tags (H1-H6) are layed out in sequential
 * order for organizing your site.
 *
 * this rule only looks at H2-H6 headings. all other tags pass.
 * this rule will walk 'up-down' the dom to find the heading tag that is
 * laid out previous to the heading tag being checked.
 * this rule will see if the heading tag number of the previous heading is
 * one more than one less than it's own heading tag and will fail if so
 * this rule will check to see if there is no previous heading tag and will
 * fail the test if so
 */

const isHtag = elem => {
  const allHTags = {
    H1: true,
    H2: true,
    H3: true,
    H4: true,
    H5: true,
    H6: true
  };
  return elem && allHTags[elem.tagName] === true;
}; // gets the H tag that is furthest down in the tree from elem(inclusive)


const getHighestOrderHForElem = elem => {
  const allHForElem = Array.prototype.slice.call(elem.querySelectorAll("H1,H2,H3,H4,H5,H6"));

  if (allHForElem.length > 0) {
    return allHForElem.reverse()[0];
  }

  if (isHtag(elem)) {
    return elem;
  }

  return void 0;
}; // gets all siblings of elem that come before the elem ordered by nearest to
// elem


const getPrevSiblings = elem => {
  let ret = [];

  if (!elem || !elem.parentElement || !elem.parentElement.children) {
    return ret;
  }

  const sibs = elem.parentElement.children;

  for (var i = 0; i < sibs.length; i++) {
    if (sibs[i] === elem) {
      break;
    }

    ret.unshift(sibs[i]);
  }

  return ret;
};

const searchPrevSiblings = elem => {
  const sibs = getPrevSiblings(elem);
  let ret;

  for (let i = 0; i < sibs.length; i++) {
    ret = getHighestOrderHForElem(sibs[i]);

    if (ret) {
      break;
    }
  }

  return ret;
};

const _walkUpTree = elem => {
  let ret;

  if (!elem || elem.tagName === "BODY") {
    return void 0;
  }

  if (isHtag(elem)) {
    return elem;
  }

  ret = searchPrevSiblings(elem);

  if (!ret) {
    ret = _walkUpTree(elem.parentElement);
  }

  return ret;
};

const walkUpTree = elem => {
  let ret = searchPrevSiblings(elem);

  if (!ret) {
    ret = _walkUpTree(elem.parentElement);
  }

  return ret;
};

const getPriorHeading = elem => {
  return walkUpTree(elem);
}; // a valid prior H tag is greater or equal to one less than current


const getValidHeadings = elem => {
  const hNum = +elem.tagName.substring(1);
  const ret = {};

  for (var i = hNum - 1; i <= 6; i++) {
    ret[`H${i}`] = true;
  }

  return ret;
};

export default {
  id: "headings-sequence",
  test: elem => {
    const testTags = {
      H2: true,
      H3: true,
      H4: true,
      H5: true,
      H6: true
    };

    if (testTags[elem.tagName] !== true) {
      return true;
    }

    const validHeadings = getValidHeadings(elem);
    const priorHeading = getPriorHeading(elem);

    if (priorHeading) {
      return validHeadings[priorHeading.tagName];
    }

    return true;
  },
  data: elem => {
    return {
      action: "nothing"
    };
  },
  form: () => [{
    label: "\u0625\u062C\u0631\u0627\u0621 \u0645\u0642\u0631\u0631 \u0627\u062A\u062E\u0627\u0630\u0647:",
    dataKey: "action",
    options: [["nothing", "\u062A\u0631\u0643 \u0643\u0645\u0627 \u0647\u0648"], ["elem", "\u0625\u0635\u0644\u0627\u062D \u0647\u064A\u0643\u0644 \u0627\u0644\u0639\u0646\u0648\u0627\u0646"], ["modify", "\u0625\u0632\u0627\u0644\u0629 \u0646\u0645\u0637 \u0627\u0644\u0639\u0646\u0648\u0627\u0646"]]
  }],
  update: (elem, data) => {
    if (!data || !data.action || data.action === "nothing") {
      return elem;
    }

    switch (data.action) {
      case "elem":
        {
          const priorH = getPriorHeading(elem);
          const hIdx = priorH ? +priorH.tagName.substring(1) : 0;
          return changeTag(elem, `H${hIdx + 1}`);
        }

      case "modify":
        {
          return changeTag(elem, "p");
        }
    }
  },
  message: () => "\u064A\u062C\u0628 \u0623\u0644\u0627 \u064A\u062A\u0645 \u062A\u062C\u0627\u0648\u0632 \u0645\u0633\u062A\u0648\u064A\u0627\u062A \u0627\u0644\u0639\u0646\u0648\u0627\u0646.",
  why: () => "\u064A\u062A\u0635\u0641\u062D \u0627\u0644\u0645\u0633\u062A\u062E\u062F\u0645\u0648\u0646 \u0627\u0644\u0630\u064A\u0646 \u064A\u062A\u0645\u062A\u0639\u0648\u0646 \u0628\u0627\u0644\u0642\u062F\u0631\u0629 \u0639\u0644\u0649 \u0627\u0644\u0625\u0628\u0635\u0627\u0631 \u0635\u0641\u062D\u0627\u062A \u0627\u0644\u0648\u064A\u0628 \u0628\u0634\u0643\u0644 \u0633\u0631\u064A\u0639\u060C \u0628\u062D\u062B\u064B\u0627 \u0639\u0646 \u0639\u0646\u0627\u0648\u064A\u0646 \u0643\u0628\u064A\u0631\u0629 \u0623\u0648 \u0628\u062E\u0637 \u0639\u0631\u064A\u0636. \u0648\u064A\u0639\u062A\u0645\u062F \u0645\u0633\u062A\u062E\u062F\u0645\u0648 \u0642\u0627\u0631\u0626\u0629 \u0627\u0644\u0634\u0627\u0634\u0629 \u0639\u0644\u0649 \u0627\u0644\u0631\u0624\u0648\u0633 \u0644\u0641\u0647\u0645 \u0627\u0644\u0633\u064A\u0627\u0642. \u064A\u062C\u0628 \u0623\u0646 \u062A\u0648\u0638\u0641 \u0627\u0644\u0631\u0624\u0648\u0633 \u0627\u0644\u0628\u0646\u064A\u0629 \u0627\u0644\u0645\u0644\u0627\u0626\u0645\u0629.",
  link: "https://www.w3.org/TR/WCAG20-TECHS/G141.html",
  linkText: () => "\u0645\u0639\u0631\u0641\u0629 \u0627\u0644\u0645\u0632\u064A\u062F \u0639\u0646 \u062A\u0646\u0638\u064A\u0645 \u0639\u0646\u0627\u0648\u064A\u0646 \u0627\u0644\u0635\u0641\u062D\u0627\u062A"
};
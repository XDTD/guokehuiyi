import formatMessage from "../format-message";
import { changeTag } from "../utils/dom";
/* Headings Sequence rule
 * this rule is ensuring that heading tags (H1-H6) are layed out in sequential
 * order for organizing your site.
 *
 * this rule only looks at H2-H6 headings. all other tags pass.
 * this rule will walk 'up-down' the dom to find the heading tag that is
 * laid out previous to the heading tag being checked.
 * this rule will see if the heading tag number of the previous heading is
 * one more than one less than it's own heading tag and will fail if so
 * this rule will check to see if there is no previous heading tag and will
 * fail the test if so
 */

const isHtag = elem => {
  const allHTags = {
    H1: true,
    H2: true,
    H3: true,
    H4: true,
    H5: true,
    H6: true
  };
  return elem && allHTags[elem.tagName] === true;
}; // gets the H tag that is furthest down in the tree from elem(inclusive)


const getHighestOrderHForElem = elem => {
  const allHForElem = Array.prototype.slice.call(elem.querySelectorAll("H1,H2,H3,H4,H5,H6"));

  if (allHForElem.length > 0) {
    return allHForElem.reverse()[0];
  }

  if (isHtag(elem)) {
    return elem;
  }

  return void 0;
}; // gets all siblings of elem that come before the elem ordered by nearest to
// elem


const getPrevSiblings = elem => {
  let ret = [];

  if (!elem || !elem.parentElement || !elem.parentElement.children) {
    return ret;
  }

  const sibs = elem.parentElement.children;

  for (var i = 0; i < sibs.length; i++) {
    if (sibs[i] === elem) {
      break;
    }

    ret.unshift(sibs[i]);
  }

  return ret;
};

const searchPrevSiblings = elem => {
  const sibs = getPrevSiblings(elem);
  let ret;

  for (let i = 0; i < sibs.length; i++) {
    ret = getHighestOrderHForElem(sibs[i]);

    if (ret) {
      break;
    }
  }

  return ret;
};

const _walkUpTree = elem => {
  let ret;

  if (!elem || elem.tagName === "BODY") {
    return void 0;
  }

  if (isHtag(elem)) {
    return elem;
  }

  ret = searchPrevSiblings(elem);

  if (!ret) {
    ret = _walkUpTree(elem.parentElement);
  }

  return ret;
};

const walkUpTree = elem => {
  let ret = searchPrevSiblings(elem);

  if (!ret) {
    ret = _walkUpTree(elem.parentElement);
  }

  return ret;
};

const getPriorHeading = elem => {
  return walkUpTree(elem);
}; // a valid prior H tag is greater or equal to one less than current


const getValidHeadings = elem => {
  const hNum = +elem.tagName.substring(1);
  const ret = {};

  for (var i = hNum - 1; i <= 6; i++) {
    ret[`H${i}`] = true;
  }

  return ret;
};

export default {
  id: "headings-sequence",
  test: elem => {
    const testTags = {
      H2: true,
      H3: true,
      H4: true,
      H5: true,
      H6: true
    };

    if (testTags[elem.tagName] !== true) {
      return true;
    }

    const validHeadings = getValidHeadings(elem);
    const priorHeading = getPriorHeading(elem);

    if (priorHeading) {
      return validHeadings[priorHeading.tagName];
    }

    return true;
  },
  data: elem => {
    return {
      action: "nothing"
    };
  },
  form: () => [{
    label: "\u0427\u0442\u043E \u043D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0441\u0434\u0435\u043B\u0430\u0442\u044C:",
    dataKey: "action",
    options: [["nothing", "\u041E\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u043A\u0430\u043A \u0435\u0441\u0442\u044C"], ["elem", "\u0418\u0441\u043F\u0440\u0430\u0432\u0438\u0442\u044C \u0438\u0435\u0440\u0430\u0440\u0445\u0438\u044E \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u043E\u0432"], ["modify", "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0441\u0442\u0438\u043B\u044C \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u0430"]]
  }],
  update: (elem, data) => {
    if (!data || !data.action || data.action === "nothing") {
      return elem;
    }

    switch (data.action) {
      case "elem":
        {
          const priorH = getPriorHeading(elem);
          const hIdx = priorH ? +priorH.tagName.substring(1) : 0;
          return changeTag(elem, `H${hIdx + 1}`);
        }

      case "modify":
        {
          return changeTag(elem, "p");
        }
    }
  },
  message: () => "\u0423\u0440\u043E\u0432\u043D\u0438 \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u043E\u0432 \u043D\u0435 \u0434\u043E\u043B\u0436\u043D\u044B \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0430\u0442\u044C\u0441\u044F.",
  why: () => "\u0417\u0440\u044F\u0447\u0438\u0435 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u0438 \u0431\u044B\u0441\u0442\u0440\u043E \u043F\u0440\u043E\u0441\u043C\u0430\u0442\u0440\u0438\u0432\u0430\u044E\u0442 \u0432\u0435\u0431-\u0441\u0442\u0440\u0430\u043D\u0438\u0446\u044B \u0432 \u043F\u043E\u0438\u0441\u043A\u0430\u0445 \u043A\u0440\u0443\u043F\u043D\u044B\u0445 \u0438\u043B\u0438 \u043F\u043E\u043B\u0443\u0436\u0438\u0440\u043D\u044B\u0445 \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u043E\u0432. \u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u0438 \u044D\u043A\u0440\u0430\u043D\u043D\u044B\u0445 \u0434\u0438\u043A\u0442\u043E\u0440\u043E\u0432 \u043F\u043E\u043B\u0430\u0433\u0430\u044E\u0442\u0441\u044F \u043D\u0430 \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u0438 \u0434\u043B\u044F \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u0443\u0430\u043B\u044C\u043D\u043E\u0433\u043E \u043F\u043E\u043D\u0438\u043C\u0430\u043D\u0438\u044F. \u0417\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u0438 \u0434\u043E\u043B\u0436\u043D\u044B \u0438\u043C\u0435\u0442\u044C \u043D\u0430\u0434\u043B\u0435\u0436\u0430\u0449\u0443\u044E \u0441\u0442\u0440\u0443\u043A\u0442\u0443\u0440\u0443.",
  link: "https://www.w3.org/TR/WCAG20-TECHS/G141.html",
  linkText: () => "\u0423\u0437\u043D\u0430\u0442\u044C \u0431\u043E\u043B\u044C\u0448\u0435 \u043E\u0431 \u043E\u0440\u0433\u0430\u043D\u0438\u0437\u0430\u0446\u0438\u0438 \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u043E\u0432 \u0441\u0442\u0440\u0430\u043D\u0438\u0446"
};
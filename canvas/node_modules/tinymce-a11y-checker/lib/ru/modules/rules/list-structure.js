import formatMessage from "../format-message";
/**
 * Handles:
 * * list item
 * - list item
 * 1. list item
 * 1) list item
 * i. list item
 * a. list Item
 */

const orderedChars = `[A-Z]+|[a-z]+|[0-9]+`;
const bulletMarkers = ["*", "-"].map(c => "\\" + c).join("|");
const orderedMarkers = [".", ")"].map(c => "\\" + c).join("|");
const listLikeRegex = new RegExp(`^\\s*(?:(?:[${bulletMarkers}])|(?:(${orderedChars})[${orderedMarkers}]))\\s+`);

const isTextList = elem => elem.tagName === "P" && listLikeRegex.test(elem.textContent);

const cleanListItem = elem => {
  if (elem.nodeType === Node.TEXT_NODE) {
    elem.textContent = elem.textContent.replace(listLikeRegex, "");
    return true;
  }

  for (let childElement of elem.childNodes) {
    let found = cleanListItem(childElement);
    if (found) return true;
  }

  return false;
};

const moveContents = (from, to) => {
  while (from.firstChild) to.appendChild(from.firstChild);
};

const splitParagraphsByBreak = paragraph => {
  let appended = [];
  let child = paragraph.firstChild;

  while (child) {
    let currentParent = appended[appended.length - 1];

    if (child.tagName === "BR") {
      appended.push(document.createElement("p"));
      child = child.nextSibling;
      continue;
    }

    if (currentParent) currentParent.appendChild(child);
    child = child.nextSibling;
  }

  const nextNode = paragraph.nextSibling;
  appended.forEach(newParagraph => {
    paragraph.parentNode.insertBefore(newParagraph, nextNode);
  });
};

export default {
  id: "list-structure",
  test: function (elem) {
    const isList = isTextList(elem);
    const isFirst = elem.previousElementSibling ? !isTextList(elem.previousElementSibling) : true;
    return !(isList && isFirst);
  },
  data: elem => {
    const match = elem.textContent.match(listLikeRegex);
    return {
      orderedStart: match[1] ? match[1] : null,
      formatAsList: false
    };
  },
  form: () => [{
    label: "\u0424\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0432 \u0432\u0438\u0434\u0435 \u0441\u043F\u0438\u0441\u043A\u0430",
    checkbox: true,
    dataKey: "formatAsList"
  }],
  update: function (elem, data) {
    const rootElem = elem.parentNode;

    if (data.formatAsList) {
      const isOrdered = Boolean(data.orderedStart);
      const listContainer = document.createElement(isOrdered ? "ol" : "ul");

      if (isOrdered) {
        listContainer.setAttribute("type", data.orderedStart);
        listContainer.setAttribute("start", data.orderedStart);
      }

      let cursor = elem;

      while (cursor) {
        if (!isTextList(cursor)) break;
        const nextIsOrdered = Boolean(cursor.textContent.match(listLikeRegex)[1]);
        if (isOrdered !== nextIsOrdered) break;
        splitParagraphsByBreak(cursor);
        const li = document.createElement("li");
        listContainer.appendChild(li);
        moveContents(cursor, li);
        let nextSibling = cursor.nextElementSibling; // Remove the now empty siblings
        // Skip elem because elem is replaced later.

        if (cursor !== elem) cursor.parentNode.removeChild(cursor);
        cursor = nextSibling;
        cleanListItem(li);
      }

      rootElem.replaceChild(listContainer, elem);
      return listContainer;
    }

    return elem;
  },
  rootNode: function (elem) {
    return elem.parentNode;
  },
  message: () => "\u0421\u043F\u0438\u0441\u043A\u0438 \u0434\u043E\u043B\u0436\u043D\u044B \u0431\u044B\u0442\u044C \u043E\u0442\u0444\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u044B \u0432 \u0432\u0438\u0434\u0435 \u0441\u043F\u0438\u0441\u043A\u043E\u0432.",
  why: () => "\u041A\u043E\u0433\u0434\u0430 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442\u0441\u044F \u0440\u0430\u0437\u043C\u0435\u0442\u043A\u0430, \u043A\u043E\u0442\u043E\u0440\u0430\u044F \u0432\u0438\u0437\u0443\u0430\u043B\u044C\u043D\u043E \u0444\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u0443\u0435\u0442 \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B \u0432 \u0432\u0438\u0434\u0435 \u0441\u043F\u0438\u0441\u043A\u0430, \u043D\u043E \u043D\u0435 \u0443\u043A\u0430\u0437\u044B\u0432\u0430\u0435\u0442 \u043D\u0430 \u043E\u0442\u043D\u043E\u0448\u0435\u043D\u0438\u0435 \u0441\u043F\u0438\u0441\u043A\u0430, \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u0438 \u043C\u043E\u0433\u0443\u0442 \u0438\u0441\u043F\u044B\u0442\u044B\u0432\u0430\u0442\u044C \u0442\u0440\u0443\u0434\u043D\u043E\u0441\u0442\u0438 \u043F\u0440\u0438 \u043F\u0440\u043E\u0441\u043C\u043E\u0442\u0440\u0435 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0438.",
  link: "https://www.w3.org/TR/2016/NOTE-WCAG20-TECHS-20161007/H48",
  linkText: () => "\u0423\u0437\u043D\u0430\u0442\u044C \u0431\u043E\u043B\u044C\u0448\u0435 \u043E\u0431 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0438 \u0441\u043F\u0438\u0441\u043A\u043E\u0432"
};
import formatMessage from "../format-message";
/**
 * Handles:
 * * list item
 * - list item
 * 1. list item
 * 1) list item
 * i. list item
 * a. list Item
 */

const orderedChars = `[A-Z]+|[a-z]+|[0-9]+`;
const bulletMarkers = ["*", "-"].map(c => "\\" + c).join("|");
const orderedMarkers = [".", ")"].map(c => "\\" + c).join("|");
const listLikeRegex = new RegExp(`^\\s*(?:(?:[${bulletMarkers}])|(?:(${orderedChars})[${orderedMarkers}]))\\s+`);

const isTextList = elem => elem.tagName === "P" && listLikeRegex.test(elem.textContent);

const cleanListItem = elem => {
  if (elem.nodeType === Node.TEXT_NODE) {
    elem.textContent = elem.textContent.replace(listLikeRegex, "");
    return true;
  }

  for (let childElement of elem.childNodes) {
    let found = cleanListItem(childElement);
    if (found) return true;
  }

  return false;
};

const moveContents = (from, to) => {
  while (from.firstChild) to.appendChild(from.firstChild);
};

const splitParagraphsByBreak = paragraph => {
  let appended = [];
  let child = paragraph.firstChild;

  while (child) {
    let currentParent = appended[appended.length - 1];

    if (child.tagName === "BR") {
      appended.push(document.createElement("p"));
      child = child.nextSibling;
      continue;
    }

    if (currentParent) currentParent.appendChild(child);
    child = child.nextSibling;
  }

  const nextNode = paragraph.nextSibling;
  appended.forEach(newParagraph => {
    paragraph.parentNode.insertBefore(newParagraph, nextNode);
  });
};

export default {
  id: "list-structure",
  test: function (elem) {
    const isList = isTextList(elem);
    const isFirst = elem.previousElementSibling ? !isTextList(elem.previousElementSibling) : true;
    return !(isList && isFirst);
  },
  data: elem => {
    const match = elem.textContent.match(listLikeRegex);
    return {
      orderedStart: match[1] ? match[1] : null,
      formatAsList: false
    };
  },
  form: () => [{
    label: "\u30EA\u30B9\u30C8\u5F62\u5F0F",
    checkbox: true,
    dataKey: "formatAsList"
  }],
  update: function (elem, data) {
    const rootElem = elem.parentNode;

    if (data.formatAsList) {
      const isOrdered = Boolean(data.orderedStart);
      const listContainer = document.createElement(isOrdered ? "ol" : "ul");

      if (isOrdered) {
        listContainer.setAttribute("type", data.orderedStart);
        listContainer.setAttribute("start", data.orderedStart);
      }

      let cursor = elem;

      while (cursor) {
        if (!isTextList(cursor)) break;
        const nextIsOrdered = Boolean(cursor.textContent.match(listLikeRegex)[1]);
        if (isOrdered !== nextIsOrdered) break;
        splitParagraphsByBreak(cursor);
        const li = document.createElement("li");
        listContainer.appendChild(li);
        moveContents(cursor, li);
        let nextSibling = cursor.nextElementSibling; // Remove the now empty siblings
        // Skip elem because elem is replaced later.

        if (cursor !== elem) cursor.parentNode.removeChild(cursor);
        cursor = nextSibling;
        cleanListItem(li);
      }

      rootElem.replaceChild(listContainer, elem);
      return listContainer;
    }

    return elem;
  },
  rootNode: function (elem) {
    return elem.parentNode;
  },
  message: () => "\u30EA\u30B9\u30C8\u306F\u30EA\u30B9\u30C8\u5F62\u5F0F\u306B\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002",
  why: () => "\u30A2\u30A4\u30C6\u30E0\u3092\u30EA\u30B9\u30C8\u5F62\u5F0F\u306B\u8996\u899A\u7684\u306B\u30D5\u30A9\u30FC\u30DE\u30C3\u30C8\u3059\u308B\u30DE\u30FC\u30AF\u30A2\u30C3\u30D7\u304C\u4F7F\u7528\u3055\u308C\u307E\u3059\u304C\u3001\u30EA\u30B9\u30C8\u306E\u95A2\u4FC2\u3092\u793A\u5506\u3059\u308B\u3082\u306E\u3067\u306F\u306A\u304F\u3001\u30E6\u30FC\u30B6\u304C\u60C5\u5831\u3092\u30CA\u30D3\u30B2\u30FC\u30C8\u3059\u308B\u306E\u306F\u96E3\u3057\u3044\u304B\u3082\u3057\u308C\u307E\u305B\u3093\u3002",
  link: "https://www.w3.org/TR/2016/NOTE-WCAG20-TECHS-20161007/H48",
  linkText: () => "\u30EA\u30B9\u30C8\u4F7F\u7528\u306E\u8A73\u7D30"
};
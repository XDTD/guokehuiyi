"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _formatMessage = _interopRequireDefault(require("../format-message"));

var _dom = require("../utils/dom");

/* Headings Sequence rule
 * this rule is ensuring that heading tags (H1-H6) are layed out in sequential
 * order for organizing your site.
 *
 * this rule only looks at H2-H6 headings. all other tags pass.
 * this rule will walk 'up-down' the dom to find the heading tag that is
 * laid out previous to the heading tag being checked.
 * this rule will see if the heading tag number of the previous heading is
 * one more than one less than it's own heading tag and will fail if so
 * this rule will check to see if there is no previous heading tag and will
 * fail the test if so
 */
const isHtag = elem => {
  const allHTags = {
    H1: true,
    H2: true,
    H3: true,
    H4: true,
    H5: true,
    H6: true
  };
  return elem && allHTags[elem.tagName] === true;
}; // gets the H tag that is furthest down in the tree from elem(inclusive)


const getHighestOrderHForElem = elem => {
  const allHForElem = Array.prototype.slice.call(elem.querySelectorAll("H1,H2,H3,H4,H5,H6"));

  if (allHForElem.length > 0) {
    return allHForElem.reverse()[0];
  }

  if (isHtag(elem)) {
    return elem;
  }

  return void 0;
}; // gets all siblings of elem that come before the elem ordered by nearest to
// elem


const getPrevSiblings = elem => {
  let ret = [];

  if (!elem || !elem.parentElement || !elem.parentElement.children) {
    return ret;
  }

  const sibs = elem.parentElement.children;

  for (var i = 0; i < sibs.length; i++) {
    if (sibs[i] === elem) {
      break;
    }

    ret.unshift(sibs[i]);
  }

  return ret;
};

const searchPrevSiblings = elem => {
  const sibs = getPrevSiblings(elem);
  let ret;

  for (let i = 0; i < sibs.length; i++) {
    ret = getHighestOrderHForElem(sibs[i]);

    if (ret) {
      break;
    }
  }

  return ret;
};

const _walkUpTree = elem => {
  let ret;

  if (!elem || elem.tagName === "BODY") {
    return void 0;
  }

  if (isHtag(elem)) {
    return elem;
  }

  ret = searchPrevSiblings(elem);

  if (!ret) {
    ret = _walkUpTree(elem.parentElement);
  }

  return ret;
};

const walkUpTree = elem => {
  let ret = searchPrevSiblings(elem);

  if (!ret) {
    ret = _walkUpTree(elem.parentElement);
  }

  return ret;
};

const getPriorHeading = elem => {
  return walkUpTree(elem);
}; // a valid prior H tag is greater or equal to one less than current


const getValidHeadings = elem => {
  const hNum = +elem.tagName.substring(1);
  const ret = {};

  for (var i = hNum - 1; i <= 6; i++) {
    ret[`H${i}`] = true;
  }

  return ret;
};

var _default = {
  id: "headings-sequence",
  test: elem => {
    const testTags = {
      H2: true,
      H3: true,
      H4: true,
      H5: true,
      H6: true
    };

    if (testTags[elem.tagName] !== true) {
      return true;
    }

    const validHeadings = getValidHeadings(elem);
    const priorHeading = getPriorHeading(elem);

    if (priorHeading) {
      return validHeadings[priorHeading.tagName];
    }

    return true;
  },
  data: elem => {
    return {
      action: "nothing"
    };
  },
  form: () => [{
    label: "\u5B9F\u884C\u3059\u308B\u30A2\u30AF\u30B7\u30E7\u30F3\uFF1A",
    dataKey: "action",
    options: [["nothing", "\u305D\u306E\u307E\u307E\u306B\u3059\u308B"], ["elem", "\u898B\u51FA\u3057\u30D2\u30A8\u30A2\u30EB\u30AD\u30FC\u3092\u4FEE\u6B63\u3059\u308B"], ["modify", "\u898B\u51FA\u3057\u30B9\u30BF\u30A4\u30EB\u3092\u524A\u9664\u3059\u308B"]]
  }],
  update: (elem, data) => {
    if (!data || !data.action || data.action === "nothing") {
      return elem;
    }

    switch (data.action) {
      case "elem":
        {
          const priorH = getPriorHeading(elem);
          const hIdx = priorH ? +priorH.tagName.substring(1) : 0;
          return (0, _dom.changeTag)(elem, `H${hIdx + 1}`);
        }

      case "modify":
        {
          return (0, _dom.changeTag)(elem, "p");
        }
    }
  },
  message: () => "\u898B\u51FA\u3057\u30EC\u30D9\u30EB\u306F\u30B9\u30AD\u30C3\u30D7\u3057\u306A\u3044\u3067\u304F\u3060\u3055\u3044\u3002",
  why: () => "\u8996\u8A8D\u30E6\u30FC\u30B6\u30FC\u306F\u5927\u304D\u304F\u592A\u5B57\u306E\u898B\u51FA\u3057\u3092\u63A2\u3057\u3001Web\u30DA\u30FC\u30B8\u3092\u3059\u3070\u3084\u304F\u53C2\u7167\u3057\u307E\u3059\u3002\u30B9\u30AF\u30EA\u30FC\u30F3\u30EA\u30FC\u30C0\u30FC\u306E\u30E6\u30FC\u30B6\u30FC\u306F\u3001\u6587\u8108\u306B\u57FA\u3065\u3044\u305F\u7406\u89E3\u3092\u884C\u3046\u969B\u306B\u30D8\u30C3\u30C0\u30FC\u306B\u4F9D\u5B58\u3057\u3066\u3044\u307E\u3059\u3002\u30D8\u30C3\u30C0\u30FC\u306F\u9069\u5207\u306A\u69CB\u9020\u3092\u4F7F\u7528\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002",
  link: "https://www.w3.org/TR/WCAG20-TECHS/G141.html",
  linkText: () => "\u30DA\u30FC\u30B8\u30D8\u30C3\u30C0\u30FC\u306E\u6574\u7406\u306E\u8A73\u7D30"
};
exports.default = _default;
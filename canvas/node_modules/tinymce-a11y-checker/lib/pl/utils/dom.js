"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.walk = walk;
exports.select = select;
exports.prepend = prepend;
exports.changeTag = changeTag;
exports.pathForNode = pathForNode;
exports.nodeByPath = nodeByPath;
exports.onlyContainsLink = onlyContainsLink;
exports.splitStyleAttribute = splitStyleAttribute;
exports.createStyleString = createStyleString;
exports.hasTextNode = hasTextNode;

var _indicate = _interopRequireDefault(require("./indicate"));

const ELEMENT_NODE = 1;
const WALK_BATCH_SIZE = 25;
const _indexOf = Array.prototype.indexOf;

function walk(node, fn, done) {
  const stack = [{
    node,
    index: 0
  }];

  const processBatch = () => {
    let batchRemaining = WALK_BATCH_SIZE;

    while (stack.length > 0 && batchRemaining > 0) {
      const depth = stack.length - 1;
      const node = stack[depth].node.childNodes[stack[depth].index];

      if (node) {
        stack[depth].index += 1;

        if (node.nodeType === ELEMENT_NODE) {
          fn(node);
          stack.push({
            node,
            index: 0
          });
          batchRemaining -= 0;
        }
      } else {
        stack.pop();
      }
    }

    setTimeout(stack.length > 0 ? processBatch : done, 0);
  };

  processBatch();
}

function select(editor, elem, indicateFn = _indicate.default) {
  if (elem == null) {
    return;
  }

  elem.scrollIntoView();
  indicateFn(editor, elem);
}

function prepend(parent, child) {
  if (parent.childNodes.length > 0) {
    parent.insertBefore(child, parent.childNodes[0]);
  } else {
    parent.appendChild(child);
  }
}

function changeTag(elem, tagName) {
  const newElem = elem.ownerDocument.createElement(tagName);

  while (elem.firstChild) {
    newElem.appendChild(elem.firstChild);
  }

  for (let i = elem.attributes.length - 1; i >= 0; --i) {
    newElem.attributes.setNamedItem(elem.attributes[i].cloneNode());
  }

  elem.parentNode.replaceChild(newElem, elem);
  return newElem;
}

function pathForNode(ancestor, decendant) {
  const path = [];
  let node = decendant;

  while (true) {
    if (node == ancestor) {
      return path;
    }

    const parent = node.parentNode;

    if (parent == null) {
      return null;
    }

    path.push(_indexOf.call(parent.childNodes, node));
    node = parent;
  }
}

function nodeByPath(ancestor, path) {
  let node = ancestor;
  let index;

  while ((index = path.pop()) !== void 0) {
    node = node.childNodes[index];

    if (node == null) {
      return null;
    }
  }

  return node;
}

function onlyContainsLink(elem) {
  const links = elem.getElementsByTagName("a");

  if (links.length) {
    return links[0].textContent === elem.textContent;
  } else {
    return false;
  }
}

function splitStyleAttribute(styleString) {
  const split = styleString.split(";");
  return split.reduce((styleObj, attributeValue) => {
    const pair = attributeValue.split(":");

    if (pair.length === 2) {
      styleObj[pair[0].trim()] = pair[1].trim();
    }

    return styleObj;
  }, {});
}

function createStyleString(styleObj) {
  let styleString = Object.keys(styleObj).map(key => `${key}:${styleObj[key]}`).join(";");

  if (styleString) {
    styleString = `${styleString};`;
  }

  return styleString;
}

function hasTextNode(elem) {
  const nodes = Array.from(elem.childNodes);
  return nodes.some(x => x.nodeType === Node.TEXT_NODE);
}